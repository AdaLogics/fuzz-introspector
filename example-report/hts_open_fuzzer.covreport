bgzf_hopen:
  536|     31|{
  537|     31|    BGZF *fp = NULL;
  538|     31|    if (strchr(mode, 'r')) {
  539|     31|        fp = bgzf_read_init(hfp, NULL);
  540|     31|        if (fp == NULL) return NULL;
  541|      0|    } else if (strchr(mode, 'w') || strchr(mode, 'a')) {
  542|      0|        fp = bgzf_write_init(mode);
  543|      0|        if (fp == NULL) return NULL;
  544|      0|    }
  545|      0|    else { errno = EINVAL; return 0; }
  546|       |
  547|     31|    fp->fp = hfp;
  548|     31|    fp->is_be = ed_is_big();
  549|     31|    return fp;
  550|     31|}
bgzf_read_block:
  987|     48|{
  988|     48|    hts_tpool_result *r;
  989|       |
  990|     48|    if (fp->mt) {
  991|      0|    again:
  992|      0|        if (fp->mt->hit_eof) {
  993|       |            // Further reading at EOF will always return 0
  994|      0|            fp->block_length = 0;
  995|      0|            return 0;
  996|      0|        }
  997|      0|        r = hts_tpool_next_result_wait(fp->mt->out_queue);
  998|      0|        bgzf_job *j = r ? (bgzf_job *)hts_tpool_result_data(r) : NULL;
  999|       |
 1000|      0|        if (!j || j->errcode == BGZF_ERR_MT) {
 1001|      0|            if (!fp->mt->free_block) {
 1002|      0|                fp->uncompressed_block = malloc(2 * BGZF_MAX_BLOCK_SIZE);
 1003|      0|                if (fp->uncompressed_block == NULL) return -1;
 1004|      0|                fp->compressed_block = (char *)fp->uncompressed_block + BGZF_MAX_BLOCK_SIZE;
 1005|      0|            } // else it's already allocated with malloc, maybe even in-use.
 1006|      0|            if (mt_destroy(fp->mt) < 0)
 1007|      0|                fp->errcode = BGZF_ERR_IO;
 1008|      0|            fp->mt = NULL;
 1009|      0|            hts_tpool_delete_result(r, 0);
 1010|       |
 1011|      0|            goto single_threaded;
 1012|      0|        }
 1013|       |
 1014|      0|        if (j->errcode) {
 1015|      0|            fp->errcode = j->errcode;
 1016|      0|            hts_log_error("BGZF decode jobs returned error %d "
 1017|      0|                          "for block offset %"PRId64,
 1018|      0|                          j->errcode, j->block_address);
 1019|      0|            return -1;
 1020|      0|        }
 1021|       |
 1022|      0|        if (j->hit_eof) {
 1023|      0|            if (!fp->last_block_eof && !fp->no_eof_block) {
 1024|      0|                fp->no_eof_block = 1;
 1025|      0|                hts_log_warning("EOF marker is absent. The input may be truncated");
 1026|      0|            }
 1027|      0|            fp->mt->hit_eof = 1;
 1028|      0|        }
 1029|       |
 1030|       |        // Zero length blocks in the middle of a file are (wrongly)
 1031|       |        // considered as EOF by many callers.  We work around this by
 1032|       |        // trying again to see if we hit a genuine EOF.
 1033|      0|        if (!j->hit_eof && j->uncomp_len == 0) {
 1034|      0|            fp->last_block_eof = 1;
 1035|      0|            hts_tpool_delete_result(r, 0);
 1036|      0|            goto again;
 1037|      0|        }
 1038|       |
 1039|       |        // block_length=0 and block_offset set by bgzf_seek.
 1040|      0|        if (fp->block_length != 0) fp->block_offset = 0;
 1041|      0|        if (!j->hit_eof) fp->block_address = j->block_address;
 1042|      0|        fp->block_clength = j->comp_len;
 1043|      0|        fp->block_length = j->uncomp_len;
 1044|       |        // bgzf_read() can change fp->block_length
 1045|      0|        fp->last_block_eof = (fp->block_length == 0);
 1046|       |
 1047|      0|        if ( j->uncomp_len && j->fp->idx_build_otf )
 1048|      0|        {
 1049|      0|            bgzf_index_add_block(j->fp);
 1050|      0|            j->fp->idx->ublock_addr += j->uncomp_len;
 1051|      0|        }
 1052|       |
 1053|       |        // Steal the data block as it's quicker than a memcpy.
 1054|       |        // We just need to make sure we delay the pool free.
 1055|      0|        if (fp->mt->curr_job) {
 1056|      0|            pthread_mutex_lock(&fp->mt->job_pool_m);
 1057|      0|            pool_free(fp->mt->job_pool, fp->mt->curr_job);
 1058|      0|            pthread_mutex_unlock(&fp->mt->job_pool_m);
 1059|      0|        }
 1060|      0|        fp->uncompressed_block = j->uncomp_data;
 1061|      0|        fp->mt->curr_job = j;
 1062|      0|        if (fp->mt->free_block) {
 1063|      0|            free(fp->mt->free_block); // clear up last non-mt block
 1064|      0|            fp->mt->free_block = NULL;
 1065|      0|        }
 1066|       |
 1067|      0|        hts_tpool_delete_result(r, 0);
 1068|      0|        return 0;
 1069|      0|    }
 1070|       |
 1071|     48|    uint8_t header[BLOCK_HEADER_LENGTH], *compressed_block;
 1072|     48|    int count, size, block_length, remaining;
 1073|       |
 1074|     48| single_threaded:
 1075|     48|    size = 0;
 1076|       |
 1077|     48|    int64_t block_address;
 1078|     48|    block_address = bgzf_htell(fp);
 1079|       |
 1080|       |    // Reading an uncompressed file
 1081|     48|    if ( !fp->is_compressed )
 1082|     48|    {
 1083|     48|        count = hread(fp->fp, fp->uncompressed_block, BGZF_MAX_BLOCK_SIZE);
 1084|     48|        if (count < 0)  // Error
 1085|      0|        {
 1086|      0|            hts_log_error("Failed to read uncompressed data "
 1087|      0|                          "at offset %"PRId64"%s%s",
 1088|      0|                          block_address, errno ? ": " : "", strerror(errno));
 1089|      0|            fp->errcode |= BGZF_ERR_IO;
 1090|      0|            return -1;
 1091|      0|        }
 1092|     48|        else if (count == 0)  // EOF
 1093|     18|        {
 1094|     18|            fp->block_length = 0;
 1095|     18|            return 0;
 1096|     18|        }
 1097|     30|        if (fp->block_length != 0) fp->block_offset = 0;
 1098|     30|        fp->block_address = block_address;
 1099|     30|        fp->block_length = count;
 1100|     30|        return 0;
 1101|     30|    }
 1102|       |
 1103|       |    // Reading compressed file
 1104|      0|    if ( fp->is_gzip && fp->gz_stream ) // is this is an initialized gzip stream?
 1105|      0|    {
 1106|      0|        count = inflate_gzip_block(fp);
 1107|      0|        if ( count<0 )
 1108|      0|        {
 1109|      0|            hts_log_error("Reading GZIP stream failed at offset %"PRId64,
 1110|      0|                          block_address);
 1111|      0|            fp->errcode |= BGZF_ERR_ZLIB;
 1112|      0|            return -1;
 1113|      0|        }
 1114|      0|        fp->block_length = count;
 1115|      0|        fp->block_address = block_address;
 1116|      0|        return 0;
 1117|      0|    }
 1118|      0|    if (fp->cache_size && load_block_from_cache(fp, block_address)) return 0;
 1119|       |
 1120|       |    // loop to skip empty bgzf blocks
 1121|      0|    while (1)
 1122|      0|    {
 1123|      0|        count = hread(fp->fp, header, sizeof(header));
 1124|      0|        if (count == 0) { // no data read
 1125|      0|            if (!fp->last_block_eof && !fp->no_eof_block && !fp->is_gzip) {
 1126|      0|                fp->no_eof_block = 1;
 1127|      0|                hts_log_warning("EOF marker is absent. The input may be truncated");
 1128|      0|            }
 1129|      0|            fp->block_length = 0;
 1130|      0|            return 0;
 1131|      0|        }
 1132|      0|        int ret = 0;
 1133|      0|        if ( count != sizeof(header) || (ret=check_header(header))==-2 )
 1134|      0|        {
 1135|      0|            fp->errcode |= BGZF_ERR_HEADER;
 1136|      0|            hts_log_error("%s BGZF header at offset %"PRId64,
 1137|      0|                          ret ? "Invalid" : "Failed to read",
 1138|      0|                          block_address);
 1139|      0|            return -1;
 1140|      0|        }
 1141|      0|        if ( ret==-1 )
 1142|      0|        {
 1143|       |            // GZIP, not BGZF
 1144|      0|            uint8_t *cblock = (uint8_t*)fp->compressed_block;
 1145|      0|            memcpy(cblock, header, sizeof(header));
 1146|      0|            count = hread(fp->fp, cblock+sizeof(header), BGZF_BLOCK_SIZE - sizeof(header)) + sizeof(header);
 1147|       |
 1148|      0|            fp->is_gzip = 1;
 1149|      0|            fp->gz_stream = (z_stream*) calloc(1,sizeof(z_stream));
 1150|       |            // Set up zlib, using a window size of 15, and its built-in GZIP header processing (+16).
 1151|      0|            int ret = inflateInit2(fp->gz_stream, 15 + 16);
 1152|      0|            if (ret != Z_OK)
 1153|      0|            {
 1154|      0|                hts_log_error("Call to inflateInit2 failed: %s", bgzf_zerr(ret, fp->gz_stream));
 1155|      0|                fp->errcode |= BGZF_ERR_ZLIB;
 1156|      0|                return -1;
 1157|      0|            }
 1158|      0|            fp->gz_stream->avail_in = count;
 1159|      0|            fp->gz_stream->next_in  = cblock;
 1160|      0|            count = inflate_gzip_block(fp);
 1161|      0|            if ( count<0 )
 1162|      0|            {
 1163|      0|                hts_log_error("Reading GZIP stream failed at offset %"PRId64,
 1164|      0|                              block_address);
 1165|      0|                fp->errcode |= BGZF_ERR_ZLIB;
 1166|      0|                return -1;
 1167|      0|            }
 1168|      0|            fp->block_length = count;
 1169|      0|            fp->block_address = block_address;
 1170|      0|            if ( fp->idx_build_otf ) return -1; // cannot build index for gzip
 1171|      0|            return 0;
 1172|      0|        }
 1173|      0|        size = count;
 1174|      0|        block_length = unpackInt16((uint8_t*)&header[16]) + 1; // +1 because when writing this number, we used "-1"
 1175|      0|        if (block_length < BLOCK_HEADER_LENGTH)
 1176|      0|        {
 1177|      0|            hts_log_error("Invalid BGZF block length at offset %"PRId64,
 1178|      0|                          block_address);
 1179|      0|            fp->errcode |= BGZF_ERR_HEADER;
 1180|      0|            return -1;
 1181|      0|        }
 1182|      0|        compressed_block = (uint8_t*)fp->compressed_block;
 1183|      0|        memcpy(compressed_block, header, BLOCK_HEADER_LENGTH);
 1184|      0|        remaining = block_length - BLOCK_HEADER_LENGTH;
 1185|      0|        count = hread(fp->fp, &compressed_block[BLOCK_HEADER_LENGTH], remaining);
 1186|      0|        if (count != remaining) {
 1187|      0|            hts_log_error("Failed to read BGZF block data at offset %"PRId64
 1188|      0|                          " expected %d bytes; hread returned %d",
 1189|      0|                          block_address, remaining, count);
 1190|      0|            fp->errcode |= BGZF_ERR_IO;
 1191|      0|            return -1;
 1192|      0|        }
 1193|      0|        size += count;
 1194|      0|        if ((count = inflate_block(fp, block_length)) < 0) {
 1195|      0|            hts_log_debug("Inflate block operation failed for "
 1196|      0|                          "block at offset %"PRId64": %s",
 1197|      0|                          block_address, bgzf_zerr(count, NULL));
 1198|      0|            fp->errcode |= BGZF_ERR_ZLIB;
 1199|      0|            return -1;
 1200|      0|        }
 1201|      0|        fp->last_block_eof = (count == 0);
 1202|      0|        if ( count ) break;     // otherwise an empty bgzf block
 1203|      0|        block_address = bgzf_htell(fp); // update for new block start
 1204|      0|    }
 1205|      0|    if (fp->block_length != 0) fp->block_offset = 0; // Do not reset offset if this read follows a seek.
 1206|      0|    fp->block_address = block_address;
 1207|      0|    fp->block_length = count;
 1208|      0|    if ( fp->idx_build_otf )
 1209|      0|    {
 1210|      0|        bgzf_index_add_block(fp);
 1211|      0|        fp->idx->ublock_addr += count;
 1212|      0|    }
 1213|      0|    cache_block(fp, size);
 1214|      0|    return 0;
 1215|      0|}
bgzf_read:
 1218|    134|{
 1219|    134|    ssize_t bytes_read = 0;
 1220|    134|    uint8_t *output = (uint8_t*)data;
 1221|    134|    if (length <= 0) return 0;
 1222|    123|    assert(fp->is_write == 0);
 1223|    240|    while (bytes_read < length) {
 1224|    135|        int copy_length, available = fp->block_length - fp->block_offset;
 1225|    135|        uint8_t *buffer;
 1226|    135|        if (available <= 0) {
 1227|     48|            int ret = bgzf_read_block(fp);
 1228|     48|            if (ret != 0) {
 1229|      0|                hts_log_error("Read block operation failed with error %d after %zd of %zu bytes", fp->errcode, bytes_read, length);
 1230|      0|                fp->errcode |= BGZF_ERR_ZLIB;
 1231|      0|                return -1;
 1232|      0|            }
 1233|     48|            available = fp->block_length - fp->block_offset;
 1234|     48|            if (available == 0) {
 1235|     18|                if (fp->block_length == 0)
 1236|     18|                    break; // EOF
 1237|       |
 1238|       |                // Offset was at end of block (see commit e9863a0)
 1239|      0|                fp->block_address = bgzf_htell(fp);
 1240|      0|                fp->block_offset = fp->block_length = 0;
 1241|      0|                continue;
 1242|     30|            } else if (available < 0) {
 1243|       |                // Block offset was set to an invalid coordinate
 1244|      0|                hts_log_error("BGZF block offset %d set beyond block size %d",
 1245|      0|                              fp->block_offset, fp->block_length);
 1246|      0|                fp->errcode |= BGZF_ERR_MISUSE;
 1247|      0|                return -1;
 1248|      0|            }
 1249|    117|        }
 1250|    117|        copy_length = length - bytes_read < available? length - bytes_read : available;
 1251|    117|        buffer = (uint8_t*)fp->uncompressed_block;
 1252|    117|        memcpy(output, buffer + fp->block_offset, copy_length);
 1253|    117|        fp->block_offset += copy_length;
 1254|    117|        output += copy_length;
 1255|    117|        bytes_read += copy_length;
 1256|       |
 1257|       |        // For raw gzip streams this avoids short reads.
 1258|    117|        if (fp->block_offset == fp->block_length) {
 1259|     19|            fp->block_address = bgzf_htell(fp);
 1260|     19|            fp->block_offset = fp->block_length = 0;
 1261|     19|        }
 1262|    117|    }
 1263|       |
 1264|    123|    fp->uncompressed_address += bytes_read;
 1265|       |
 1266|    123|    return bytes_read;
 1267|    123|}
bgzf_close:
 2053|     31|{
 2054|     31|    int ret, block_length;
 2055|     31|    if (fp == 0) return -1;
 2056|     31|    if (fp->is_write && fp->is_compressed) {
 2057|      0|        if (bgzf_flush(fp) != 0) {
 2058|      0|            bgzf_close_mt(fp);
 2059|      0|            return -1;
 2060|      0|        }
 2061|      0|        fp->compress_level = -1;
 2062|      0|        block_length = deflate_block(fp, 0); // write an empty block
 2063|      0|        if (block_length < 0) {
 2064|      0|            hts_log_debug("Deflate block operation failed: %s", bgzf_zerr(block_length, NULL));
 2065|      0|            bgzf_close_mt(fp);
 2066|      0|            return -1;
 2067|      0|        }
 2068|      0|        if (hwrite(fp->fp, fp->compressed_block, block_length) < 0
 2069|      0|            || hflush(fp->fp) != 0) {
 2070|      0|            hts_log_error("File write failed");
 2071|      0|            fp->errcode |= BGZF_ERR_IO;
 2072|      0|            return -1;
 2073|      0|        }
 2074|     31|    }
 2075|       |
 2076|     31|    bgzf_close_mt(fp);
 2077|       |
 2078|     31|    if ( fp->is_gzip )
 2079|      0|    {
 2080|      0|        if (fp->gz_stream == NULL) ret = Z_OK;
 2081|      0|        else if (!fp->is_write) ret = inflateEnd(fp->gz_stream);
 2082|      0|        else ret = deflateEnd(fp->gz_stream);
 2083|      0|        if (ret != Z_OK) {
 2084|      0|            hts_log_error("Call to inflateEnd/deflateEnd failed: %s", bgzf_zerr(ret, NULL));
 2085|      0|        }
 2086|      0|        free(fp->gz_stream);
 2087|      0|    }
 2088|     31|    ret = hclose(fp->fp);
 2089|     31|    if (ret != 0) return -1;
 2090|     31|    bgzf_index_destroy(fp);
 2091|     31|    free(fp->uncompressed_block);
 2092|     31|    free_cache(fp);
 2093|     31|    ret = fp->errcode ? -1 : 0;
 2094|     31|    free(fp);
 2095|     31|    return ret;
 2096|     31|}
bgzf_check_EOF:
 2104|     22|int bgzf_check_EOF(BGZF *fp) {
 2105|     22|    int has_eof;
 2106|       |
 2107|     22|    if (fp->mt) {
 2108|      0|        pthread_mutex_lock(&fp->mt->command_m);
 2109|       |        // fp->mt->command state transitions should be:
 2110|       |        // NONE -> HAS_EOF -> HAS_EOF_DONE -> NONE
 2111|       |        // (HAS_EOF -> HAS_EOF_DONE happens in bgzf_mt_reader thread)
 2112|      0|        if (fp->mt->command != CLOSE)
 2113|      0|            fp->mt->command = HAS_EOF;
 2114|      0|        pthread_cond_signal(&fp->mt->command_c);
 2115|      0|        hts_tpool_wake_dispatch(fp->mt->out_queue);
 2116|      0|        do {
 2117|      0|            if (fp->mt->command == CLOSE) {
 2118|       |                // possible error in bgzf_mt_reader
 2119|      0|                pthread_mutex_unlock(&fp->mt->command_m);
 2120|      0|                return 0;
 2121|      0|            }
 2122|      0|            pthread_cond_wait(&fp->mt->command_c, &fp->mt->command_m);
 2123|      0|            switch (fp->mt->command) {
 2124|      0|            case HAS_EOF_DONE: break;
 2125|      0|            case HAS_EOF:
 2126|       |                // Resend signal intended for bgzf_mt_reader()
 2127|      0|                pthread_cond_signal(&fp->mt->command_c);
 2128|      0|                break;
 2129|      0|            case CLOSE:
 2130|      0|                continue;
 2131|      0|            default:
 2132|      0|                abort();  // Should not get to any other state
 2133|      0|            }
 2134|      0|        } while (fp->mt->command != HAS_EOF_DONE);
 2135|      0|        fp->mt->command = NONE;
 2136|      0|        has_eof = fp->mt->eof;
 2137|      0|        pthread_mutex_unlock(&fp->mt->command_m);
 2138|     22|    } else {
 2139|     22|        has_eof = bgzf_check_EOF_common(fp);
 2140|     22|    }
 2141|       |
 2142|     22|    fp->no_eof_block = (has_eof == 0);
 2143|       |
 2144|     22|    return has_eof;
 2145|     22|}
bgzf_index_destroy:
 2294|     31|{
 2295|     31|    if ( !fp->idx ) return;
 2296|      0|    free(fp->idx->offs);
 2297|      0|    free(fp->idx);
 2298|      0|    fp->idx = NULL;
 2299|      0|    fp->idx_build_otf = 0;
 2300|      0|}
bgzf.c:bgzf_read_init:
  391|     31|{
  392|     31|    BGZF *fp;
  393|     31|    uint8_t magic[18];
  394|     31|    ssize_t n = hpeek(hfpr, magic, 18);
  395|     31|    if (n < 0) return NULL;
  396|       |
  397|     31|    fp = (BGZF*)calloc(1, sizeof(BGZF));
  398|     31|    if (fp == NULL) return NULL;
  399|       |
  400|     31|    fp->is_write = 0;
  401|     31|    fp->uncompressed_block = malloc(2 * BGZF_MAX_BLOCK_SIZE);
  402|     31|    if (fp->uncompressed_block == NULL) { free(fp); return NULL; }
  403|     31|    fp->compressed_block = (char *)fp->uncompressed_block + BGZF_MAX_BLOCK_SIZE;
  404|     31|    fp->is_compressed = (n==18 && magic[0]==0x1f && magic[1]==0x8b);
  405|     31|    fp->is_gzip = ( !fp->is_compressed || ((magic[3]&4) && memcmp(&magic[12], "BC\2\0",4)==0) ) ? 0 : 1;
  406|     31|    if (fp->is_compressed && (magic[3]&4) && memcmp(&magic[12], "RAZF", 4)==0) {
  407|      0|        hts_log_error("Cannot decompress legacy RAZF format");
  408|      0|        razf_info(hfpr, filename);
  409|      0|        free(fp->uncompressed_block);
  410|      0|        free(fp);
  411|      0|        errno = EFTYPE;
  412|      0|        return NULL;
  413|      0|    }
  414|     31|#ifdef BGZF_CACHE
  415|     31|    if (!(fp->cache = malloc(sizeof(*fp->cache)))) {
  416|      0|        free(fp->uncompressed_block);
  417|      0|        free(fp);
  418|      0|        return NULL;
  419|      0|    }
  420|     31|    if (!(fp->cache->h = kh_init(cache))) {
  421|      0|        free(fp->uncompressed_block);
  422|      0|        free(fp->cache);
  423|      0|        free(fp);
  424|      0|        return NULL;
  425|      0|    }
  426|     31|    fp->cache->last_pos = 0;
  427|     31|#endif
  428|     31|    return fp;
  429|     31|}
bgzf.c:bgzf_htell:
  975|     67|static off_t bgzf_htell(BGZF *fp) {
  976|     67|    if (fp->mt) {
  977|      0|        pthread_mutex_lock(&fp->mt->job_pool_m);
  978|      0|        off_t pos = fp->block_address + fp->block_clength;
  979|      0|        pthread_mutex_unlock(&fp->mt->job_pool_m);
  980|      0|        return pos;
  981|     67|    } else {
  982|     67|        return htell(fp->fp);
  983|     67|    }
  984|     67|}
bgzf.c:bgzf_close_mt:
 2043|     31|static void bgzf_close_mt(BGZF *fp) {
 2044|     31|    if (fp->mt) {
 2045|      0|        if (!fp->mt->free_block)
 2046|      0|            fp->uncompressed_block = NULL;
 2047|      0|        if (mt_destroy(fp->mt) < 0)
 2048|      0|            fp->errcode = BGZF_ERR_IO;
 2049|      0|    }
 2050|     31|}
bgzf.c:free_cache:
  885|     31|{
  886|     31|    khint_t k;
  887|     31|    if (fp->is_write) return;
  888|     31|    khash_t(cache) *h = fp->cache->h;
  889|     31|    for (k = kh_begin(h); k < kh_end(h); ++k)
  890|      0|        if (kh_exist(h, k)) free(kh_val(h, k).block);
  891|     31|    kh_destroy(cache, h);
  892|     31|    free(fp->cache);
  893|     31|}
bgzf.c:bgzf_check_EOF_common:
 1523|     22|{
 1524|     22|    uint8_t buf[28];
 1525|     22|    off_t offset = htell(fp->fp);
 1526|     22|    if (hseek(fp->fp, -28, SEEK_END) < 0) {
 1527|     11|        if (errno == ESPIPE) { hclearerr(fp->fp); return 2; }
 1528|       |#ifdef _WIN32
 1529|       |        if (errno == EINVAL) { hclearerr(fp->fp); return 2; }
 1530|       |#else
 1531|       |        // Assume that EINVAL was due to the file being less than 28 bytes
 1532|       |        // long, rather than being a random error return from an hfile backend.
 1533|       |        // This should be reported as "no EOF block" rather than an error.
 1534|     11|        if (errno == EINVAL) { hclearerr(fp->fp); return 0; }
 1535|      0|#endif
 1536|      0|        return -1;
 1537|      0|    }
 1538|     11|    if ( hread(fp->fp, buf, 28) != 28 ) return -1;
 1539|     11|    if ( hseek(fp->fp, offset, SEEK_SET) < 0 ) return -1;
 1540|     11|    return (memcmp("\037\213\010\4\0\0\0\0\0\377\6\0\102\103\2\0\033\0\3\0\0\0\0\0\0\0\0\0", buf, 28) == 0)? 1 : 0;
 1541|     11|}

cram_decode_compression_header:
  144|      2|                                                           cram_block *b) {
  145|      2|    char *cp, *endp, *cp_copy;
  146|      2|    cram_block_compression_hdr *hdr = calloc(1, sizeof(*hdr));
  147|      2|    int i, err = 0;
  148|      2|    int32_t map_size = 0, map_count = 0;
  149|       |
  150|      2|    if (!hdr)
  151|      0|        return NULL;
  152|       |
  153|      2|    if (b->method != RAW) {
  154|      2|        if (cram_uncompress_block(b)) {
  155|      1|            free(hdr);
  156|      1|            return NULL;
  157|      1|        }
  158|      1|    }
  159|       |
  160|      1|    cp = (char *)b->data;
  161|      1|    endp = cp + b->uncomp_size;
  162|       |
  163|      1|    if (CRAM_MAJOR_VERS(fd->version) == 1) {
  164|      1|        hdr->ref_seq_id = fd->vv.varint_get32(&cp, endp, &err);
  165|      1|        if (CRAM_MAJOR_VERS(fd->version) >= 4) {
  166|      0|            hdr->ref_seq_start = fd->vv.varint_get64(&cp, endp, &err);
  167|      0|            hdr->ref_seq_span  = fd->vv.varint_get64(&cp, endp, &err);
  168|      1|        } else {
  169|      1|            hdr->ref_seq_start = fd->vv.varint_get32(&cp, endp, &err);
  170|      1|            hdr->ref_seq_span  = fd->vv.varint_get32(&cp, endp, &err);
  171|      1|        }
  172|      1|        hdr->num_records   = fd->vv.varint_get32(&cp, endp, &err);
  173|      1|        hdr->num_landmarks = fd->vv.varint_get32(&cp, endp, &err);
  174|      1|        if (hdr->num_landmarks < 0 ||
  175|      1|            hdr->num_landmarks >= SIZE_MAX / sizeof(int32_t) ||
  176|      1|            endp - cp < hdr->num_landmarks) {
  177|      0|            free(hdr);
  178|      0|            return NULL;
  179|      0|        }
  180|      1|        if (!(hdr->landmark = malloc(hdr->num_landmarks * sizeof(int32_t)))) {
  181|      0|            free(hdr);
  182|      0|            return NULL;
  183|      0|        }
  184|      1|        for (i = 0; i < hdr->num_landmarks; i++)
  185|      0|            hdr->landmark[i] = fd->vv.varint_get32(&cp, endp, &err);;
  186|      1|    }
  187|       |
  188|      1|    hdr->preservation_map = kh_init(map);
  189|       |
  190|      1|    memset(hdr->rec_encoding_map, 0,
  191|      1|           CRAM_MAP_HASH * sizeof(hdr->rec_encoding_map[0]));
  192|      1|    memset(hdr->tag_encoding_map, 0,
  193|      1|           CRAM_MAP_HASH * sizeof(hdr->tag_encoding_map[0]));
  194|       |
  195|      1|    if (!hdr->preservation_map) {
  196|      0|        cram_free_compression_header(hdr);
  197|      0|        return NULL;
  198|      0|    }
  199|       |
  200|       |    /* Initialise defaults for preservation map */
  201|      1|    hdr->read_names_included = 0;
  202|      1|    hdr->AP_delta = 1;
  203|      1|    hdr->qs_seq_orient = 1;
  204|      1|    memcpy(hdr->substitution_matrix, "CGTNAGTNACTNACGNACGT", 20);
  205|       |
  206|       |    /* Preservation map */
  207|      1|    map_size  = fd->vv.varint_get32(&cp, endp, &err); cp_copy = cp;
  208|      1|    map_count = fd->vv.varint_get32(&cp, endp, &err);
  209|      1|    for (i = 0; i < map_count; i++) {
  210|      0|        pmap_t hd;
  211|      0|        khint_t k;
  212|      0|        int r;
  213|       |
  214|      0|        if (endp - cp < 3) {
  215|      0|            cram_free_compression_header(hdr);
  216|      0|            return NULL;
  217|      0|        }
  218|      0|        cp += 2;
  219|      0|        switch(CRAM_KEY(cp[-2],cp[-1])) {
  220|      0|        case CRAM_KEY('M','I'): // was mapped QS included in V1.0
  221|      0|        case CRAM_KEY('U','I'): // was unmapped QS included in V1.0
  222|      0|        case CRAM_KEY('P','I'): // was unmapped placed in V1.0
  223|      0|            hd.i = *cp++;
  224|      0|            break;
  225|       |
  226|      0|        case CRAM_KEY('R','N'):
  227|      0|            hd.i = *cp++;
  228|      0|            k = kh_put(map, hdr->preservation_map, "RN", &r);
  229|      0|            if (-1 == r) {
  230|      0|                cram_free_compression_header(hdr);
  231|      0|                return NULL;
  232|      0|            }
  233|       |
  234|      0|            kh_val(hdr->preservation_map, k) = hd;
  235|      0|            hdr->read_names_included = hd.i;
  236|      0|            break;
  237|       |
  238|      0|        case CRAM_KEY('A','P'):
  239|      0|            hd.i = *cp++;
  240|      0|            k = kh_put(map, hdr->preservation_map, "AP", &r);
  241|      0|            if (-1 == r) {
  242|      0|                cram_free_compression_header(hdr);
  243|      0|                return NULL;
  244|      0|            }
  245|       |
  246|      0|            kh_val(hdr->preservation_map, k) = hd;
  247|      0|            hdr->AP_delta = hd.i;
  248|      0|            break;
  249|       |
  250|      0|        case CRAM_KEY('R','R'):
  251|      0|            hd.i = *cp++;
  252|      0|            k = kh_put(map, hdr->preservation_map, "RR", &r);
  253|      0|            if (-1 == r) {
  254|      0|                cram_free_compression_header(hdr);
  255|      0|                return NULL;
  256|      0|            }
  257|       |
  258|      0|            kh_val(hdr->preservation_map, k) = hd;
  259|      0|            hdr->no_ref = !hd.i;
  260|      0|            break;
  261|       |
  262|      0|        case CRAM_KEY('Q','O'):
  263|      0|            hd.i = *cp++;
  264|      0|            k = kh_put(map, hdr->preservation_map, "QO", &r);
  265|      0|            if (-1 == r) {
  266|      0|                cram_free_compression_header(hdr);
  267|      0|                return NULL;
  268|      0|            }
  269|       |
  270|      0|            kh_val(hdr->preservation_map, k) = hd;
  271|      0|            hdr->qs_seq_orient = hd.i;
  272|      0|            break;
  273|       |
  274|      0|        case CRAM_KEY('S','M'):
  275|      0|            if (endp - cp < 5) {
  276|      0|                cram_free_compression_header(hdr);
  277|      0|                return NULL;
  278|      0|            }
  279|      0|            hdr->substitution_matrix[0][(cp[0]>>6)&3] = 'C';
  280|      0|            hdr->substitution_matrix[0][(cp[0]>>4)&3] = 'G';
  281|      0|            hdr->substitution_matrix[0][(cp[0]>>2)&3] = 'T';
  282|      0|            hdr->substitution_matrix[0][(cp[0]>>0)&3] = 'N';
  283|       |
  284|      0|            hdr->substitution_matrix[1][(cp[1]>>6)&3] = 'A';
  285|      0|            hdr->substitution_matrix[1][(cp[1]>>4)&3] = 'G';
  286|      0|            hdr->substitution_matrix[1][(cp[1]>>2)&3] = 'T';
  287|      0|            hdr->substitution_matrix[1][(cp[1]>>0)&3] = 'N';
  288|       |
  289|      0|            hdr->substitution_matrix[2][(cp[2]>>6)&3] = 'A';
  290|      0|            hdr->substitution_matrix[2][(cp[2]>>4)&3] = 'C';
  291|      0|            hdr->substitution_matrix[2][(cp[2]>>2)&3] = 'T';
  292|      0|            hdr->substitution_matrix[2][(cp[2]>>0)&3] = 'N';
  293|       |
  294|      0|            hdr->substitution_matrix[3][(cp[3]>>6)&3] = 'A';
  295|      0|            hdr->substitution_matrix[3][(cp[3]>>4)&3] = 'C';
  296|      0|            hdr->substitution_matrix[3][(cp[3]>>2)&3] = 'G';
  297|      0|            hdr->substitution_matrix[3][(cp[3]>>0)&3] = 'N';
  298|       |
  299|      0|            hdr->substitution_matrix[4][(cp[4]>>6)&3] = 'A';
  300|      0|            hdr->substitution_matrix[4][(cp[4]>>4)&3] = 'C';
  301|      0|            hdr->substitution_matrix[4][(cp[4]>>2)&3] = 'G';
  302|      0|            hdr->substitution_matrix[4][(cp[4]>>0)&3] = 'T';
  303|       |
  304|      0|            hd.p = cp;
  305|      0|            cp += 5;
  306|       |
  307|      0|            k = kh_put(map, hdr->preservation_map, "SM", &r);
  308|      0|            if (-1 == r) {
  309|      0|                cram_free_compression_header(hdr);
  310|      0|                return NULL;
  311|      0|            }
  312|      0|            kh_val(hdr->preservation_map, k) = hd;
  313|      0|            break;
  314|       |
  315|      0|        case CRAM_KEY('T','D'): {
  316|      0|            int sz = cram_decode_TD(fd, cp, endp, hdr); // tag dictionary
  317|      0|            if (sz < 0) {
  318|      0|                cram_free_compression_header(hdr);
  319|      0|                return NULL;
  320|      0|            }
  321|       |
  322|      0|            hd.p = cp;
  323|      0|            cp += sz;
  324|       |
  325|      0|            k = kh_put(map, hdr->preservation_map, "TD", &r);
  326|      0|            if (-1 == r) {
  327|      0|                cram_free_compression_header(hdr);
  328|      0|                return NULL;
  329|      0|            }
  330|      0|            kh_val(hdr->preservation_map, k) = hd;
  331|      0|            break;
  332|      0|        }
  333|       |
  334|      0|        default:
  335|      0|            hts_log_warning("Unrecognised preservation map key %c%c", cp[-2], cp[-1]);
  336|       |            // guess byte;
  337|      0|            cp++;
  338|      0|            break;
  339|      0|        }
  340|      0|    }
  341|      1|    if (cp - cp_copy != map_size) {
  342|      0|        cram_free_compression_header(hdr);
  343|      0|        return NULL;
  344|      0|    }
  345|       |
  346|       |    /* Record encoding map */
  347|      1|    map_size  = fd->vv.varint_get32(&cp, endp, &err); cp_copy = cp;
  348|      1|    map_count = fd->vv.varint_get32(&cp, endp, &err);
  349|      1|    int is_v4 = CRAM_MAJOR_VERS(fd->version) >= 4 ? 1 : 0;
  350|      1|    for (i = 0; i < map_count; i++) {
  351|      0|        char *key = cp;
  352|      0|        int32_t encoding = E_NULL;
  353|      0|        int32_t size = 0;
  354|      0|        ptrdiff_t offset;
  355|      0|        cram_map *m;
  356|      0|        enum cram_DS_ID ds_id;
  357|      0|        enum cram_external_type type;
  358|       |
  359|      0|        if (endp - cp < 4) {
  360|      0|            cram_free_compression_header(hdr);
  361|      0|            return NULL;
  362|      0|        }
  363|       |
  364|      0|        cp += 2;
  365|      0|        encoding = fd->vv.varint_get32(&cp, endp, &err);
  366|      0|        size     = fd->vv.varint_get32(&cp, endp, &err);
  367|       |
  368|      0|        offset = cp - (char *)b->data;
  369|       |
  370|      0|        if (encoding == E_NULL)
  371|      0|            continue;
  372|       |
  373|      0|        if (size < 0 || endp - cp < size) {
  374|      0|            cram_free_compression_header(hdr);
  375|      0|            return NULL;
  376|      0|        }
  377|       |
  378|       |        //printf("%s codes for %.2s\n", cram_encoding2str(encoding), key);
  379|       |
  380|       |        /*
  381|       |         * For CRAM1.0 CF and BF are Byte and not Int.
  382|       |         * Practically speaking it makes no difference unless we have a
  383|       |         * 1.0 format file that stores these in EXTERNAL as only then
  384|       |         * does Byte vs Int matter.
  385|       |         *
  386|       |         * Neither this C code nor Java reference implementations did this,
  387|       |         * so we gloss over it and treat them as int.
  388|       |         */
  389|      0|        ds_id = DS_CORE;
  390|      0|        if (key[0] == 'B' && key[1] == 'F') {
  391|      0|            ds_id = DS_BF; type = E_INT;
  392|      0|        } else if (key[0] == 'C' && key[1] == 'F') {
  393|      0|            ds_id = DS_CF; type = E_INT;
  394|      0|        } else if (key[0] == 'R' && key[1] == 'I') {
  395|      0|            ds_id = DS_RI; type = E_INT;
  396|      0|        } else if (key[0] == 'R' && key[1] == 'L') {
  397|      0|            ds_id = DS_RL; type = E_INT;
  398|      0|        } else if (key[0] == 'A' && key[1] == 'P') {
  399|      0|            ds_id = DS_AP;
  400|      0|            type = is_v4 ? E_SLONG : E_INT;
  401|      0|        } else if (key[0] == 'R' && key[1] == 'G') {
  402|      0|            ds_id = DS_RG;
  403|      0|            type = E_INT;
  404|      0|        } else if (key[0] == 'M' && key[1] == 'F') {
  405|      0|            ds_id = DS_MF; type = E_INT;
  406|      0|        } else if (key[0] == 'N' && key[1] == 'S') {
  407|      0|            ds_id = DS_NS; type = E_INT;
  408|      0|        } else if (key[0] == 'N' && key[1] == 'P') {
  409|      0|            ds_id = DS_NP;
  410|      0|            type = is_v4 ? E_LONG : E_INT;
  411|      0|        } else if (key[0] == 'T' && key[1] == 'S') {
  412|      0|            ds_id = DS_TS;
  413|      0|            type = is_v4 ? E_SLONG : E_INT;
  414|      0|        } else if (key[0] == 'N' && key[1] == 'F') {
  415|      0|            ds_id = DS_NF; type = E_INT;
  416|      0|        } else if (key[0] == 'T' && key[1] == 'C') {
  417|      0|            ds_id = DS_TC; type = E_BYTE;
  418|      0|        } else if (key[0] == 'T' && key[1] == 'N') {
  419|      0|            ds_id = DS_TN; type = E_INT;
  420|      0|        } else if (key[0] == 'F' && key[1] == 'N') {
  421|      0|            ds_id = DS_FN; type = E_INT;
  422|      0|        } else if (key[0] == 'F' && key[1] == 'C') {
  423|      0|            ds_id = DS_FC; type = E_BYTE;
  424|      0|        } else if (key[0] == 'F' && key[1] == 'P') {
  425|      0|            ds_id = DS_FP; type = E_INT;
  426|      0|        } else if (key[0] == 'B' && key[1] == 'S') {
  427|      0|            ds_id = DS_BS; type = E_BYTE;
  428|      0|        } else if (key[0] == 'I' && key[1] == 'N') {
  429|      0|            ds_id = DS_IN; type = E_BYTE_ARRAY;
  430|      0|        } else if (key[0] == 'S' && key[1] == 'C') {
  431|      0|            ds_id = DS_SC; type = E_BYTE_ARRAY;
  432|      0|        } else if (key[0] == 'D' && key[1] == 'L') {
  433|      0|            ds_id = DS_DL; type = E_INT;
  434|      0|        } else if (key[0] == 'B' && key[1] == 'A') {
  435|      0|            ds_id = DS_BA; type = E_BYTE;
  436|      0|        } else if (key[0] == 'B' && key[1] == 'B') {
  437|      0|            ds_id = DS_BB; type = E_BYTE_ARRAY;
  438|      0|        } else if (key[0] == 'R' && key[1] == 'S') {
  439|      0|            ds_id = DS_RS; type = E_INT;
  440|      0|        } else if (key[0] == 'P' && key[1] == 'D') {
  441|      0|            ds_id = DS_PD; type = E_INT;
  442|      0|        } else if (key[0] == 'H' && key[1] == 'C') {
  443|      0|            ds_id = DS_HC; type = E_INT;
  444|      0|        } else if (key[0] == 'M' && key[1] == 'Q') {
  445|      0|            ds_id = DS_MQ; type = E_INT;
  446|      0|        } else if (key[0] == 'R' && key[1] == 'N') {
  447|      0|            ds_id = DS_RN; type = E_BYTE_ARRAY_BLOCK;
  448|      0|        } else if (key[0] == 'Q' && key[1] == 'S') {
  449|      0|            ds_id = DS_QS; type = E_BYTE;
  450|      0|        } else if (key[0] == 'Q' && key[1] == 'Q') {
  451|      0|            ds_id = DS_QQ; type = E_BYTE_ARRAY;
  452|      0|        } else if (key[0] == 'T' && key[1] == 'L') {
  453|      0|            ds_id = DS_TL; type = E_INT;
  454|      0|        } else if (key[0] == 'T' && key[1] == 'M') {
  455|      0|        } else if (key[0] == 'T' && key[1] == 'V') {
  456|      0|        } else {
  457|      0|            hts_log_warning("Unrecognised key: %.2s", key);
  458|      0|        }
  459|       |
  460|      0|        if (ds_id != DS_CORE) {
  461|      0|            if (hdr->codecs[ds_id] != NULL) {
  462|      0|                hts_log_warning("Codec for key %.2s defined more than once",
  463|      0|                                key);
  464|      0|                hdr->codecs[ds_id]->free(hdr->codecs[ds_id]);
  465|      0|            }
  466|      0|            hdr->codecs[ds_id] = cram_decoder_init(hdr, encoding, cp, size,
  467|      0|                                                   type, fd->version, &fd->vv);
  468|      0|            if (!hdr->codecs[ds_id]) {
  469|      0|                cram_free_compression_header(hdr);
  470|      0|                return NULL;
  471|      0|            }
  472|      0|        }
  473|       |
  474|      0|        cp += size;
  475|       |
  476|       |        // Fill out cram_map purely for cram_dump to dump out.
  477|      0|        m = malloc(sizeof(*m));
  478|      0|        if (!m) {
  479|      0|            cram_free_compression_header(hdr);
  480|      0|            return NULL;
  481|      0|        }
  482|      0|        m->key = CRAM_KEY(key[0], key[1]);
  483|      0|        m->encoding = encoding;
  484|      0|        m->size     = size;
  485|      0|        m->offset   = offset;
  486|      0|        m->codec = NULL;
  487|       |
  488|      0|        m->next = hdr->rec_encoding_map[CRAM_MAP(key[0], key[1])];
  489|      0|        hdr->rec_encoding_map[CRAM_MAP(key[0], key[1])] = m;
  490|      0|    }
  491|      1|    if (cp - cp_copy != map_size) {
  492|      0|        cram_free_compression_header(hdr);
  493|      0|        return NULL;
  494|      0|    }
  495|       |
  496|       |    /* Tag encoding map */
  497|      1|    map_size  = fd->vv.varint_get32(&cp, endp, &err); cp_copy = cp;
  498|      1|    map_count = fd->vv.varint_get32(&cp, endp, &err);
  499|      1|    for (i = 0; i < map_count; i++) {
  500|      0|        int32_t encoding = E_NULL;
  501|      0|        int32_t size = 0;
  502|      0|        cram_map *m = malloc(sizeof(*m)); // FIXME: use pooled_alloc
  503|      0|        uint8_t key[3];
  504|       |
  505|      0|        if (!m || endp - cp < 6) {
  506|      0|            free(m);
  507|      0|            cram_free_compression_header(hdr);
  508|      0|            return NULL;
  509|      0|        }
  510|       |
  511|      0|        m->key = fd->vv.varint_get32(&cp, endp, &err);
  512|      0|        key[0] = m->key>>16;
  513|      0|        key[1] = m->key>>8;
  514|      0|        key[2] = m->key;
  515|      0|        encoding = fd->vv.varint_get32(&cp, endp, &err);
  516|      0|        size     = fd->vv.varint_get32(&cp, endp, &err);
  517|       |
  518|      0|        m->encoding = encoding;
  519|      0|        m->size     = size;
  520|      0|        m->offset   = cp - (char *)b->data;
  521|      0|        if (size < 0 || endp - cp < size ||
  522|      0|            !(m->codec = cram_decoder_init(hdr, encoding, cp, size,
  523|      0|                                           E_BYTE_ARRAY_BLOCK, fd->version, &fd->vv))) {
  524|      0|            cram_free_compression_header(hdr);
  525|      0|            free(m);
  526|      0|            return NULL;
  527|      0|        }
  528|       |
  529|      0|        cp += size;
  530|       |
  531|      0|        m->next = hdr->tag_encoding_map[CRAM_MAP(key[0],key[1])];
  532|      0|        hdr->tag_encoding_map[CRAM_MAP(key[0],key[1])] = m;
  533|      0|    }
  534|      1|    if (err || cp - cp_copy != map_size) {
  535|      1|        cram_free_compression_header(hdr);
  536|      1|        return NULL;
  537|      1|    }
  538|       |
  539|      0|    return hdr;
  540|      0|}
cram_get_seq:
 3414|     65|cram_record *cram_get_seq(cram_fd *fd) {
 3415|     65|    cram_container *c;
 3416|     65|    cram_slice *s;
 3417|       |
 3418|     65|    for (;;) {
 3419|     65|        c = fd->ctr;
 3420|     65|        if (c && c->slice && c->slice->curr_rec < c->slice->max_rec) {
 3421|      0|            s = c->slice;
 3422|     65|        } else {
 3423|     65|            if (!(s = cram_next_slice(fd, &c)))
 3424|     65|                return NULL;
 3425|      0|            continue; /* In case slice contains no records */
 3426|      0|        }
 3427|       |
 3428|       |        // No need to lock here as get_seq is running in the main thread,
 3429|       |        // which is also the same one that does the range modifications.
 3430|      0|        if (fd->range.refid != -2) {
 3431|      0|            if (fd->range.refid == -1 && s->crecs[s->curr_rec].ref_id != -1) {
 3432|       |                // Special case when looking for unmapped blocks at end.
 3433|       |                // If these are mixed in with mapped data (c->ref_id == -2)
 3434|       |                // then we need skip until we find the unmapped data, if at all
 3435|      0|                s->curr_rec++;
 3436|      0|                continue;
 3437|      0|            }
 3438|      0|            if (s->crecs[s->curr_rec].ref_id < fd->range.refid &&
 3439|      0|                s->crecs[s->curr_rec].ref_id != -1) {
 3440|       |                // Looking for a mapped read, but not there yet.  Special case
 3441|       |                // as -1 (unmapped) shouldn't be considered < refid.
 3442|      0|                s->curr_rec++;
 3443|      0|                continue;
 3444|      0|            }
 3445|       |
 3446|      0|            if (s->crecs[s->curr_rec].ref_id != fd->range.refid) {
 3447|      0|                fd->eof = 1;
 3448|      0|                cram_free_slice(s);
 3449|      0|                c->slice = NULL;
 3450|      0|                return NULL;
 3451|      0|            }
 3452|       |
 3453|      0|            if (fd->range.refid != -1 && s->crecs[s->curr_rec].apos > fd->range.end) {
 3454|      0|                fd->eof = 1;
 3455|      0|                cram_free_slice(s);
 3456|      0|                c->slice = NULL;
 3457|      0|                return NULL;
 3458|      0|            }
 3459|       |
 3460|      0|            if (fd->range.refid != -1 && s->crecs[s->curr_rec].aend < fd->range.start) {
 3461|      0|                s->curr_rec++;
 3462|      0|                continue;
 3463|      0|            }
 3464|      0|        }
 3465|       |
 3466|      0|        break;
 3467|      0|    }
 3468|       |
 3469|      0|    fd->ctr = c;
 3470|      0|    c->slice = s;
 3471|      0|    return &s->crecs[s->curr_rec++];
 3472|     65|}
cram_get_bam_seq:
 3480|     65|int cram_get_bam_seq(cram_fd *fd, bam_seq_t **bam) {
 3481|     65|    cram_record *cr;
 3482|     65|    cram_container *c;
 3483|     65|    cram_slice *s;
 3484|       |
 3485|     65|    if (!(cr = cram_get_seq(fd)))
 3486|     65|        return -1;
 3487|       |
 3488|      0|    c = fd->ctr;
 3489|      0|    s = c->slice;
 3490|       |
 3491|      0|    return cram_to_bam(fd->header, fd, s, cr, s->curr_rec-1, bam);
 3492|      0|}
cram_drain_rqueue:
 3497|     65|void cram_drain_rqueue(cram_fd *fd) {
 3498|     65|    cram_container *lc = NULL;
 3499|       |
 3500|     65|    if (!fd->pool || !fd->rqueue)
 3501|     65|        return;
 3502|       |
 3503|       |    // drain queue of any in-flight decode jobs
 3504|      0|    while (!hts_tpool_process_empty(fd->rqueue)) {
 3505|      0|        hts_tpool_result *r = hts_tpool_next_result_wait(fd->rqueue);
 3506|      0|        if (!r)
 3507|      0|            break;
 3508|      0|        cram_decode_job *j = (cram_decode_job *)hts_tpool_result_data(r);
 3509|      0|        if (j->c->slice == j->s)
 3510|      0|            j->c->slice = NULL;
 3511|      0|        if (j->c != lc) {
 3512|      0|            if (lc) {
 3513|      0|                if (fd->ctr == lc)
 3514|      0|                    fd->ctr = NULL;
 3515|      0|                if (fd->ctr_mt == lc)
 3516|      0|                    fd->ctr_mt = NULL;
 3517|      0|                cram_free_container(lc);
 3518|      0|            }
 3519|      0|            lc = j->c;
 3520|      0|        }
 3521|      0|        cram_free_slice(j->s);
 3522|      0|        hts_tpool_delete_result(r, 1);
 3523|      0|    }
 3524|       |
 3525|       |    // Also tidy up any pending decode job that we didn't submit to the workers
 3526|       |    // due to the input queue being full.
 3527|      0|    if (fd->job_pending) {
 3528|      0|        cram_decode_job *j = (cram_decode_job *)fd->job_pending;
 3529|      0|        if (j->c->slice == j->s)
 3530|      0|            j->c->slice = NULL;
 3531|      0|        if (j->c != lc) {
 3532|      0|            if (lc) {
 3533|      0|                if (fd->ctr == lc)
 3534|      0|                    fd->ctr = NULL;
 3535|      0|                if (fd->ctr_mt == lc)
 3536|      0|                    fd->ctr_mt = NULL;
 3537|      0|                cram_free_container(lc);
 3538|      0|            }
 3539|      0|            lc = j->c;
 3540|      0|        }
 3541|      0|        cram_free_slice(j->s);
 3542|      0|        free(j);
 3543|      0|        fd->job_pending = NULL;
 3544|      0|    }
 3545|       |
 3546|      0|    if (lc) {
 3547|      0|        if (fd->ctr == lc)
 3548|      0|            fd->ctr = NULL;
 3549|      0|        if (fd->ctr_mt == lc)
 3550|      0|            fd->ctr_mt = NULL;
 3551|      0|        cram_free_container(lc);
 3552|      0|    }
 3553|      0|}
cram_decode.c:cram_next_slice:
 3145|     65|static cram_slice *cram_next_slice(cram_fd *fd, cram_container **cp) {
 3146|     65|    cram_container *c_curr;  // container being consumed via cram_get_seq()
 3147|     65|    cram_slice *s_curr = NULL;
 3148|       |
 3149|       |    // Populate the first container if unknown.
 3150|     65|    if (!(c_curr = fd->ctr)) {
 3151|     65|        if (!(c_curr = cram_first_slice(fd)))
 3152|     65|            return NULL;
 3153|      0|    }
 3154|       |
 3155|       |    // Discard previous slice
 3156|      0|    if ((s_curr = c_curr->slice)) {
 3157|      0|        c_curr->slice = NULL;
 3158|      0|        cram_free_slice(s_curr);
 3159|      0|        s_curr = NULL;
 3160|      0|    }
 3161|       |
 3162|       |    // If we've consumed all slices in this container, also discard
 3163|       |    // the container too.
 3164|      0|    if (c_curr->curr_slice == c_curr->max_slice) {
 3165|      0|        if (fd->ctr == c_curr)
 3166|      0|            fd->ctr = NULL;
 3167|      0|        if (fd->ctr_mt == c_curr)
 3168|      0|            fd->ctr_mt = NULL;
 3169|      0|        cram_free_container(c_curr);
 3170|      0|        c_curr = NULL;
 3171|      0|    }
 3172|       |
 3173|      0|    if (!fd->ctr_mt)
 3174|      0|        fd->ctr_mt = c_curr;
 3175|       |
 3176|       |    // Fetch the next slice (and the container if necessary).
 3177|       |    //
 3178|       |    // If single threaded this loop bails out as soon as it finds
 3179|       |    // a slice in range.  In this case c_next and c_curr end up being
 3180|       |    // the same thing.
 3181|       |    //
 3182|       |    // If multi-threaded, we loop until we have filled out
 3183|       |    // thread pool input queue.  Here c_next and c_curr *may* differ, as
 3184|       |    // can fd->ctr and fd->ctr_mt.
 3185|      0|    for (;;) {
 3186|      0|        cram_container *c_next = fd->ctr_mt;
 3187|      0|        cram_slice *s_next = NULL;
 3188|       |
 3189|       |        // Next slice; either from the last job we failed to push
 3190|       |        // to the input queue or via more I/O.
 3191|      0|        if (fd->job_pending) {
 3192|      0|            cram_decode_job *j = (cram_decode_job *)fd->job_pending;
 3193|      0|            c_next = j->c;
 3194|      0|            s_next = j->s;
 3195|      0|            free(fd->job_pending);
 3196|      0|            fd->job_pending = NULL;
 3197|      0|        } else if (!fd->ooc) {
 3198|      0|        empty_container:
 3199|      0|            if (!c_next || c_next->curr_slice_mt == c_next->max_slice) {
 3200|       |                // new container
 3201|      0|                for(;;) {
 3202|      0|                    if (!(c_next = cram_read_container(fd))) {
 3203|      0|                        if (fd->pool) {
 3204|      0|                            fd->ooc = 1;
 3205|      0|                            break;
 3206|      0|                        }
 3207|       |
 3208|      0|                        return NULL;
 3209|      0|                    }
 3210|      0|                    c_next->curr_slice_mt = c_next->curr_slice;
 3211|       |
 3212|      0|                    if (c_next->length != 0)
 3213|      0|                        break;
 3214|       |
 3215|      0|                    cram_free_container(c_next);
 3216|      0|                }
 3217|      0|                if (fd->ooc)
 3218|      0|                    break;
 3219|       |
 3220|       |                /* Skip containers not yet spanning our range */
 3221|      0|                if (fd->range.refid != -2 && c_next->ref_seq_id != -2) {
 3222|       |                    // ref_id beyond end of range; bail out
 3223|      0|                    if (c_next->ref_seq_id != fd->range.refid) {
 3224|      0|                        cram_free_container(c_next);
 3225|      0|                        fd->ctr_mt = NULL;
 3226|      0|                        fd->ooc = 1;
 3227|      0|                        break;
 3228|      0|                    }
 3229|       |
 3230|       |                    // position beyond end of range; bail out
 3231|      0|                    if (c_next->ref_seq_start > fd->range.end) {
 3232|      0|                        cram_free_container(c_next);
 3233|      0|                        fd->ctr_mt = NULL;
 3234|      0|                        fd->ooc = 1;
 3235|      0|                        break;
 3236|      0|                    }
 3237|       |
 3238|       |                    // before start of range; skip to next container
 3239|      0|                    if (c_next->ref_seq_start + c_next->ref_seq_span-1 <
 3240|      0|                        fd->range.start) {
 3241|      0|                        c_next->curr_slice_mt = c_next->max_slice;
 3242|      0|                        cram_seek(fd, c_next->length, SEEK_CUR);
 3243|      0|                        cram_free_container(c_next);
 3244|      0|                        c_next = NULL;
 3245|      0|                        continue;
 3246|      0|                    }
 3247|      0|                }
 3248|       |
 3249|       |                // Container is valid range, so remember it for restarting
 3250|       |                // this function.
 3251|      0|                fd->ctr_mt = c_next;
 3252|       |
 3253|      0|                if (!(c_next->comp_hdr_block = cram_read_block(fd)))
 3254|      0|                    return NULL;
 3255|      0|                if (c_next->comp_hdr_block->content_type != COMPRESSION_HEADER)
 3256|      0|                    return NULL;
 3257|       |
 3258|      0|                c_next->comp_hdr =
 3259|      0|                    cram_decode_compression_header(fd, c_next->comp_hdr_block);
 3260|      0|                if (!c_next->comp_hdr)
 3261|      0|                    return NULL;
 3262|       |
 3263|      0|                if (!c_next->comp_hdr->AP_delta &&
 3264|      0|                    sam_hrecs_sort_order(fd->header->hrecs) != ORDER_COORD) {
 3265|      0|                    pthread_mutex_lock(&fd->ref_lock);
 3266|      0|                    fd->unsorted = 1;
 3267|      0|                    pthread_mutex_unlock(&fd->ref_lock);
 3268|      0|                }
 3269|      0|            }
 3270|       |
 3271|      0|            if (c_next->num_records == 0) {
 3272|      0|                if (fd->ctr == c_next)
 3273|      0|                    fd->ctr = NULL;
 3274|      0|                if (c_curr == c_next)
 3275|      0|                    c_curr = NULL;
 3276|      0|                if (fd->ctr_mt == c_next)
 3277|      0|                    fd->ctr_mt = NULL;
 3278|      0|                cram_free_container(c_next);
 3279|      0|                c_next = NULL;
 3280|      0|                goto empty_container;
 3281|      0|            }
 3282|       |
 3283|      0|            if (!(s_next = c_next->slice = cram_read_slice(fd)))
 3284|      0|                return NULL;
 3285|       |
 3286|      0|            s_next->slice_num = ++c_next->curr_slice_mt;
 3287|      0|            s_next->curr_rec = 0;
 3288|      0|            s_next->max_rec = s_next->hdr->num_records;
 3289|       |
 3290|      0|            s_next->last_apos = s_next->hdr->ref_seq_start;
 3291|       |
 3292|       |            // We know the container overlaps our range, but with multi-slice
 3293|       |            // containers we may have slices that do not.  Skip these also.
 3294|      0|            if (fd->range.refid != -2 && s_next->hdr->ref_seq_id != -2) {
 3295|       |                // ref_id beyond end of range; bail out
 3296|      0|                if (s_next->hdr->ref_seq_id != fd->range.refid) {
 3297|      0|                    fd->ooc = 1;
 3298|      0|                    cram_free_slice(s_next);
 3299|      0|                    c_next->slice = s_next = NULL;
 3300|      0|                    break;
 3301|      0|                }
 3302|       |
 3303|       |                // position beyond end of range; bail out
 3304|      0|                if (s_next->hdr->ref_seq_start > fd->range.end) {
 3305|      0|                    fd->ooc = 1;
 3306|      0|                    cram_free_slice(s_next);
 3307|      0|                    c_next->slice = s_next = NULL;
 3308|      0|                    break;
 3309|      0|                }
 3310|       |
 3311|       |                // before start of range; skip to next slice
 3312|      0|                if (s_next->hdr->ref_seq_start + s_next->hdr->ref_seq_span-1 <
 3313|      0|                    fd->range.start) {
 3314|      0|                    cram_free_slice(s_next);
 3315|      0|                    c_next->slice = s_next = NULL;
 3316|      0|                    continue;
 3317|      0|                }
 3318|      0|            }
 3319|      0|        } // end: if (!fd->ooc)
 3320|       |
 3321|      0|        if (!c_next || !s_next)
 3322|      0|            break;
 3323|       |
 3324|       |        // Decode the slice, either right now (non-threaded) or by pushing
 3325|       |        // it to the a decode queue (threaded).
 3326|      0|        if (cram_decode_slice_mt(fd, c_next, s_next, fd->header) != 0) {
 3327|      0|            hts_log_error("Failure to decode slice");
 3328|      0|            cram_free_slice(s_next);
 3329|      0|            c_next->slice = NULL;
 3330|      0|            return NULL;
 3331|      0|        }
 3332|       |
 3333|       |        // No thread pool, so don't loop again
 3334|      0|        if (!fd->pool) {
 3335|      0|            c_curr = c_next;
 3336|      0|            s_curr = s_next;
 3337|      0|            break;
 3338|      0|        }
 3339|       |
 3340|       |        // With thread pool, but we have a job pending so our decode queue
 3341|       |        // is full.
 3342|      0|        if (fd->job_pending)
 3343|      0|            break;
 3344|       |
 3345|       |        // Otherwise we're threaded with room in the decode input queue, so
 3346|       |        // keep reading slices for decode.
 3347|       |        // Push it a bit far, to qsize in queue rather than pending arrival,
 3348|       |        // as cram tends to be a bit bursty in decode timings.
 3349|      0|        if (hts_tpool_process_len(fd->rqueue) >
 3350|      0|            hts_tpool_process_qsize(fd->rqueue))
 3351|      0|            break;
 3352|      0|    } // end of for(;;)
 3353|       |
 3354|       |
 3355|       |    // When not threaded we've already have c_curr and s_curr.
 3356|       |    // Otherwise we need get them by pulling off the decode output queue.
 3357|      0|    if (fd->pool) {
 3358|      0|        hts_tpool_result *res;
 3359|      0|        cram_decode_job *j;
 3360|       |
 3361|      0|        if (fd->ooc && hts_tpool_process_empty(fd->rqueue)) {
 3362|      0|            fd->eof = 1;
 3363|      0|            return NULL;
 3364|      0|        }
 3365|       |
 3366|      0|        res = hts_tpool_next_result_wait(fd->rqueue);
 3367|       |
 3368|      0|        if (!res || !hts_tpool_result_data(res)) {
 3369|      0|            hts_log_error("Call to hts_tpool_next_result failed");
 3370|      0|            return NULL;
 3371|      0|        }
 3372|       |
 3373|      0|        j = (cram_decode_job *)hts_tpool_result_data(res);
 3374|      0|        c_curr = j->c;
 3375|      0|        s_curr = j->s;
 3376|       |
 3377|      0|        if (j->exit_code != 0) {
 3378|      0|            hts_log_error("Slice decode failure");
 3379|      0|            fd->eof = 0;
 3380|      0|            hts_tpool_delete_result(res, 1);
 3381|      0|            return NULL;
 3382|      0|        }
 3383|       |
 3384|      0|        hts_tpool_delete_result(res, 1);
 3385|      0|    }
 3386|       |
 3387|      0|    *cp = c_curr;
 3388|       |
 3389|       |    // Update current slice being processed (as opposed to current
 3390|       |    // slice in the multi-threaded reahead.
 3391|      0|    fd->ctr = c_curr;
 3392|      0|    if (c_curr) {
 3393|      0|        c_curr->slice = s_curr;
 3394|      0|        if (s_curr)
 3395|      0|            c_curr->curr_slice = s_curr->slice_num;
 3396|      0|    }
 3397|      0|    if (s_curr)
 3398|      0|        s_curr->curr_rec = 0;
 3399|      0|    else
 3400|      0|        fd->eof = 1;
 3401|       |
 3402|      0|    return s_curr;
 3403|      0|}
cram_decode.c:cram_first_slice:
 3089|     65|static cram_container *cram_first_slice(cram_fd *fd) {
 3090|     65|    cram_container *c;
 3091|       |
 3092|    206|    do {
 3093|    206|        if (fd->ctr)
 3094|    141|            cram_free_container(fd->ctr);
 3095|       |
 3096|    206|        if (!(c = fd->ctr = cram_read_container(fd)))
 3097|     48|            return NULL;
 3098|    158|        c->curr_slice_mt = c->curr_slice;
 3099|    158|    } while (c->length == 0);
 3100|       |
 3101|       |    /*
 3102|       |     * The first container may be a result of a sub-range query.
 3103|       |     * In which case it may still not be the optimal starting point
 3104|       |     * due to skipped containers/slices in the index.
 3105|       |     */
 3106|       |    // No need for locks here as we're in the main thread.
 3107|     17|    if (fd->range.refid != -2) {
 3108|      0|        while (c->ref_seq_id != -2 &&
 3109|      0|               (c->ref_seq_id < fd->range.refid ||
 3110|      0|                (fd->range.refid >= 0 && c->ref_seq_id == fd->range.refid
 3111|      0|                 && c->ref_seq_start + c->ref_seq_span-1 < fd->range.start))) {
 3112|      0|            if (0 != cram_seek(fd, c->length, SEEK_CUR))
 3113|      0|                return NULL;
 3114|      0|            cram_free_container(fd->ctr);
 3115|      0|            do {
 3116|      0|                if (!(c = fd->ctr = cram_read_container(fd)))
 3117|      0|                    return NULL;
 3118|      0|            } while (c->length == 0);
 3119|      0|        }
 3120|       |
 3121|      0|        if (c->ref_seq_id != -2 && c->ref_seq_id != fd->range.refid) {
 3122|      0|            fd->eof = 1;
 3123|      0|            return NULL;
 3124|      0|        }
 3125|     17|    }
 3126|       |
 3127|     17|    if (!(c->comp_hdr_block = cram_read_block(fd)))
 3128|     12|        return NULL;
 3129|      5|    if (c->comp_hdr_block->content_type != COMPRESSION_HEADER)
 3130|      3|        return NULL;
 3131|       |
 3132|      2|    c->comp_hdr = cram_decode_compression_header(fd, c->comp_hdr_block);
 3133|      2|    if (!c->comp_hdr)
 3134|      2|        return NULL;
 3135|      0|    if (!c->comp_hdr->AP_delta &&
 3136|      0|        sam_hrecs_sort_order(fd->header->hrecs) != ORDER_COORD) {
 3137|      0|        pthread_mutex_lock(&fd->ref_lock);
 3138|      0|        fd->unsorted = 1;
 3139|      0|        pthread_mutex_unlock(&fd->ref_lock);
 3140|      0|    }
 3141|       |
 3142|      0|    return c;
 3143|      0|}

itf8_decode_crc:
  191|  2.28k|int itf8_decode_crc(cram_fd *fd, int32_t *val_p, uint32_t *crc) {
  192|  2.28k|    static int nbytes[16] = {
  193|  2.28k|        0,0,0,0, 0,0,0,0,                               // 0000xxxx - 0111xxxx
  194|  2.28k|        1,1,1,1,                                        // 1000xxxx - 1011xxxx
  195|  2.28k|        2,2,                                            // 1100xxxx - 1101xxxx
  196|  2.28k|        3,                                              // 1110xxxx
  197|  2.28k|        4,                                              // 1111xxxx
  198|  2.28k|    };
  199|       |
  200|  2.28k|    static int nbits[16] = {
  201|  2.28k|        0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, // 0000xxxx - 0111xxxx
  202|  2.28k|        0x3f, 0x3f, 0x3f, 0x3f,                         // 1000xxxx - 1011xxxx
  203|  2.28k|        0x1f, 0x1f,                                     // 1100xxxx - 1101xxxx
  204|  2.28k|        0x0f,                                           // 1110xxxx
  205|  2.28k|        0x0f,                                           // 1111xxxx
  206|  2.28k|    };
  207|  2.28k|    unsigned char c[5];
  208|       |
  209|  2.28k|    int32_t val = hgetc(fd->fp);
  210|  2.28k|    if (val == -1)
  211|     55|        return -1;
  212|       |
  213|  2.22k|    c[0]=val;
  214|       |
  215|  2.22k|    int i = nbytes[val>>4];
  216|  2.22k|    val &= nbits[val>>4];
  217|       |
  218|  2.22k|    if (i > 0) {
  219|    333|        if (hread(fd->fp, &c[1], i) < i)
  220|      5|            return -1;
  221|  2.22k|    }
  222|       |
  223|  2.22k|    switch(i) {
  224|  1.89k|    case 0:
  225|  1.89k|        *val_p = val;
  226|  1.89k|        *crc = crc32(*crc, c, 1);
  227|  1.89k|        return 1;
  228|       |
  229|    152|    case 1:
  230|    152|        val = (val<<8) | c[1];
  231|    152|        *val_p = val;
  232|    152|        *crc = crc32(*crc, c, 2);
  233|    152|        return 2;
  234|       |
  235|     88|    case 2:
  236|     88|        val = (val<<8) | c[1];
  237|     88|        val = (val<<8) | c[2];
  238|     88|        *val_p = val;
  239|     88|        *crc = crc32(*crc, c, 3);
  240|     88|        return 3;
  241|       |
  242|     29|    case 3:
  243|     29|        val = (val<<8) | c[1];
  244|     29|        val = (val<<8) | c[2];
  245|     29|        val = (val<<8) | c[3];
  246|     29|        *val_p = val;
  247|     29|        *crc = crc32(*crc, c, 4);
  248|     29|        return 4;
  249|       |
  250|     59|    case 4: // really 3.5 more, why make it different?
  251|     59|        {
  252|     59|            uint32_t uv = val;
  253|     59|            uv = (uv<<8) |  c[1];
  254|     59|            uv = (uv<<8) |  c[2];
  255|     59|            uv = (uv<<8) |  c[3];
  256|     59|            uv = (uv<<4) | (c[4] & 0x0f);
  257|       |            // Avoid implementation-defined behaviour on negative values
  258|     59|            *val_p = uv < 0x80000000UL ? (int32_t) uv : -((int32_t) (0xffffffffUL - uv)) - 1;
  259|     59|            *crc = crc32(*crc, c, 5);
  260|     59|        }
  261|  2.22k|    }
  262|       |
  263|     59|    return 5;
  264|  2.22k|}
ltf8_decode_crc:
  496|     31|int ltf8_decode_crc(cram_fd *fd, int64_t *val_p, uint32_t *crc) {
  497|     31|    unsigned char c[9];
  498|     31|    int64_t val = hgetc(fd->fp);
  499|     31|    if (val < 0)
  500|      2|        return -1;
  501|       |
  502|     29|    c[0] = val;
  503|       |
  504|     29|    if (val < 0x80) {
  505|     14|        *val_p =   val;
  506|     14|        *crc = crc32(*crc, c, 1);
  507|     14|        return 1;
  508|       |
  509|     15|    } else if (val < 0xc0) {
  510|      4|        int v = hgetc(fd->fp);
  511|      4|        if (v < 0)
  512|      0|            return -1;
  513|      4|        val = (val<<8) | (c[1]=v);
  514|      4|        *val_p = val & (((1LL<<(6+8)))-1);
  515|      4|        *crc = crc32(*crc, c, 2);
  516|      4|        return 2;
  517|       |
  518|     11|    } else if (val < 0xe0) {
  519|      4|        if (hread(fd->fp, &c[1], 2) < 2)
  520|      0|            return -1;
  521|      4|        val = (val<<8) | c[1];
  522|      4|        val = (val<<8) | c[2];
  523|      4|        *val_p = val & ((1LL<<(5+2*8))-1);
  524|      4|        *crc = crc32(*crc, c, 3);
  525|      4|        return 3;
  526|       |
  527|      7|    } else if (val < 0xf0) {
  528|      2|        if (hread(fd->fp, &c[1], 3) < 3)
  529|      0|            return -1;
  530|      2|        val = (val<<8) | c[1];
  531|      2|        val = (val<<8) | c[2];
  532|      2|        val = (val<<8) | c[3];
  533|      2|        *val_p = val & ((1LL<<(4+3*8))-1);
  534|      2|        *crc = crc32(*crc, c, 4);
  535|      2|        return 4;
  536|       |
  537|      5|    } else if (val < 0xf8) {
  538|      1|        if (hread(fd->fp, &c[1], 4) < 4)
  539|      0|            return -1;
  540|      1|        val = (val<<8) | c[1];
  541|      1|        val = (val<<8) | c[2];
  542|      1|        val = (val<<8) | c[3];
  543|      1|        val = (val<<8) | c[4];
  544|      1|        *val_p = val & ((1LL<<(3+4*8))-1);
  545|      1|        *crc = crc32(*crc, c, 5);
  546|      1|        return 5;
  547|       |
  548|      4|    } else if (val < 0xfc) {
  549|      0|        if (hread(fd->fp, &c[1], 5) < 5)
  550|      0|            return -1;
  551|      0|        val = (val<<8) | c[1];
  552|      0|        val = (val<<8) | c[2];
  553|      0|        val = (val<<8) | c[3];
  554|      0|        val = (val<<8) | c[4];
  555|      0|        val = (val<<8) | c[5];
  556|      0|        *val_p = val & ((1LL<<(2+5*8))-1);
  557|      0|        *crc = crc32(*crc, c, 6);
  558|      0|        return 6;
  559|       |
  560|      4|    } else if (val < 0xfe) {
  561|      0|        if (hread(fd->fp, &c[1], 6) < 6)
  562|      0|            return -1;
  563|      0|        val = (val<<8) | c[1];
  564|      0|        val = (val<<8) | c[2];
  565|      0|        val = (val<<8) | c[3];
  566|      0|        val = (val<<8) | c[4];
  567|      0|        val = (val<<8) | c[5];
  568|      0|        val = (val<<8) | c[6];
  569|      0|        *val_p = val & ((1LL<<(1+6*8))-1);
  570|      0|        *crc = crc32(*crc, c, 7);
  571|      0|        return 7;
  572|       |
  573|      4|    } else if (val < 0xff) {
  574|      1|        uint64_t uval = val;
  575|      1|        if (hread(fd->fp, &c[1], 7) < 7)
  576|      0|            return -1;
  577|      1|        uval = (uval<<8) | c[1];
  578|      1|        uval = (uval<<8) | c[2];
  579|      1|        uval = (uval<<8) | c[3];
  580|      1|        uval = (uval<<8) | c[4];
  581|      1|        uval = (uval<<8) | c[5];
  582|      1|        uval = (uval<<8) | c[6];
  583|      1|        uval = (uval<<8) | c[7];
  584|      1|        *val_p = uval & ((1ULL<<(7*8))-1);
  585|      1|        *crc = crc32(*crc, c, 8);
  586|      1|        return 8;
  587|       |
  588|      3|    } else {
  589|      3|        uint64_t uval;
  590|      3|        if (hread(fd->fp, &c[1], 8) < 8)
  591|      0|            return -1;
  592|      3|        uval =             c[1];
  593|      3|        uval = (uval<<8) | c[2];
  594|      3|        uval = (uval<<8) | c[3];
  595|      3|        uval = (uval<<8) | c[4];
  596|      3|        uval = (uval<<8) | c[5];
  597|      3|        uval = (uval<<8) | c[6];
  598|      3|        uval = (uval<<8) | c[7];
  599|      3|        uval = (uval<<8) | c[8];
  600|      3|        *crc = crc32(*crc, c, 9);
  601|       |        // Avoid implementation-defined behaviour on negative values
  602|      3|        *val_p = c[1] < 0x80 ? (int64_t) uval : -((int64_t) (0xffffffffffffffffULL - uval)) - 1;
  603|      3|    }
  604|       |
  605|      3|    return 9;
  606|     29|}
int32_get_blk:
 1024|      1|int int32_get_blk(cram_block *b, int32_t *val) {
 1025|      1|    if (b->uncomp_size - BLOCK_SIZE(b) < 4)
 1026|      1|        return -1;
 1027|       |
 1028|      0|    uint32_t v =
 1029|      0|         ((uint32_t) b->data[b->byte  ])        |
 1030|      0|        (((uint32_t) b->data[b->byte+1]) <<  8) |
 1031|      0|        (((uint32_t) b->data[b->byte+2]) << 16) |
 1032|      0|        (((uint32_t) b->data[b->byte+3]) << 24);
 1033|       |    // Avoid implementation-defined behaviour on negative values
 1034|      0|    *val = v < 0x80000000U ? (int32_t) v : -((int32_t) (0xffffffffU - v)) - 1;
 1035|      0|    BLOCK_SIZE(b) += 4;
 1036|      0|    return 4;
 1037|      0|}
cram_read_block:
 1407|     20|cram_block *cram_read_block(cram_fd *fd) {
 1408|     20|    cram_block *b = malloc(sizeof(*b));
 1409|     20|    unsigned char c;
 1410|     20|    uint32_t crc = 0;
 1411|     20|    if (!b)
 1412|      0|        return NULL;
 1413|       |
 1414|       |    //fprintf(stderr, "Block at %d\n", (int)ftell(fd->fp));
 1415|       |
 1416|     20|    if (-1 == (b->method      = hgetc(fd->fp))) { free(b); return NULL; }
 1417|     19|    c = b->method; crc = crc32(crc, &c, 1);
 1418|     19|    if (-1 == (b->content_type= hgetc(fd->fp))) { free(b); return NULL; }
 1419|     18|    c = b->content_type; crc = crc32(crc, &c, 1);
 1420|     18|    if (-1 == fd->vv.varint_decode32_crc(fd, &b->content_id, &crc))  { free(b); return NULL; }
 1421|     15|    if (-1 == fd->vv.varint_decode32_crc(fd, &b->comp_size, &crc))   { free(b); return NULL; }
 1422|     14|    if (-1 == fd->vv.varint_decode32_crc(fd, &b->uncomp_size, &crc)) { free(b); return NULL; }
 1423|       |
 1424|       |    //fprintf(stderr, "  method %d, ctype %d, cid %d, csize %d, ucsize %d\n",
 1425|       |    //      b->method, b->content_type, b->content_id, b->comp_size, b->uncomp_size);
 1426|       |
 1427|     13|    if (b->method == RAW) {
 1428|      7|        if (b->uncomp_size < 0 || b->comp_size != b->uncomp_size) {
 1429|      3|            free(b);
 1430|      3|            return NULL;
 1431|      3|        }
 1432|      4|        b->alloc = b->uncomp_size;
 1433|      4|        if (!(b->data = malloc(b->uncomp_size))){ free(b); return NULL; }
 1434|      4|        if (b->uncomp_size != hread(fd->fp, b->data, b->uncomp_size)) {
 1435|      1|            free(b->data);
 1436|      1|            free(b);
 1437|      1|            return NULL;
 1438|      1|        }
 1439|      6|    } else {
 1440|      6|        if (b->comp_size < 0 || b->uncomp_size < 0) {
 1441|      1|            free(b);
 1442|      1|            return NULL;
 1443|      1|        }
 1444|      5|        b->alloc = b->comp_size;
 1445|      5|        if (!(b->data = malloc(b->comp_size)))  { free(b); return NULL; }
 1446|      5|        if (b->comp_size != hread(fd->fp, b->data, b->comp_size)) {
 1447|      1|            free(b->data);
 1448|      1|            free(b);
 1449|      1|            return NULL;
 1450|      1|        }
 1451|      7|    }
 1452|       |
 1453|      7|    if (CRAM_MAJOR_VERS(fd->version) >= 3) {
 1454|      0|        if (-1 == int32_decode(fd, (int32_t *)&b->crc32)) {
 1455|      0|            free(b->data);
 1456|      0|            free(b);
 1457|      0|            return NULL;
 1458|      0|        }
 1459|       |
 1460|      0|        b->crc32_checked = fd->ignore_md5;
 1461|      0|        b->crc_part = crc;
 1462|      7|    } else {
 1463|      7|        b->crc32_checked = 1; // CRC not present
 1464|      7|    }
 1465|       |
 1466|      7|    b->orig_method = b->method;
 1467|      7|    b->idx = 0;
 1468|      7|    b->byte = 0;
 1469|      7|    b->bit = 7; // MSB
 1470|       |
 1471|      7|    return b;
 1472|      7|}
cram_free_block:
 1554|      7|void cram_free_block(cram_block *b) {
 1555|      7|    if (!b)
 1556|      0|        return;
 1557|      7|    if (b->data)
 1558|      7|        free(b->data);
 1559|      7|    free(b);
 1560|      7|}
cram_uncompress_block:
 1565|      4|int cram_uncompress_block(cram_block *b) {
 1566|      4|    char *uncomp;
 1567|      4|    size_t uncomp_size = 0;
 1568|       |
 1569|      4|    if (b->crc32_checked == 0) {
 1570|      0|        uint32_t crc = crc32(b->crc_part, b->data ? b->data : (uc *)"", b->alloc);
 1571|      0|        b->crc32_checked = 1;
 1572|      0|        if (crc != b->crc32) {
 1573|      0|            hts_log_error("Block CRC32 failure");
 1574|      0|            return -1;
 1575|      0|        }
 1576|      4|    }
 1577|       |
 1578|      4|    if (b->uncomp_size == 0) {
 1579|       |        // blank block
 1580|      2|        b->method = RAW;
 1581|      2|        return 0;
 1582|      2|    }
 1583|      2|    assert(b->uncomp_size >= 0); // cram_read_block should ensure this
 1584|       |
 1585|      2|    switch (b->method) {
 1586|      0|    case RAW:
 1587|      0|        return 0;
 1588|       |
 1589|      0|    case GZIP:
 1590|      0|        uncomp_size = b->uncomp_size;
 1591|      0|        uncomp = zlib_mem_inflate((char *)b->data, b->comp_size, &uncomp_size);
 1592|       |
 1593|      0|        if (!uncomp)
 1594|      0|            return -1;
 1595|      0|        if (uncomp_size != b->uncomp_size) {
 1596|      0|            free(uncomp);
 1597|      0|            return -1;
 1598|      0|        }
 1599|      0|        free(b->data);
 1600|      0|        b->data = (unsigned char *)uncomp;
 1601|      0|        b->alloc = uncomp_size;
 1602|      0|        b->method = RAW;
 1603|      0|        break;
 1604|       |
 1605|      0|#ifdef HAVE_LIBBZ2
 1606|      0|    case BZIP2: {
 1607|      0|        unsigned int usize = b->uncomp_size;
 1608|      0|        if (!(uncomp = malloc(usize)))
 1609|      0|            return -1;
 1610|      0|        if (BZ_OK != BZ2_bzBuffToBuffDecompress(uncomp, &usize,
 1611|      0|                                                (char *)b->data, b->comp_size,
 1612|      0|                                                0, 0)) {
 1613|      0|            free(uncomp);
 1614|      0|            return -1;
 1615|      0|        }
 1616|      0|        free(b->data);
 1617|      0|        b->data = (unsigned char *)uncomp;
 1618|      0|        b->alloc = usize;
 1619|      0|        b->method = RAW;
 1620|      0|        b->uncomp_size = usize; // Just in case it differs
 1621|      0|        break;
 1622|      0|    }
 1623|       |#else
 1624|       |    case BZIP2:
 1625|       |        hts_log_error("Bzip2 compression is not compiled into this version. Please rebuild and try again");
 1626|       |        return -1;
 1627|       |#endif
 1628|       |
 1629|      0|#ifdef HAVE_LIBLZMA
 1630|      0|    case LZMA:
 1631|      0|        uncomp = lzma_mem_inflate((char *)b->data, b->comp_size, &uncomp_size);
 1632|      0|        if (!uncomp)
 1633|      0|            return -1;
 1634|      0|        if (uncomp_size != b->uncomp_size) {
 1635|      0|            free(uncomp);
 1636|      0|            return -1;
 1637|      0|        }
 1638|      0|        free(b->data);
 1639|      0|        b->data = (unsigned char *)uncomp;
 1640|      0|        b->alloc = uncomp_size;
 1641|      0|        b->method = RAW;
 1642|      0|        break;
 1643|       |#else
 1644|       |    case LZMA:
 1645|       |        hts_log_error("Lzma compression is not compiled into this version. Please rebuild and try again");
 1646|       |        return -1;
 1647|       |        break;
 1648|       |#endif
 1649|       |
 1650|      0|    case RANS: {
 1651|      0|        unsigned int usize = b->uncomp_size, usize2;
 1652|      0|        uncomp = (char *)rans_uncompress(b->data, b->comp_size, &usize2);
 1653|      0|        if (!uncomp)
 1654|      0|            return -1;
 1655|      0|        if (usize != usize2) {
 1656|      0|            free(uncomp);
 1657|      0|            return -1;
 1658|      0|        }
 1659|      0|        free(b->data);
 1660|      0|        b->data = (unsigned char *)uncomp;
 1661|      0|        b->alloc = usize2;
 1662|      0|        b->method = RAW;
 1663|      0|        b->uncomp_size = usize2; // Just in case it differs
 1664|       |        //fprintf(stderr, "Expanded %d to %d\n", b->comp_size, b->uncomp_size);
 1665|      0|        break;
 1666|      0|    }
 1667|       |
 1668|      0|    case FQZ: {
 1669|      0|        uncomp_size = b->uncomp_size;
 1670|      0|        uncomp = fqz_decompress((char *)b->data, b->comp_size, &uncomp_size, NULL, 0);
 1671|      0|        if (!uncomp)
 1672|      0|            return -1;
 1673|      0|        free(b->data);
 1674|      0|        b->data = (unsigned char *)uncomp;
 1675|      0|        b->alloc = uncomp_size;
 1676|      0|        b->method = RAW;
 1677|      0|        b->uncomp_size = uncomp_size;
 1678|      0|        break;
 1679|      0|    }
 1680|       |
 1681|      0|    case RANS_PR0: {
 1682|      0|        unsigned int usize = b->uncomp_size, usize2;
 1683|      0|        uncomp = (char *)rans_uncompress_4x16(b->data, b->comp_size, &usize2);
 1684|      0|        if (!uncomp)
 1685|      0|            return -1;
 1686|      0|        if (usize != usize2) {
 1687|      0|            free(uncomp);
 1688|      0|            return -1;
 1689|      0|        }
 1690|      0|        b->orig_method = RANS_PR0 + (b->data[0]&1)
 1691|      0|            + 2*((b->data[0]&0x40)>0) + 4*((b->data[0]&0x80)>0);
 1692|      0|        free(b->data);
 1693|      0|        b->data = (unsigned char *)uncomp;
 1694|      0|        b->alloc = usize2;
 1695|      0|        b->method = RAW;
 1696|      0|        b->uncomp_size = usize2; // Just incase it differs
 1697|       |        //fprintf(stderr, "Expanded %d to %d\n", b->comp_size, b->uncomp_size);
 1698|      0|        break;
 1699|      0|    }
 1700|       |
 1701|      0|    case ARITH_PR0: {
 1702|      0|        unsigned int usize = b->uncomp_size, usize2;
 1703|      0|        uncomp = (char *)arith_uncompress_to(b->data, b->comp_size, NULL, &usize2);
 1704|      0|        if (!uncomp)
 1705|      0|            return -1;
 1706|      0|        if (usize != usize2) {
 1707|      0|            free(uncomp);
 1708|      0|            return -1;
 1709|      0|        }
 1710|      0|        b->orig_method = ARITH_PR0 + (b->data[0]&1)
 1711|      0|            + 2*((b->data[0]&0x40)>0) + 4*((b->data[0]&0x80)>0);
 1712|      0|        free(b->data);
 1713|      0|        b->data = (unsigned char *)uncomp;
 1714|      0|        b->alloc = usize2;
 1715|      0|        b->method = RAW;
 1716|      0|        b->uncomp_size = usize2; // Just incase it differs
 1717|       |        //fprintf(stderr, "Expanded %d to %d\n", b->comp_size, b->uncomp_size);
 1718|      0|        break;
 1719|      0|    }
 1720|       |
 1721|      0|    case TOK3: {
 1722|      0|        uint32_t out_len;
 1723|      0|        uint8_t *cp = decode_names(b->data, b->comp_size, &out_len);
 1724|      0|        if (!cp)
 1725|      0|            return -1;
 1726|      0|        b->orig_method = TOK3;
 1727|      0|        b->method = RAW;
 1728|      0|        free(b->data);
 1729|      0|        b->data = cp;
 1730|      0|        b->alloc = out_len;
 1731|      0|        b->uncomp_size = out_len;
 1732|      0|        break;
 1733|      0|    }
 1734|       |
 1735|      2|    default:
 1736|      2|        return -1;
 1737|      0|    }
 1738|       |
 1739|      0|    return 0;
 1740|      0|}
cram_new_metrics:
 2279|  3.05k|cram_metrics *cram_new_metrics(void) {
 2280|  3.05k|    cram_metrics *m = calloc(1, sizeof(*m));
 2281|  3.05k|    if (!m)
 2282|      0|        return NULL;
 2283|  3.05k|    m->trial = NTRIALS-1;
 2284|  3.05k|    m->next_trial = TRIAL_SPAN/2; // learn quicker at start
 2285|  3.05k|    m->method = RAW;
 2286|  3.05k|    m->strat = 0;
 2287|  3.05k|    m->revised_method = 0;
 2288|  3.05k|    m->unpackable = 0;
 2289|       |
 2290|  3.05k|    return m;
 2291|  3.05k|}
refs_free:
 2379|     65|void refs_free(refs_t *r) {
 2380|     65|    RP("refs_free()\n");
 2381|       |
 2382|     65|    if (--r->count > 0)
 2383|      0|        return;
 2384|       |
 2385|     65|    if (!r)
 2386|      0|        return;
 2387|       |
 2388|     65|    if (r->pool)
 2389|     65|        string_pool_destroy(r->pool);
 2390|       |
 2391|     65|    if (r->h_meta) {
 2392|     65|        khint_t k;
 2393|       |
 2394|     65|        for (k = kh_begin(r->h_meta); k != kh_end(r->h_meta); k++) {
 2395|      0|            ref_entry *e;
 2396|       |
 2397|      0|            if (!kh_exist(r->h_meta, k))
 2398|      0|                continue;
 2399|      0|            if (!(e = kh_val(r->h_meta, k)))
 2400|      0|                continue;
 2401|      0|            ref_entry_free_seq(e);
 2402|      0|            free(e);
 2403|      0|        }
 2404|       |
 2405|     65|        kh_destroy(refs, r->h_meta);
 2406|     65|    }
 2407|       |
 2408|     65|    if (r->ref_id)
 2409|      0|        free(r->ref_id);
 2410|       |
 2411|     65|    if (r->fp)
 2412|      0|        bgzf_close(r->fp);
 2413|       |
 2414|     65|    pthread_mutex_destroy(&r->lock);
 2415|       |
 2416|     65|    free(r);
 2417|     65|}
cram_free_container:
 3650|    207|void cram_free_container(cram_container *c) {
 3651|    207|    enum cram_DS_ID id;
 3652|    207|    int i;
 3653|       |
 3654|    207|    if (!c)
 3655|      0|        return;
 3656|       |
 3657|    207|    if (c->refs_used)
 3658|      0|        free(c->refs_used);
 3659|       |
 3660|    207|    if (c->landmark)
 3661|     57|        free(c->landmark);
 3662|       |
 3663|    207|    if (c->comp_hdr)
 3664|      0|        cram_free_compression_header(c->comp_hdr);
 3665|       |
 3666|    207|    if (c->comp_hdr_block)
 3667|      5|        cram_free_block(c->comp_hdr_block);
 3668|       |
 3669|       |    // Free the slices; filled out by encoder only
 3670|    207|    if (c->slices) {
 3671|      0|        for (i = 0; i < c->max_slice; i++) {
 3672|      0|            if (c->slices[i])
 3673|      0|                cram_free_slice(c->slices[i]);
 3674|      0|            if (c->slices[i] == c->slice)
 3675|      0|                c->slice = NULL;
 3676|      0|        }
 3677|      0|        free(c->slices);
 3678|      0|    }
 3679|       |
 3680|       |    // Free the current slice; set by both encoder & decoder
 3681|    207|    if (c->slice) {
 3682|      0|        cram_free_slice(c->slice);
 3683|      0|        c->slice = NULL;
 3684|      0|    }
 3685|       |
 3686|  6.00k|    for (id = DS_RN; id < DS_TN; id++)
 3687|  5.79k|        if (c->stats[id]) cram_stats_free(c->stats[id]);
 3688|       |
 3689|       |    //if (c->aux_B_stats) cram_stats_free(c->aux_B_stats);
 3690|       |
 3691|    207|    if (c->tags_used) {
 3692|      0|        khint_t k;
 3693|       |
 3694|      0|        for (k = kh_begin(c->tags_used); k != kh_end(c->tags_used); k++) {
 3695|      0|            if (!kh_exist(c->tags_used, k))
 3696|      0|                continue;
 3697|       |
 3698|      0|            cram_tag_map *tm = (cram_tag_map *)kh_val(c->tags_used, k);
 3699|      0|            if (tm) {
 3700|      0|                cram_codec *c = tm->codec;
 3701|       |
 3702|      0|                if (c) c->free(c);
 3703|      0|                free(tm);
 3704|      0|            }
 3705|      0|        }
 3706|       |
 3707|      0|        kh_destroy(m_tagmap, c->tags_used);
 3708|      0|    }
 3709|       |
 3710|    207|    free(c);
 3711|    207|}
cram_read_container:
 3719|    254|cram_container *cram_read_container(cram_fd *fd) {
 3720|    254|    cram_container c2, *c;
 3721|    254|    int i, s;
 3722|    254|    size_t rd = 0;
 3723|    254|    uint32_t crc = 0;
 3724|       |
 3725|    254|    fd->err = 0;
 3726|    254|    fd->eof = 0;
 3727|       |
 3728|    254|    memset(&c2, 0, sizeof(c2));
 3729|    254|    if (CRAM_MAJOR_VERS(fd->version) == 1) {
 3730|    206|        if ((s = fd->vv.varint_decode32_crc(fd, &c2.length, &crc)) == -1) {
 3731|      6|            fd->eof = fd->empty_container ? 1 : 2;
 3732|      6|            return NULL;
 3733|    200|        } else {
 3734|    200|            rd+=s;
 3735|    200|        }
 3736|     48|    } else if (CRAM_MAJOR_VERS(fd->version) < 4) {
 3737|     22|        uint32_t len;
 3738|     22|        if ((s = int32_decode(fd, &c2.length)) == -1) {
 3739|      2|            if (CRAM_MAJOR_VERS(fd->version) == 2 &&
 3740|      1|                CRAM_MINOR_VERS(fd->version) == 0)
 3741|      0|                fd->eof = 1; // EOF blocks arrived in v2.1
 3742|      2|            else
 3743|      2|                fd->eof = fd->empty_container ? 1 : 2;
 3744|      2|            return NULL;
 3745|     20|        } else {
 3746|     20|            rd+=s;
 3747|     20|        }
 3748|     20|        len = le_int4(c2.length);
 3749|     20|        crc = crc32(0L, (unsigned char *)&len, 4);
 3750|     26|    } else {
 3751|     26|        if ((s = fd->vv.varint_decode32_crc(fd, &c2.length, &crc))   == -1) {
 3752|      1|            fd->eof = fd->empty_container ? 1 : 2;
 3753|      1|            return NULL;
 3754|     25|        } else {
 3755|     25|            rd+=s;
 3756|     25|        }
 3757|     26|    }
 3758|    245|    if ((s = fd->vv.varint_decode32s_crc(fd, &c2.ref_seq_id, &crc))   == -1) return NULL; else rd+=s;
 3759|    239|    if (CRAM_MAJOR_VERS(fd->version) >= 4) {
 3760|     24|        int64_t i64;
 3761|     24|        if ((s = fd->vv.varint_decode64_crc(fd, &i64, &crc))== -1) return NULL; else rd+=s;
 3762|     23|        c2.ref_seq_start = i64;
 3763|     23|        if ((s = fd->vv.varint_decode64_crc(fd, &i64, &crc)) == -1) return NULL; else rd+=s;
 3764|     23|        c2.ref_seq_span = i64;
 3765|    215|    } else {
 3766|    215|        int32_t i32;
 3767|    215|        if ((s = fd->vv.varint_decode32_crc(fd, &i32, &crc))== -1) return NULL; else rd+=s;
 3768|    212|        c2.ref_seq_start = i32;
 3769|    212|        if ((s = fd->vv.varint_decode32_crc(fd, &i32, &crc)) == -1) return NULL; else rd+=s;
 3770|    208|        c2.ref_seq_span = i32;
 3771|    208|    }
 3772|    231|    if ((s = fd->vv.varint_decode32_crc(fd, &c2.num_records, &crc))  == -1) return NULL; else rd+=s;
 3773|       |
 3774|    228|    if (CRAM_MAJOR_VERS(fd->version) == 1) {
 3775|    187|        c2.record_counter = 0;
 3776|    187|        c2.num_bases = 0;
 3777|     41|    } else {
 3778|     41|        if (CRAM_MAJOR_VERS(fd->version) >= 3) {
 3779|     36|            if ((s = fd->vv.varint_decode64_crc(fd, &c2.record_counter, &crc)) == -1)
 3780|      2|                return NULL;
 3781|     36|            else
 3782|     34|                rd += s;
 3783|      5|        } else {
 3784|      5|            int32_t i32;
 3785|      5|            if ((s = fd->vv.varint_decode32_crc(fd, &i32, &crc)) == -1)
 3786|      1|                return NULL;
 3787|      5|            else
 3788|      4|                rd += s;
 3789|      4|            c2.record_counter = i32;
 3790|      4|        }
 3791|       |
 3792|     38|        if ((s = fd->vv.varint_decode64_crc(fd, &c2.num_bases, &crc))== -1)
 3793|      2|            return NULL;
 3794|     38|        else
 3795|     36|            rd += s;
 3796|     38|    }
 3797|    223|    if ((s = fd->vv.varint_decode32_crc(fd, &c2.num_blocks, &crc))   == -1)
 3798|      4|        return NULL;
 3799|    223|    else
 3800|    219|        rd+=s;
 3801|    219|    if ((s = fd->vv.varint_decode32_crc(fd, &c2.num_landmarks, &crc))== -1)
 3802|      5|        return NULL;
 3803|    219|    else
 3804|    214|        rd+=s;
 3805|       |
 3806|    214|    if (c2.num_landmarks < 0 || c2.num_landmarks >= SIZE_MAX / sizeof(int32_t))
 3807|      7|        return NULL;
 3808|       |
 3809|    207|    if (!(c = calloc(1, sizeof(*c))))
 3810|      0|        return NULL;
 3811|       |
 3812|    207|    *c = c2;
 3813|       |
 3814|    207|    if (c->num_landmarks && !(c->landmark = malloc(c->num_landmarks * sizeof(int32_t)))) {
 3815|      0|        fd->err = errno;
 3816|      0|        cram_free_container(c);
 3817|      0|        return NULL;
 3818|      0|    }
 3819|  1.22k|    for (i = 0; i < c->num_landmarks; i++) {
 3820|  1.05k|        if ((s = fd->vv.varint_decode32_crc(fd, &c->landmark[i], &crc)) == -1) {
 3821|     35|            cram_free_container(c);
 3822|     35|            return NULL;
 3823|  1.01k|        } else {
 3824|  1.01k|            rd += s;
 3825|  1.01k|        }
 3826|  1.05k|    }
 3827|       |
 3828|    172|    if (CRAM_MAJOR_VERS(fd->version) >= 3) {
 3829|     10|        if (-1 == int32_decode(fd, (int32_t *)&c->crc32)) {
 3830|      1|            cram_free_container(c);
 3831|      1|            return NULL;
 3832|      9|        } else {
 3833|      9|            rd+=4;
 3834|      9|        }
 3835|       |
 3836|      9|        if (crc != c->crc32) {
 3837|      9|            hts_log_error("Container header CRC32 failure");
 3838|      9|            cram_free_container(c);
 3839|      9|            return NULL;
 3840|      9|        }
 3841|    162|    }
 3842|       |
 3843|    162|    c->offset = rd;
 3844|    162|    c->slices = NULL;
 3845|    162|    c->slice = NULL;
 3846|    162|    c->curr_slice = 0;
 3847|    162|    c->max_slice = c->num_landmarks;
 3848|    162|    c->slice_rec = 0;
 3849|    162|    c->curr_rec = 0;
 3850|    162|    c->max_rec = 0;
 3851|       |
 3852|    162|    if (c->ref_seq_id == -2) {
 3853|      0|        c->multi_seq = 1;
 3854|      0|        fd->multi_seq = 1;
 3855|      0|    }
 3856|       |
 3857|    162|    fd->empty_container =
 3858|    162|        (c->num_records == 0 &&
 3859|    132|         c->ref_seq_id == -1 &&
 3860|    162|         c->ref_seq_start == 0x454f46 /* EOF */) ? 1 : 0;
 3861|       |
 3862|    162|    return c;
 3863|    162|}
cram_free_compression_header:
 4278|      1|void cram_free_compression_header(cram_block_compression_hdr *hdr) {
 4279|      1|    int i;
 4280|       |
 4281|      1|    if (hdr->landmark)
 4282|      1|        free(hdr->landmark);
 4283|       |
 4284|      1|    if (hdr->preservation_map)
 4285|      1|        kh_destroy(map, hdr->preservation_map);
 4286|       |
 4287|     33|    for (i = 0; i < CRAM_MAP_HASH; i++) {
 4288|     32|        cram_map *m, *m2;
 4289|     32|        for (m = hdr->rec_encoding_map[i]; m; m = m2) {
 4290|      0|            m2 = m->next;
 4291|      0|            if (m->codec)
 4292|      0|                m->codec->free(m->codec);
 4293|      0|            free(m);
 4294|      0|        }
 4295|     32|    }
 4296|       |
 4297|     33|    for (i = 0; i < CRAM_MAP_HASH; i++) {
 4298|     32|        cram_map *m, *m2;
 4299|     32|        for (m = hdr->tag_encoding_map[i]; m; m = m2) {
 4300|      0|            m2 = m->next;
 4301|      0|            if (m->codec)
 4302|      0|                m->codec->free(m->codec);
 4303|      0|            free(m);
 4304|      0|        }
 4305|     32|    }
 4306|       |
 4307|     48|    for (i = 0; i < DS_END; i++) {
 4308|     47|        if (hdr->codecs[i])
 4309|      0|            hdr->codecs[i]->free(hdr->codecs[i]);
 4310|     47|    }
 4311|       |
 4312|      1|    if (hdr->TL)
 4313|      0|        free(hdr->TL);
 4314|      1|    if (hdr->TD_blk)
 4315|      0|        cram_free_block(hdr->TD_blk);
 4316|      1|    if (hdr->TD_hash)
 4317|      1|        kh_destroy(m_s2i, hdr->TD_hash);
 4318|      1|    if (hdr->TD_keys)
 4319|      0|        string_pool_destroy(hdr->TD_keys);
 4320|       |
 4321|      1|    free(hdr);
 4322|      1|}
cram_read_file_def:
 4574|    121|cram_file_def *cram_read_file_def(cram_fd *fd) {
 4575|    121|    cram_file_def *def = malloc(sizeof(*def));
 4576|    121|    if (!def)
 4577|      0|        return NULL;
 4578|       |
 4579|    121|    if (26 != hread(fd->fp, &def->magic[0], 26)) {
 4580|      1|        free(def);
 4581|      1|        return NULL;
 4582|      1|    }
 4583|       |
 4584|    120|    if (memcmp(def->magic, "CRAM", 4) != 0) {
 4585|      0|        free(def);
 4586|      0|        return NULL;
 4587|      0|    }
 4588|       |
 4589|    120|    if (def->major_version > 4) {
 4590|      1|        hts_log_error("CRAM version number mismatch. Expected 1.x, 2.x, 3.x or 4.x, got %d.%d",
 4591|      1|                      def->major_version, def->minor_version);
 4592|      1|        free(def);
 4593|      1|        return NULL;
 4594|      1|    }
 4595|       |
 4596|    119|    fd->first_container += 26;
 4597|    119|    fd->curr_position = fd->first_container;
 4598|    119|    fd->last_slice = 0;
 4599|       |
 4600|    119|    return def;
 4601|    119|}
cram_free_file_def:
 4612|    119|void cram_free_file_def(cram_file_def *def) {
 4613|    119|    if (def) free(def);
 4614|    119|}
cram_read_SAM_hdr:
 4629|    119|sam_hdr_t *cram_read_SAM_hdr(cram_fd *fd) {
 4630|    119|    int32_t header_len;
 4631|    119|    char *header;
 4632|    119|    sam_hdr_t *hdr;
 4633|       |
 4634|       |    /* 1.1 onwards stores the header in the first block of a container */
 4635|    119|    if (CRAM_MAJOR_VERS(fd->version) == 1) {
 4636|       |        /* Length */
 4637|     71|        if (-1 == int32_decode(fd, &header_len))
 4638|      1|            return NULL;
 4639|       |
 4640|       |        /* Alloc and read */
 4641|     70|        if (header_len < 0 || NULL == (header = malloc((size_t) header_len+1)))
 4642|      1|            return NULL;
 4643|       |
 4644|     69|        if (header_len != hread(fd->fp, header, header_len)) {
 4645|      2|            free(header);
 4646|      2|            return NULL;
 4647|      2|        }
 4648|     67|        header[header_len] = '\0';
 4649|       |
 4650|     67|        fd->first_container += 4 + header_len;
 4651|     48|    } else {
 4652|     48|        cram_container *c = cram_read_container(fd);
 4653|     48|        cram_block *b;
 4654|     48|        int i;
 4655|     48|        int64_t len;
 4656|       |
 4657|     48|        if (!c)
 4658|     44|            return NULL;
 4659|       |
 4660|      4|        fd->first_container += c->length + c->offset;
 4661|      4|        fd->curr_position = fd->first_container;
 4662|       |
 4663|      4|        if (c->num_blocks < 1) {
 4664|      1|            cram_free_container(c);
 4665|      1|            return NULL;
 4666|      1|        }
 4667|       |
 4668|      3|        if (!(b = cram_read_block(fd))) {
 4669|      1|            cram_free_container(c);
 4670|      1|            return NULL;
 4671|      1|        }
 4672|      2|        if (cram_uncompress_block(b) != 0) {
 4673|      1|            cram_free_container(c);
 4674|      1|            cram_free_block(b);
 4675|      1|            return NULL;
 4676|      1|        }
 4677|       |
 4678|      1|        len = b->comp_size + 2 + 4*(CRAM_MAJOR_VERS(fd->version) >= 3) +
 4679|      1|            fd->vv.varint_size(b->content_id) +
 4680|      1|            fd->vv.varint_size(b->uncomp_size) +
 4681|      1|            fd->vv.varint_size(b->comp_size);
 4682|       |
 4683|       |        /* Extract header from 1st block */
 4684|      1|        if (-1 == int32_get_blk(b, &header_len) ||
 4685|      0|            header_len < 0 || /* Spec. says signed...  why? */
 4686|      1|            b->uncomp_size - 4 < header_len) {
 4687|      1|            cram_free_container(c);
 4688|      1|            cram_free_block(b);
 4689|      1|            return NULL;
 4690|      1|        }
 4691|      0|        if (NULL == (header = malloc((size_t) header_len+1))) {
 4692|      0|            cram_free_container(c);
 4693|      0|            cram_free_block(b);
 4694|      0|            return NULL;
 4695|      0|        }
 4696|      0|        memcpy(header, BLOCK_END(b), header_len);
 4697|      0|        header[header_len] = '\0';
 4698|      0|        cram_free_block(b);
 4699|       |
 4700|       |        /* Consume any remaining blocks */
 4701|      0|        for (i = 1; i < c->num_blocks; i++) {
 4702|      0|            if (!(b = cram_read_block(fd))) {
 4703|      0|                cram_free_container(c);
 4704|      0|                free(header);
 4705|      0|                return NULL;
 4706|      0|            }
 4707|      0|            len += b->comp_size + 2 + 4*(CRAM_MAJOR_VERS(fd->version) >= 3) +
 4708|      0|                fd->vv.varint_size(b->content_id) +
 4709|      0|                fd->vv.varint_size(b->uncomp_size) +
 4710|      0|                fd->vv.varint_size(b->comp_size);
 4711|      0|            cram_free_block(b);
 4712|      0|        }
 4713|       |
 4714|      0|        if (c->length > 0 && len > 0 && c->length > len) {
 4715|       |            // Consume padding
 4716|      0|            char *pads = malloc(c->length - len);
 4717|      0|            if (!pads) {
 4718|      0|                cram_free_container(c);
 4719|      0|                free(header);
 4720|      0|                return NULL;
 4721|      0|            }
 4722|       |
 4723|      0|            if (c->length - len != hread(fd->fp, pads, c->length - len)) {
 4724|      0|                cram_free_container(c);
 4725|      0|                free(header);
 4726|      0|                free(pads);
 4727|      0|                return NULL;
 4728|      0|            }
 4729|      0|            free(pads);
 4730|      0|        }
 4731|       |
 4732|      0|        cram_free_container(c);
 4733|      0|    }
 4734|       |
 4735|       |    /* Parse */
 4736|     67|    hdr = sam_hdr_init();
 4737|     67|    if (!hdr) {
 4738|      0|        free(header);
 4739|      0|        return NULL;
 4740|      0|    }
 4741|       |
 4742|     67|    if (-1 == sam_hdr_add_lines(hdr, header, header_len)) {
 4743|      2|        free(header);
 4744|      2|        sam_hdr_destroy(hdr);
 4745|      2|        return NULL;
 4746|      2|    }
 4747|       |
 4748|     65|    hdr->l_text = header_len;
 4749|     65|    hdr->text = header;
 4750|       |
 4751|     65|    return hdr;
 4752|       |
 4753|     65|}
cram_dopen:
 5167|    121|cram_fd *cram_dopen(hFILE *fp, const char *filename, const char *mode) {
 5168|    121|    int i;
 5169|    121|    char *cp;
 5170|    121|    cram_fd *fd = calloc(1, sizeof(*fd));
 5171|    121|    if (!fd)
 5172|      0|        return NULL;
 5173|       |
 5174|    121|    fd->level = CRAM_DEFAULT_LEVEL;
 5175|    363|    for (i = 0; mode[i]; i++) {
 5176|    242|        if (mode[i] >= '0' && mode[i] <= '9') {
 5177|      0|            fd->level = mode[i] - '0';
 5178|      0|            break;
 5179|      0|        }
 5180|    242|    }
 5181|       |
 5182|    121|    fd->fp = fp;
 5183|    121|    fd->mode = *mode;
 5184|    121|    fd->first_container = 0;
 5185|    121|    fd->curr_position = 0;
 5186|       |
 5187|    121|    if (fd->mode == 'r') {
 5188|       |        /* Reader */
 5189|       |
 5190|    121|        if (!(fd->file_def = cram_read_file_def(fd)))
 5191|      2|            goto err;
 5192|       |
 5193|    119|        fd->version = fd->file_def->major_version * 256 +
 5194|    119|            fd->file_def->minor_version;
 5195|       |
 5196|    119|        cram_init_tables(fd);
 5197|       |
 5198|    119|        if (!(fd->header = cram_read_SAM_hdr(fd))) {
 5199|     54|            cram_free_file_def(fd->file_def);
 5200|     54|            goto err;
 5201|     54|        }
 5202|       |
 5203|      0|    } else {
 5204|       |        /* Writer */
 5205|      0|        cram_file_def *def = calloc(1, sizeof(*def));
 5206|      0|        if (!def)
 5207|      0|            return NULL;
 5208|       |
 5209|      0|        fd->file_def = def;
 5210|       |
 5211|      0|        def->magic[0] = 'C';
 5212|      0|        def->magic[1] = 'R';
 5213|      0|        def->magic[2] = 'A';
 5214|      0|        def->magic[3] = 'M';
 5215|      0|        def->major_version = 0; // Indicator to write file def later.
 5216|      0|        def->minor_version = 0;
 5217|      0|        memset(def->file_id, 0, 20);
 5218|      0|        strncpy(def->file_id, filename, 20);
 5219|       |
 5220|      0|        fd->version = major_version * 256 + minor_version;
 5221|      0|        cram_init_tables(fd);
 5222|       |
 5223|       |        /* SAM header written later along with this file_def */
 5224|      0|    }
 5225|       |
 5226|     65|    fd->prefix = strdup((cp = strrchr(filename, '/')) ? cp+1 : filename);
 5227|     65|    if (!fd->prefix)
 5228|      0|        goto err;
 5229|     65|    fd->first_base = fd->last_base = -1;
 5230|     65|    fd->record_counter = 0;
 5231|       |
 5232|     65|    fd->ctr = NULL;
 5233|     65|    fd->ctr_mt = NULL;
 5234|     65|    fd->refs  = refs_create();
 5235|     65|    if (!fd->refs)
 5236|      0|        goto err;
 5237|     65|    fd->ref_id = -2;
 5238|     65|    fd->ref = NULL;
 5239|       |
 5240|     65|    fd->decode_md = 0;
 5241|     65|    fd->seqs_per_slice = SEQS_PER_SLICE;
 5242|     65|    fd->bases_per_slice = BASES_PER_SLICE;
 5243|     65|    fd->slices_per_container = SLICE_PER_CNT;
 5244|     65|    fd->embed_ref = 0;
 5245|     65|    fd->no_ref = 0;
 5246|     65|    fd->ap_delta = 0;
 5247|     65|    fd->ignore_md5 = 0;
 5248|     65|    fd->lossy_read_names = 0;
 5249|     65|    fd->use_bz2 = 0;
 5250|     65|    fd->use_rans = (CRAM_MAJOR_VERS(fd->version) >= 3);
 5251|     65|    fd->use_tok = (CRAM_MAJOR_VERS(fd->version) >= 3) && (CRAM_MINOR_VERS(fd->version) >= 1);
 5252|     65|    fd->use_lzma = 0;
 5253|     65|    fd->multi_seq = -1;
 5254|     65|    fd->multi_seq_user = -1;
 5255|     65|    fd->unsorted   = 0;
 5256|     65|    fd->shared_ref = 0;
 5257|     65|    fd->store_md = 0;
 5258|     65|    fd->store_nm = 0;
 5259|     65|    fd->last_RI_count = 0;
 5260|       |
 5261|     65|    fd->index       = NULL;
 5262|     65|    fd->own_pool    = 0;
 5263|     65|    fd->pool        = NULL;
 5264|     65|    fd->rqueue      = NULL;
 5265|     65|    fd->job_pending = NULL;
 5266|     65|    fd->ooc         = 0;
 5267|     65|    fd->required_fields = INT_MAX;
 5268|       |
 5269|  3.12k|    for (i = 0; i < DS_END; i++) {
 5270|  3.05k|        fd->m[i] = cram_new_metrics();
 5271|  3.05k|        if (!fd->m[i])
 5272|      0|            goto err;
 5273|  3.05k|    }
 5274|       |
 5275|     65|    if (!(fd->tags_used = kh_init(m_metrics)))
 5276|      0|        goto err;
 5277|       |
 5278|     65|    fd->range.refid = -2; // no ref.
 5279|     65|    fd->eof = 1;          // See samtools issue #150
 5280|     65|    fd->ref_fn = NULL;
 5281|       |
 5282|     65|    fd->bl = NULL;
 5283|       |
 5284|       |    /* Initialise dummy refs from the @SQ headers */
 5285|     65|    if (-1 == refs_from_header(fd))
 5286|      0|        goto err;
 5287|       |
 5288|     65|    return fd;
 5289|       |
 5290|     56| err:
 5291|     56|    if (fd)
 5292|     56|        free(fd);
 5293|       |
 5294|     56|    return NULL;
 5295|     65|}
cram_close:
 5439|     65|int cram_close(cram_fd *fd) {
 5440|     65|    spare_bams *bl, *next;
 5441|     65|    int i;
 5442|       |
 5443|     65|    if (!fd)
 5444|      0|        return -1;
 5445|       |
 5446|     65|    if (fd->mode == 'w' && fd->ctr) {
 5447|      0|        if(fd->ctr->slice)
 5448|      0|            cram_update_curr_slice(fd->ctr);
 5449|       |
 5450|      0|        if (-1 == cram_flush_container_mt(fd, fd->ctr))
 5451|      0|            return -1;
 5452|     65|    }
 5453|       |
 5454|     65|    if (fd->mode != 'w')
 5455|     65|        cram_drain_rqueue(fd);
 5456|       |
 5457|     65|    if (fd->pool && fd->eof >= 0 && fd->rqueue) {
 5458|      0|        hts_tpool_process_flush(fd->rqueue);
 5459|       |
 5460|      0|        if (0 != cram_flush_result(fd))
 5461|      0|            return -1;
 5462|       |
 5463|      0|        if (fd->mode == 'w')
 5464|      0|            fd->ctr = NULL; // prevent double freeing
 5465|       |
 5466|      0|        pthread_mutex_destroy(&fd->metrics_lock);
 5467|      0|        pthread_mutex_destroy(&fd->ref_lock);
 5468|      0|        pthread_mutex_destroy(&fd->bam_list_lock);
 5469|       |
 5470|       |        //fprintf(stderr, "CRAM: destroy queue %p\n", fd->rqueue);
 5471|       |
 5472|      0|        hts_tpool_process_destroy(fd->rqueue);
 5473|      0|    }
 5474|       |
 5475|     65|    if (fd->mode == 'w') {
 5476|       |        /* Write EOF block */
 5477|      0|        if (0 != cram_write_eof_block(fd))
 5478|      0|            return -1;
 5479|     65|    }
 5480|       |
 5481|     65|    for (bl = fd->bl; bl; bl = next) {
 5482|      0|        int i, max_rec = fd->seqs_per_slice * fd->slices_per_container;
 5483|       |
 5484|      0|        next = bl->next;
 5485|      0|        for (i = 0; i < max_rec; i++) {
 5486|      0|            if (bl->bams[i])
 5487|      0|                bam_free(bl->bams[i]);
 5488|      0|        }
 5489|      0|        free(bl->bams);
 5490|      0|        free(bl);
 5491|      0|    }
 5492|       |
 5493|     65|    if (hclose(fd->fp) != 0)
 5494|      0|        return -1;
 5495|       |
 5496|     65|    if (fd->file_def)
 5497|     65|        cram_free_file_def(fd->file_def);
 5498|       |
 5499|     65|    if (fd->header)
 5500|     65|        sam_hdr_destroy(fd->header);
 5501|       |
 5502|     65|    free(fd->prefix);
 5503|       |
 5504|     65|    if (fd->ctr)
 5505|     17|        cram_free_container(fd->ctr);
 5506|       |
 5507|     65|    if (fd->ctr_mt && fd->ctr_mt != fd->ctr)
 5508|      0|        cram_free_container(fd->ctr_mt);
 5509|       |
 5510|     65|    if (fd->refs)
 5511|     65|        refs_free(fd->refs);
 5512|     65|    if (fd->ref_free)
 5513|      0|        free(fd->ref_free);
 5514|       |
 5515|  3.12k|    for (i = 0; i < DS_END; i++)
 5516|  3.05k|        if (fd->m[i])
 5517|  3.05k|            free(fd->m[i]);
 5518|       |
 5519|     65|    if (fd->tags_used) {
 5520|     65|        khint_t k;
 5521|       |
 5522|     65|        for (k = kh_begin(fd->tags_used); k != kh_end(fd->tags_used); k++) {
 5523|      0|            if (kh_exist(fd->tags_used, k))
 5524|      0|                free(kh_val(fd->tags_used, k));
 5525|      0|        }
 5526|       |
 5527|     65|        kh_destroy(m_metrics, fd->tags_used);
 5528|     65|    }
 5529|       |
 5530|     65|    if (fd->index)
 5531|      0|        cram_index_free(fd);
 5532|       |
 5533|     65|    if (fd->own_pool && fd->pool)
 5534|      0|        hts_tpool_destroy(fd->pool);
 5535|       |
 5536|     65|    if (fd->idxfp)
 5537|      0|        if (bgzf_close(fd->idxfp) < 0)
 5538|      0|            return -1;
 5539|       |
 5540|     65|    free(fd);
 5541|     65|    return 0;
 5542|     65|}
cram_eof:
 5547|    130|int cram_eof(cram_fd *fd) {
 5548|    130|    return fd->eof;
 5549|    130|}
cram_set_option:
 5559|     65|int cram_set_option(cram_fd *fd, enum hts_fmt_option opt, ...) {
 5560|     65|    int r;
 5561|     65|    va_list args;
 5562|       |
 5563|     65|    va_start(args, opt);
 5564|     65|    r = cram_set_voption(fd, opt, args);
 5565|     65|    va_end(args);
 5566|       |
 5567|     65|    return r;
 5568|     65|}
cram_set_voption:
 5577|     65|int cram_set_voption(cram_fd *fd, enum hts_fmt_option opt, va_list args) {
 5578|     65|    refs_t *refs;
 5579|       |
 5580|     65|    if (!fd) {
 5581|      0|        errno = EBADF;
 5582|      0|        return -1;
 5583|      0|    }
 5584|       |
 5585|     65|    switch (opt) {
 5586|     65|    case CRAM_OPT_DECODE_MD:
 5587|     65|        fd->decode_md = va_arg(args, int);
 5588|     65|        break;
 5589|       |
 5590|      0|    case CRAM_OPT_PREFIX:
 5591|      0|        if (fd->prefix)
 5592|      0|            free(fd->prefix);
 5593|      0|        if (!(fd->prefix = strdup(va_arg(args, char *))))
 5594|      0|            return -1;
 5595|      0|        break;
 5596|       |
 5597|      0|    case CRAM_OPT_VERBOSITY:
 5598|      0|        break;
 5599|       |
 5600|      0|    case CRAM_OPT_SEQS_PER_SLICE:
 5601|      0|        fd->seqs_per_slice = va_arg(args, int);
 5602|      0|        if (fd->bases_per_slice == BASES_PER_SLICE)
 5603|      0|            fd->bases_per_slice = fd->seqs_per_slice * 500;
 5604|      0|        break;
 5605|       |
 5606|      0|    case CRAM_OPT_BASES_PER_SLICE:
 5607|      0|        fd->bases_per_slice = va_arg(args, int);
 5608|      0|        break;
 5609|       |
 5610|      0|    case CRAM_OPT_SLICES_PER_CONTAINER:
 5611|      0|        fd->slices_per_container = va_arg(args, int);
 5612|      0|        break;
 5613|       |
 5614|      0|    case CRAM_OPT_EMBED_REF:
 5615|      0|        fd->embed_ref = va_arg(args, int);
 5616|      0|        break;
 5617|       |
 5618|      0|    case CRAM_OPT_NO_REF:
 5619|      0|        fd->no_ref = va_arg(args, int);
 5620|      0|        break;
 5621|       |
 5622|      0|    case CRAM_OPT_POS_DELTA:
 5623|      0|        fd->ap_delta = va_arg(args, int);
 5624|      0|        break;
 5625|       |
 5626|      0|    case CRAM_OPT_IGNORE_MD5:
 5627|      0|        fd->ignore_md5 = va_arg(args, int);
 5628|      0|        break;
 5629|       |
 5630|      0|    case CRAM_OPT_LOSSY_NAMES:
 5631|      0|        fd->lossy_read_names = va_arg(args, int);
 5632|       |        // Currently lossy read names required paired (attached) reads.
 5633|       |        // TLEN 0 or being 1 out causes read pairs to be detached, breaking
 5634|       |        // the lossy read name compression, so we have extra options to
 5635|       |        // slacken the exact TLEN round-trip checks.
 5636|      0|        fd->tlen_approx = fd->lossy_read_names;
 5637|      0|        fd->tlen_zero = fd->lossy_read_names;
 5638|      0|        break;
 5639|       |
 5640|      0|    case CRAM_OPT_USE_BZIP2:
 5641|      0|        fd->use_bz2 = va_arg(args, int);
 5642|      0|        break;
 5643|       |
 5644|      0|    case CRAM_OPT_USE_RANS:
 5645|      0|        fd->use_rans = va_arg(args, int);
 5646|      0|        break;
 5647|       |
 5648|      0|    case CRAM_OPT_USE_TOK:
 5649|      0|        fd->use_tok = va_arg(args, int);
 5650|      0|        break;
 5651|       |
 5652|      0|    case CRAM_OPT_USE_FQZ:
 5653|      0|        fd->use_fqz = va_arg(args, int);
 5654|      0|        break;
 5655|       |
 5656|      0|    case CRAM_OPT_USE_ARITH:
 5657|      0|        fd->use_arith = va_arg(args, int);
 5658|      0|        break;
 5659|       |
 5660|      0|    case CRAM_OPT_USE_LZMA:
 5661|      0|        fd->use_lzma = va_arg(args, int);
 5662|      0|        break;
 5663|       |
 5664|      0|    case CRAM_OPT_SHARED_REF:
 5665|      0|        fd->shared_ref = 1;
 5666|      0|        refs = va_arg(args, refs_t *);
 5667|      0|        if (refs != fd->refs) {
 5668|      0|            if (fd->refs)
 5669|      0|                refs_free(fd->refs);
 5670|      0|            fd->refs = refs;
 5671|      0|            fd->refs->count++;
 5672|      0|        }
 5673|      0|        break;
 5674|       |
 5675|      0|    case CRAM_OPT_RANGE: {
 5676|      0|        int r = cram_seek_to_refpos(fd, va_arg(args, cram_range *));
 5677|      0|        pthread_mutex_lock(&fd->range_lock);
 5678|      0|        if (fd->range.refid != -2)
 5679|      0|            fd->required_fields |= SAM_POS;
 5680|      0|        pthread_mutex_unlock(&fd->range_lock);
 5681|      0|        return r;
 5682|      0|    }
 5683|       |
 5684|      0|    case CRAM_OPT_RANGE_NOSEEK: {
 5685|       |        // As per CRAM_OPT_RANGE, but no seeking
 5686|      0|        pthread_mutex_lock(&fd->range_lock);
 5687|      0|        cram_range *r = va_arg(args, cram_range *);
 5688|      0|        fd->range = *r;
 5689|      0|        if (r->refid == HTS_IDX_NOCOOR) {
 5690|      0|            fd->range.refid = -1;
 5691|      0|            fd->range.start = 0;
 5692|      0|        } else if (r->refid == HTS_IDX_START || r->refid == HTS_IDX_REST) {
 5693|      0|            fd->range.refid = -2; // special case in cram_next_slice
 5694|      0|        }
 5695|      0|        if (fd->range.refid != -2)
 5696|      0|            fd->required_fields |= SAM_POS;
 5697|      0|        fd->ooc = 0;
 5698|      0|        fd->eof = 0;
 5699|      0|        pthread_mutex_unlock(&fd->range_lock);
 5700|      0|        return 0;
 5701|      0|    }
 5702|       |
 5703|      0|    case CRAM_OPT_REFERENCE:
 5704|      0|        return cram_load_reference(fd, va_arg(args, char *));
 5705|       |
 5706|      0|    case CRAM_OPT_VERSION: {
 5707|      0|        int major, minor;
 5708|      0|        char *s = va_arg(args, char *);
 5709|      0|        if (2 != sscanf(s, "%d.%d", &major, &minor)) {
 5710|      0|            hts_log_error("Malformed version string %s", s);
 5711|      0|            return -1;
 5712|      0|        }
 5713|      0|        if (!((major == 1 &&  minor == 0) ||
 5714|      0|              (major == 2 && (minor == 0 || minor == 1)) ||
 5715|      0|              (major == 3 && (minor == 0 || minor == 1)) ||
 5716|      0|              (major == 4 &&  minor == 0))) {
 5717|      0|            hts_log_error("Unknown version string; use 1.0, 2.0, 2.1, 3.0, 3.1 or 4.0");
 5718|      0|            errno = EINVAL;
 5719|      0|            return -1;
 5720|      0|        }
 5721|       |
 5722|      0|        if (major > 3 || (major == 3 && minor > 0)) {
 5723|      0|            hts_log_warning(
 5724|      0|                "CRAM version %s is still a draft and subject to change.\n"
 5725|      0|                "This is a technology demonstration that should not be "
 5726|      0|                "used for archival data.", s);
 5727|      0|        }
 5728|       |
 5729|      0|        fd->version = major*256 + minor;
 5730|       |
 5731|      0|        fd->use_rans = (CRAM_MAJOR_VERS(fd->version) >= 3) ? 1 : 0;
 5732|       |
 5733|      0|        fd->use_tok = ((CRAM_MAJOR_VERS(fd->version) == 3 &&
 5734|      0|                        CRAM_MINOR_VERS(fd->version) >= 1) ||
 5735|      0|                        CRAM_MAJOR_VERS(fd->version) >= 4) ? 1 : 0;
 5736|      0|        cram_init_tables(fd);
 5737|       |
 5738|      0|        break;
 5739|      0|    }
 5740|       |
 5741|      0|    case CRAM_OPT_MULTI_SEQ_PER_SLICE:
 5742|      0|        fd->multi_seq_user = fd->multi_seq = va_arg(args, int);
 5743|      0|        break;
 5744|       |
 5745|      0|    case CRAM_OPT_NTHREADS: {
 5746|      0|        int nthreads =  va_arg(args, int);
 5747|      0|        if (nthreads >= 1) {
 5748|      0|            if (!(fd->pool = hts_tpool_init(nthreads)))
 5749|      0|                return -1;
 5750|       |
 5751|      0|            fd->rqueue = hts_tpool_process_init(fd->pool, nthreads*2, 0);
 5752|      0|            pthread_mutex_init(&fd->metrics_lock, NULL);
 5753|      0|            pthread_mutex_init(&fd->ref_lock, NULL);
 5754|      0|            pthread_mutex_init(&fd->range_lock, NULL);
 5755|      0|            pthread_mutex_init(&fd->bam_list_lock, NULL);
 5756|      0|            fd->shared_ref = 1;
 5757|      0|            fd->own_pool = 1;
 5758|      0|        }
 5759|      0|        break;
 5760|      0|    }
 5761|       |
 5762|      0|    case CRAM_OPT_THREAD_POOL: {
 5763|      0|        htsThreadPool *p = va_arg(args, htsThreadPool *);
 5764|      0|        fd->pool = p ? p->pool : NULL;
 5765|      0|        if (fd->pool) {
 5766|      0|            fd->rqueue = hts_tpool_process_init(fd->pool,
 5767|      0|                                                p->qsize ? p->qsize : hts_tpool_size(fd->pool)*2,
 5768|      0|                                                0);
 5769|      0|            pthread_mutex_init(&fd->metrics_lock, NULL);
 5770|      0|            pthread_mutex_init(&fd->ref_lock, NULL);
 5771|      0|            pthread_mutex_init(&fd->range_lock, NULL);
 5772|      0|            pthread_mutex_init(&fd->bam_list_lock, NULL);
 5773|      0|        }
 5774|      0|        fd->shared_ref = 1; // Needed to avoid clobbering ref between threads
 5775|      0|        fd->own_pool = 0;
 5776|       |
 5777|       |        //fd->qsize = 1;
 5778|       |        //fd->decoded = calloc(fd->qsize, sizeof(cram_container *));
 5779|       |        //hts_tpool_dispatch(fd->pool, cram_decoder_thread, fd);
 5780|      0|        break;
 5781|      0|    }
 5782|       |
 5783|      0|    case CRAM_OPT_REQUIRED_FIELDS:
 5784|      0|        fd->required_fields = va_arg(args, int);
 5785|      0|        if (fd->range.refid != -2)
 5786|      0|            fd->required_fields |= SAM_POS;
 5787|      0|        break;
 5788|       |
 5789|      0|    case CRAM_OPT_STORE_MD:
 5790|      0|        fd->store_md = va_arg(args, int);
 5791|      0|        break;
 5792|       |
 5793|      0|    case CRAM_OPT_STORE_NM:
 5794|      0|        fd->store_nm = va_arg(args, int);
 5795|      0|        break;
 5796|       |
 5797|      0|    case HTS_OPT_COMPRESSION_LEVEL:
 5798|      0|        fd->level = va_arg(args, int);
 5799|      0|        break;
 5800|       |
 5801|      0|    case HTS_OPT_PROFILE: {
 5802|      0|        enum hts_profile_option prof = va_arg(args, int);
 5803|      0|        switch (prof) {
 5804|      0|        case HTS_PROFILE_FAST:
 5805|      0|            if (fd->level == CRAM_DEFAULT_LEVEL) fd->level = 1;
 5806|      0|            fd->use_tok = 0;
 5807|      0|            fd->seqs_per_slice = 10000;
 5808|      0|            break;
 5809|       |
 5810|      0|        case HTS_PROFILE_NORMAL:
 5811|      0|            break;
 5812|       |
 5813|      0|        case HTS_PROFILE_SMALL:
 5814|      0|            if (fd->level == CRAM_DEFAULT_LEVEL) fd->level = 6;
 5815|      0|            fd->use_bz2 = 1;
 5816|      0|            fd->use_fqz = 1;
 5817|      0|            fd->seqs_per_slice = 25000;
 5818|      0|            break;
 5819|       |
 5820|      0|        case HTS_PROFILE_ARCHIVE:
 5821|      0|            if (fd->level == CRAM_DEFAULT_LEVEL) fd->level = 7;
 5822|      0|            fd->use_bz2 = 1;
 5823|      0|            fd->use_fqz = 1;
 5824|      0|            fd->use_arith = 1;
 5825|      0|            if (fd->level > 7)
 5826|      0|                fd->use_lzma = 1;
 5827|      0|            fd->seqs_per_slice = 100000;
 5828|      0|            break;
 5829|      0|        }
 5830|       |
 5831|      0|        if (fd->bases_per_slice == BASES_PER_SLICE)
 5832|      0|            fd->bases_per_slice = fd->seqs_per_slice * 500;
 5833|      0|        break;
 5834|      0|    }
 5835|       |
 5836|      0|    default:
 5837|      0|        hts_log_error("Unknown CRAM option code %d", opt);
 5838|      0|        errno = EINVAL;
 5839|      0|        return -1;
 5840|     65|    }
 5841|       |
 5842|     65|    return 0;
 5843|     65|}
cram_io.c:int32_decode:
 1000|    103|static int int32_decode(cram_fd *fd, int32_t *val) {
 1001|    103|    int32_t i;
 1002|    103|    if (4 != hread(fd->fp, &i, 4))
 1003|      4|        return -1;
 1004|       |
 1005|     99|    *val = le_int4(i);
 1006|     99|    return 4;
 1007|     99|}
cram_io.c:refs_from_header:
 2716|     65|static int refs_from_header(cram_fd *fd) {
 2717|     65|    if (!fd)
 2718|      0|        return -1;
 2719|       |
 2720|     65|    refs_t *r = fd->refs;
 2721|     65|    if (!r)
 2722|      0|        return -1;
 2723|       |
 2724|     65|    sam_hdr_t *h = fd->header;
 2725|     65|    if (!h)
 2726|      0|        return 0;
 2727|       |
 2728|     65|    if (!h->hrecs) {
 2729|     64|        if (-1 == sam_hdr_fill_hrecs(h))
 2730|      0|            return -1;
 2731|     65|    }
 2732|       |
 2733|     65|    if (h->hrecs->nref == 0)
 2734|     65|        return 0;
 2735|       |
 2736|       |    //fprintf(stderr, "refs_from_header for %p mode %c\n", fd, fd->mode);
 2737|       |
 2738|       |    /* Existing refs are fine, as long as they're compatible with the hdr. */
 2739|      0|    ref_entry **new_ref_id = realloc(r->ref_id, (r->nref + h->hrecs->nref) * sizeof(*r->ref_id));
 2740|      0|    if (!new_ref_id)
 2741|      0|        return -1;
 2742|      0|    r->ref_id = new_ref_id;
 2743|       |
 2744|      0|    int i, j;
 2745|       |    /* Copy info from h->ref[i] over to r */
 2746|      0|    for (i = 0, j = r->nref; i < h->hrecs->nref; i++) {
 2747|      0|        sam_hrec_type_t *ty;
 2748|      0|        sam_hrec_tag_t *tag;
 2749|      0|        khint_t k;
 2750|      0|        int n;
 2751|       |
 2752|      0|        k = kh_get(refs, r->h_meta, h->hrecs->ref[i].name);
 2753|      0|        if (k != kh_end(r->h_meta))
 2754|       |            // Ref already known about
 2755|      0|            continue;
 2756|       |
 2757|      0|        if (!(r->ref_id[j] = calloc(1, sizeof(ref_entry))))
 2758|      0|            return -1;
 2759|       |
 2760|      0|        if (!h->hrecs->ref[i].name)
 2761|      0|            return -1;
 2762|       |
 2763|      0|        r->ref_id[j]->name = string_dup(r->pool, h->hrecs->ref[i].name);
 2764|      0|        if (!r->ref_id[j]->name) return -1;
 2765|      0|        r->ref_id[j]->length = 0; // marker for not yet loaded
 2766|       |
 2767|       |        /* Initialise likely filename if known */
 2768|      0|        if ((ty = sam_hrecs_find_type_id(h->hrecs, "SQ", "SN", h->hrecs->ref[i].name))) {
 2769|      0|            if ((tag = sam_hrecs_find_key(ty, "M5", NULL))) {
 2770|      0|                r->ref_id[j]->fn = string_dup(r->pool, tag->str+3);
 2771|       |                //fprintf(stderr, "Tagging @SQ %s / %s\n", r->ref_id[h]->name, r->ref_id[h]->fn);
 2772|      0|            }
 2773|      0|        }
 2774|       |
 2775|      0|        k = kh_put(refs, r->h_meta, r->ref_id[j]->name, &n);
 2776|      0|        if (n <= 0) // already exists or error
 2777|      0|            return -1;
 2778|      0|        kh_val(r->h_meta, k) = r->ref_id[j];
 2779|       |
 2780|      0|        j++;
 2781|      0|    }
 2782|      0|    r->nref = j;
 2783|       |
 2784|      0|    return 0;
 2785|      0|}
cram_io.c:refs_create:
 2419|     65|static refs_t *refs_create(void) {
 2420|     65|    refs_t *r = calloc(1, sizeof(*r));
 2421|       |
 2422|     65|    RP("refs_create()\n");
 2423|       |
 2424|     65|    if (!r)
 2425|      0|        return NULL;
 2426|       |
 2427|     65|    if (!(r->pool = string_pool_create(8192)))
 2428|      0|        goto err;
 2429|       |
 2430|     65|    r->ref_id = NULL; // see refs2id() to populate.
 2431|     65|    r->count = 1;
 2432|     65|    r->last = NULL;
 2433|     65|    r->last_id = -1;
 2434|       |
 2435|     65|    if (!(r->h_meta = kh_init(refs)))
 2436|      0|        goto err;
 2437|       |
 2438|     65|    pthread_mutex_init(&r->lock, NULL);
 2439|       |
 2440|     65|    return r;
 2441|       |
 2442|      0| err:
 2443|      0|    refs_free(r);
 2444|      0|    return NULL;
 2445|     65|}
cram_io.c:cram_init_tables:
 5050|    119|static void cram_init_tables(cram_fd *fd) {
 5051|    119|    int i;
 5052|       |
 5053|    119|    memset(fd->L1, 4, 256);
 5054|    119|    fd->L1['A'] = 0; fd->L1['a'] = 0;
 5055|    119|    fd->L1['C'] = 1; fd->L1['c'] = 1;
 5056|    119|    fd->L1['G'] = 2; fd->L1['g'] = 2;
 5057|    119|    fd->L1['T'] = 3; fd->L1['t'] = 3;
 5058|       |
 5059|    119|    memset(fd->L2, 5, 256);
 5060|    119|    fd->L2['A'] = 0; fd->L2['a'] = 0;
 5061|    119|    fd->L2['C'] = 1; fd->L2['c'] = 1;
 5062|    119|    fd->L2['G'] = 2; fd->L2['g'] = 2;
 5063|    119|    fd->L2['T'] = 3; fd->L2['t'] = 3;
 5064|    119|    fd->L2['N'] = 4; fd->L2['n'] = 4;
 5065|       |
 5066|    119|    if (CRAM_MAJOR_VERS(fd->version) == 1) {
 5067|  36.4k|        for (i = 0; i < 0x200; i++) {
 5068|  36.3k|            int f = 0;
 5069|       |
 5070|  36.3k|            if (i & CRAM_FPAIRED)      f |= BAM_FPAIRED;
 5071|  36.3k|            if (i & CRAM_FPROPER_PAIR) f |= BAM_FPROPER_PAIR;
 5072|  36.3k|            if (i & CRAM_FUNMAP)       f |= BAM_FUNMAP;
 5073|  36.3k|            if (i & CRAM_FREVERSE)     f |= BAM_FREVERSE;
 5074|  36.3k|            if (i & CRAM_FREAD1)       f |= BAM_FREAD1;
 5075|  36.3k|            if (i & CRAM_FREAD2)       f |= BAM_FREAD2;
 5076|  36.3k|            if (i & CRAM_FSECONDARY)   f |= BAM_FSECONDARY;
 5077|  36.3k|            if (i & CRAM_FQCFAIL)      f |= BAM_FQCFAIL;
 5078|  36.3k|            if (i & CRAM_FDUP)         f |= BAM_FDUP;
 5079|       |
 5080|  36.3k|            fd->bam_flag_swap[i]  = f;
 5081|  36.3k|        }
 5082|       |
 5083|   290k|        for (i = 0; i < 0x1000; i++) {
 5084|   290k|            int g = 0;
 5085|       |
 5086|   290k|            if (i & BAM_FPAIRED)           g |= CRAM_FPAIRED;
 5087|   290k|            if (i & BAM_FPROPER_PAIR)  g |= CRAM_FPROPER_PAIR;
 5088|   290k|            if (i & BAM_FUNMAP)        g |= CRAM_FUNMAP;
 5089|   290k|            if (i & BAM_FREVERSE)      g |= CRAM_FREVERSE;
 5090|   290k|            if (i & BAM_FREAD1)        g |= CRAM_FREAD1;
 5091|   290k|            if (i & BAM_FREAD2)        g |= CRAM_FREAD2;
 5092|   290k|            if (i & BAM_FSECONDARY)    g |= CRAM_FSECONDARY;
 5093|   290k|            if (i & BAM_FQCFAIL)       g |= CRAM_FQCFAIL;
 5094|   290k|            if (i & BAM_FDUP)          g |= CRAM_FDUP;
 5095|       |
 5096|   290k|            fd->cram_flag_swap[i] = g;
 5097|   290k|        }
 5098|     48|    } else {
 5099|       |        /* NOP */
 5100|   196k|        for (i = 0; i < 0x1000; i++)
 5101|   196k|            fd->bam_flag_swap[i] = i;
 5102|   196k|        for (i = 0; i < 0x1000; i++)
 5103|   196k|            fd->cram_flag_swap[i] = i;
 5104|     48|    }
 5105|       |
 5106|    119|    memset(fd->cram_sub_matrix, 4, 32*32);
 5107|  3.92k|    for (i = 0; i < 32; i++) {
 5108|  3.80k|        fd->cram_sub_matrix[i]['A'&0x1f]=0;
 5109|  3.80k|        fd->cram_sub_matrix[i]['C'&0x1f]=1;
 5110|  3.80k|        fd->cram_sub_matrix[i]['G'&0x1f]=2;
 5111|  3.80k|        fd->cram_sub_matrix[i]['T'&0x1f]=3;
 5112|  3.80k|        fd->cram_sub_matrix[i]['N'&0x1f]=4;
 5113|  3.80k|    }
 5114|    714|    for (i = 0; i < 20; i+=4) {
 5115|    595|        int j;
 5116|  12.4k|        for (j = 0; j < 20; j++) {
 5117|  11.9k|            fd->cram_sub_matrix["ACGTN"[i>>2]&0x1f][j]=3;
 5118|  11.9k|            fd->cram_sub_matrix["ACGTN"[i>>2]&0x1f][j]=3;
 5119|  11.9k|            fd->cram_sub_matrix["ACGTN"[i>>2]&0x1f][j]=3;
 5120|  11.9k|            fd->cram_sub_matrix["ACGTN"[i>>2]&0x1f][j]=3;
 5121|  11.9k|        }
 5122|    595|        fd->cram_sub_matrix["ACGTN"[i>>2]&0x1f][CRAM_SUBST_MATRIX[i+0]&0x1f]=0;
 5123|    595|        fd->cram_sub_matrix["ACGTN"[i>>2]&0x1f][CRAM_SUBST_MATRIX[i+1]&0x1f]=1;
 5124|    595|        fd->cram_sub_matrix["ACGTN"[i>>2]&0x1f][CRAM_SUBST_MATRIX[i+2]&0x1f]=2;
 5125|    595|        fd->cram_sub_matrix["ACGTN"[i>>2]&0x1f][CRAM_SUBST_MATRIX[i+3]&0x1f]=3;
 5126|    595|    }
 5127|       |
 5128|    119|    cram_init_varint(&fd->vv, CRAM_MAJOR_VERS(fd->version));
 5129|    119|}
cram_io.c:cram_init_varint:
 5007|    119|static void cram_init_varint(varint_vec *vv, int version) {
 5008|    119|    if (version >= 4) {
 5009|     26|        vv->varint_get32 = uint7_get_32; // FIXME: varint.h API should be size agnostic
 5010|     26|        vv->varint_get32s = sint7_get_32;
 5011|     26|        vv->varint_get64 = uint7_get_64;
 5012|     26|        vv->varint_get64s = sint7_get_64;
 5013|     26|        vv->varint_put32 = uint7_put_32;
 5014|     26|        vv->varint_put32s = sint7_put_32;
 5015|     26|        vv->varint_put64 = uint7_put_64;
 5016|     26|        vv->varint_put64s = sint7_put_64;
 5017|     26|        vv->varint_put32_blk = uint7_put_blk_32;
 5018|     26|        vv->varint_put32s_blk = sint7_put_blk_32;
 5019|     26|        vv->varint_put64_blk = uint7_put_blk_64;
 5020|     26|        vv->varint_put64s_blk = sint7_put_blk_64;
 5021|     26|        vv->varint_size = uint7_size;
 5022|     26|        vv->varint_decode32_crc = uint7_decode_crc32;
 5023|     26|        vv->varint_decode32s_crc = sint7_decode_crc32;
 5024|     26|        vv->varint_decode64_crc = uint7_decode_crc64;
 5025|     93|    } else {
 5026|     93|        vv->varint_get32 = safe_itf8_get;
 5027|     93|        vv->varint_get32s = safe_itf8_get;
 5028|     93|        vv->varint_get64 = safe_ltf8_get;
 5029|     93|        vv->varint_get64s = safe_ltf8_get;
 5030|     93|        vv->varint_put32 = safe_itf8_put;
 5031|     93|        vv->varint_put32s = safe_itf8_put;
 5032|     93|        vv->varint_put64 = safe_ltf8_put;
 5033|     93|        vv->varint_put64s = safe_ltf8_put;
 5034|     93|        vv->varint_put32_blk = itf8_put_blk;
 5035|     93|        vv->varint_put32s_blk = itf8_put_blk;
 5036|     93|        vv->varint_put64_blk = ltf8_put_blk;
 5037|     93|        vv->varint_put64s_blk = ltf8_put_blk;
 5038|     93|        vv->varint_size = itf8_size;
 5039|     93|        vv->varint_decode32_crc = itf8_decode_crc;
 5040|     93|        vv->varint_decode32s_crc = itf8_decode_crc;
 5041|     93|        vv->varint_decode64_crc = ltf8_decode_crc;
 5042|     93|    }
 5043|    119|}
cram_io.c:uint7_decode_crc32:
  857|    371|static int uint7_decode_crc32(cram_fd *fd, int32_t *val_p, uint32_t *crc) {
  858|    371|    uint8_t b[5], i = 0;
  859|    371|    int c;
  860|    371|    uint32_t v = 0;
  861|       |
  862|       |#ifdef VARINT2
  863|       |    b[0] = hgetc(fd->fp);
  864|       |    if (b[0] < 177) {
  865|       |    } else if (b[0] < 241) {
  866|       |        b[1] = hgetc(fd->fp);
  867|       |    } else if (b[0] < 249) {
  868|       |        b[1] = hgetc(fd->fp);
  869|       |        b[2] = hgetc(fd->fp);
  870|       |    } else {
  871|       |        int n = b[0]+2, z = 1;
  872|       |        while (n-- >= 249)
  873|       |            b[z++] = hgetc(fd->fp);
  874|       |    }
  875|       |    i = var_get_u32(b, NULL, &v);
  876|       |#else
  877|       |//    // Little endian
  878|       |//    int s = 0;
  879|       |//    do {
  880|       |//        b[i++] = c = hgetc(fd->fp);
  881|       |//        if (c < 0)
  882|       |//            return -1;
  883|       |//        v |= (c & 0x7f) << s;
  884|       |//      s += 7;
  885|       |//    } while (i < 5 && (c & 0x80));
  886|       |
  887|       |    // Big endian, see also htscodecs/varint.h
  888|    492|    do {
  889|    492|        b[i++] = c = hgetc(fd->fp);
  890|    492|        if (c < 0)
  891|     12|            return -1;
  892|    480|        v = (v<<7) | (c & 0x7f);
  893|    480|    } while (i < 5 && (c & 0x80));
  894|    371|#endif
  895|    359|    *crc = crc32(*crc, b, i);
  896|       |
  897|    359|    *val_p = v;
  898|    359|    return i;
  899|    371|}
cram_io.c:sint7_decode_crc32:
  902|     25|static int sint7_decode_crc32(cram_fd *fd, int32_t *val_p, uint32_t *crc) {
  903|     25|    uint8_t b[5], i = 0;
  904|     25|    int c;
  905|     25|    uint32_t v = 0;
  906|       |
  907|       |#ifdef VARINT2
  908|       |    b[0] = hgetc(fd->fp);
  909|       |    if (b[0] < 177) {
  910|       |    } else if (b[0] < 241) {
  911|       |        b[1] = hgetc(fd->fp);
  912|       |    } else if (b[0] < 249) {
  913|       |        b[1] = hgetc(fd->fp);
  914|       |        b[2] = hgetc(fd->fp);
  915|       |    } else {
  916|       |        int n = b[0]+2, z = 1;
  917|       |        while (n-- >= 249)
  918|       |            b[z++] = hgetc(fd->fp);
  919|       |    }
  920|       |    i = var_get_u32(b, NULL, &v);
  921|       |#else
  922|       |//    // Little endian
  923|       |//    int s = 0;
  924|       |//    do {
  925|       |//        b[i++] = c = hgetc(fd->fp);
  926|       |//        if (c < 0)
  927|       |//            return -1;
  928|       |//        v |= (c & 0x7f) << s;
  929|       |//      s += 7;
  930|       |//    } while (i < 5 && (c & 0x80));
  931|       |
  932|       |    // Big endian, see also htscodecs/varint.h
  933|     68|    do {
  934|     68|        b[i++] = c = hgetc(fd->fp);
  935|     68|        if (c < 0)
  936|      1|            return -1;
  937|     67|        v = (v<<7) | (c & 0x7f);
  938|     67|    } while (i < 5 && (c & 0x80));
  939|     25|#endif
  940|     24|    *crc = crc32(*crc, b, i);
  941|       |
  942|     24|    *val_p = (v>>1) ^ -(v&1);
  943|     24|    return i;
  944|     25|}
cram_io.c:uint7_decode_crc64:
  948|     90|static int uint7_decode_crc64(cram_fd *fd, int64_t *val_p, uint32_t *crc) {
  949|     90|    uint8_t b[10], i = 0;
  950|     90|    int c;
  951|     90|    uint64_t v = 0;
  952|       |
  953|       |#ifdef VARINT2
  954|       |    b[0] = hgetc(fd->fp);
  955|       |    if (b[0] < 177) {
  956|       |    } else if (b[0] < 241) {
  957|       |        b[1] = hgetc(fd->fp);
  958|       |    } else if (b[0] < 249) {
  959|       |        b[1] = hgetc(fd->fp);
  960|       |        b[2] = hgetc(fd->fp);
  961|       |    } else {
  962|       |        int n = b[0]+2, z = 1;
  963|       |        while (n-- >= 249)
  964|       |            b[z++] = hgetc(fd->fp);
  965|       |    }
  966|       |    i = var_get_u64(b, NULL, &v);
  967|       |#else
  968|       |//    // Little endian
  969|       |//    int s = 0;
  970|       |//    do {
  971|       |//        b[i++] = c = hgetc(fd->fp);
  972|       |//        if (c < 0)
  973|       |//            return -1;
  974|       |//        v |= (c & 0x7f) << s;
  975|       |//      s += 7;
  976|       |//    } while (i < 10 && (c & 0x80));
  977|       |
  978|       |    // Big endian, see also htscodecs/varint.h
  979|    179|    do {
  980|    179|        b[i++] = c = hgetc(fd->fp);
  981|    179|        if (c < 0)
  982|      3|            return -1;
  983|    176|        v = (v<<7) | (c & 0x7f);
  984|    176|    } while (i < 5 && (c & 0x80));
  985|     90|#endif
  986|     87|    *crc = crc32(*crc, b, i);
  987|       |
  988|     87|    *val_p = v;
  989|     87|    return i;
  990|     90|}
cram_io.c:safe_itf8_get:
  639|     11|static int64_t safe_itf8_get(char **cp, const char *endp, int *err) {
  640|     11|    const unsigned char *up = (unsigned char *)*cp;
  641|       |
  642|     11|    if (endp && endp - *cp < 5 &&
  643|     11|        (*cp >= endp || endp - *cp < itf8_bytes[up[0]>>4])) {
  644|     11|        if (err) *err = 1;
  645|     11|        return 0;
  646|     11|    }
  647|       |
  648|      0|    if (up[0] < 0x80) {
  649|      0|        (*cp)++;
  650|      0|        return up[0];
  651|      0|    } else if (up[0] < 0xc0) {
  652|      0|        (*cp)+=2;
  653|      0|        return ((up[0] <<8) |  up[1])                           & 0x3fff;
  654|      0|    } else if (up[0] < 0xe0) {
  655|      0|        (*cp)+=3;
  656|      0|        return ((up[0]<<16) | (up[1]<< 8) |  up[2])             & 0x1fffff;
  657|      0|    } else if (up[0] < 0xf0) {
  658|      0|        (*cp)+=4;
  659|      0|        uint32_t uv = (((uint32_t)up[0]<<24) | (up[1]<<16) | (up[2]<<8) | up[3]) & 0x0fffffff;
  660|      0|        return (int32_t)uv;
  661|      0|    } else {
  662|      0|        (*cp)+=5;
  663|      0|        uint32_t uv = (((uint32_t)up[0] & 0x0f)<<28) | (up[1]<<20) | (up[2]<<12) | (up[3]<<4) | (up[4] & 0x0f);
  664|      0|        return (int32_t)uv;
  665|      0|    }
  666|      0|}
cram_io.c:itf8_size:
  750|      3|static int itf8_size(int64_t v) {
  751|      3|    return ((!((v)&~0x7f))?1:(!((v)&~0x3fff))?2:(!((v)&~0x1fffff))?3:(!((v)&~0xfffffff))?4:5);
  752|      3|}

pool_create:
   64|    782|pool_alloc_t *pool_create(size_t dsize) {
   65|    782|    pool_alloc_t *p;
   66|       |
   67|    782|    if (NULL == (p = (pool_alloc_t *)malloc(sizeof(*p))))
   68|      0|        return NULL;
   69|       |
   70|       |    /* Minimum size is a pointer, for free list */
   71|    782|    dsize = (dsize + sizeof(void *) - 1) & ~(sizeof(void *)-1);
   72|    782|    if (dsize < sizeof(void *))
   73|      0|        dsize = sizeof(void *);
   74|    782|    p->dsize = dsize;
   75|    782|    p->psize = MIN(PSIZE, next_power_2(p->dsize*1024));
   76|       |
   77|    782|    p->npools = 0;
   78|    782|    p->pools = NULL;
   79|    782|    p->free  = NULL;
   80|       |
   81|    782|    return p;
   82|    782|}
pool_destroy:
   84|    782|void pool_destroy(pool_alloc_t *p) {
   85|    782|    size_t i;
   86|       |
   87|    960|    for (i = 0; i < p->npools; i++) {
   88|    178|        free(p->pools[i].pool);
   89|    178|    }
   90|    782|    free(p->pools);
   91|    782|    free(p);
   92|    782|}
pool_alloc:
  115|    215|void *pool_alloc(pool_alloc_t *p) {
  116|    215|    pool_t *pool;
  117|    215|    void *ret;
  118|       |
  119|       |    /* Look on free list */
  120|    215|    if (NULL != p->free) {
  121|      0|        ret = p->free;
  122|      0|        p->free = *((void **)p->free);
  123|      0|        return ret;
  124|      0|    }
  125|       |
  126|       |    /* Look for space in the last pool */
  127|    215|    if (p->npools) {
  128|     37|        pool = &p->pools[p->npools - 1];
  129|     37|        if (pool->used + p->dsize < p->psize) {
  130|     37|            ret = ((char *) pool->pool) + pool->used;
  131|     37|            pool->used += p->dsize;
  132|     37|            return ret;
  133|     37|        }
  134|    178|    }
  135|       |
  136|       |    /* Need a new pool */
  137|    178|    pool = new_pool(p);
  138|    178|    if (NULL == pool) return NULL;
  139|       |
  140|    178|    pool->used = p->dsize;
  141|    178|    return pool->pool;
  142|    178|}
pooled_alloc.c:next_power_2:
   47|  1.56k|static int next_power_2(unsigned int v) {
   48|  1.56k|    v--;
   49|  1.56k|    v |= v >> 1;
   50|  1.56k|    v |= v >> 2;
   51|  1.56k|    v |= v >> 4;
   52|  1.56k|    v |= v >> 8;
   53|  1.56k|    v |= v >> 16;
   54|  1.56k|    v++;
   55|       |
   56|  1.56k|    return v;
   57|  1.56k|}
pooled_alloc.c:new_pool:
   96|    178|static pool_t *new_pool(pool_alloc_t *p) {
   97|    178|    size_t n = p->psize / p->dsize;
   98|    178|    pool_t *pool;
   99|       |
  100|    178|    pool = realloc(p->pools, (p->npools + 1) * sizeof(*p->pools));
  101|    178|    if (NULL == pool) return NULL;
  102|    178|    p->pools = pool;
  103|    178|    pool = &p->pools[p->npools];
  104|       |
  105|    178|    pool->pool = malloc(n * p->dsize);
  106|    178|    if (NULL == pool->pool) return NULL;
  107|       |
  108|    178|    pool->used = 0;
  109|       |
  110|    178|    p->npools++;
  111|       |
  112|    178|    return pool;
  113|    178|}

string_pool_create:
   55|    456|string_alloc_t *string_pool_create(size_t max_length) {
   56|    456|    string_alloc_t *a_str;
   57|       |
   58|    456|    if (NULL == (a_str = (string_alloc_t *)malloc(sizeof(*a_str)))) {
   59|      0|        return NULL;
   60|      0|    }
   61|       |
   62|    456|    if (max_length < MIN_STR_SIZE) max_length = MIN_STR_SIZE;
   63|       |
   64|    456|    a_str->nstrings    = 0;
   65|    456|    a_str->max_strings = 0;
   66|    456|    a_str->max_length  = max_length;
   67|    456|    a_str->strings     = NULL;
   68|       |
   69|    456|    return a_str;
   70|    456|}
string_pool_destroy:
  103|    456|void string_pool_destroy(string_alloc_t *a_str) {
  104|    456|    size_t i;
  105|       |
  106|    511|    for (i = 0; i < a_str->nstrings; i++) {
  107|     55|        free(a_str->strings[i].str);
  108|     55|    }
  109|       |
  110|    456|    free(a_str->strings);
  111|    456|    free(a_str);
  112|    456|}
string_alloc:
  117|     79|char *string_alloc(string_alloc_t *a_str, size_t length) {
  118|     79|    string_t *str;
  119|     79|    char *ret;
  120|       |
  121|     79|    if (length <= 0) return NULL;
  122|       |
  123|       |    // add to last string pool if we have space
  124|     79|    if (a_str->nstrings) {
  125|     24|        str = &a_str->strings[a_str->nstrings - 1];
  126|       |
  127|     24|        if (str->used + length < a_str->max_length) {
  128|     24|            ret = str->str + str->used;
  129|     24|            str->used += length;
  130|     24|            return ret;
  131|     24|        }
  132|     55|    }
  133|       |
  134|       |    // increase the max length if needs be
  135|     55|    if (length > a_str->max_length) a_str->max_length = length;
  136|       |
  137|       |    // need a new string pool
  138|     55|    str = new_string_pool(a_str);
  139|       |
  140|     55|    if (NULL == str) return NULL;
  141|       |
  142|     55|    str->used = length;
  143|     55|    return str->str;
  144|     55|}
string_ndup:
  153|     79|char *string_ndup(string_alloc_t *a_str, const char *instr, size_t len) {
  154|     79|    char *str = string_alloc(a_str, len + 1);
  155|       |
  156|     79|    if (NULL == str) return NULL;
  157|       |
  158|     79|    memcpy(str, instr, len);
  159|     79|    str[len] = 0;
  160|       |
  161|     79|    return str;
  162|     79|}
string_alloc.c:new_string_pool:
   75|     55|static string_t *new_string_pool(string_alloc_t *a_str) {
   76|     55|    string_t *str;
   77|       |
   78|     55|    if (a_str->nstrings == a_str->max_strings) {
   79|     55|        size_t new_max = (a_str->max_strings | (a_str->max_strings >> 2)) + 1;
   80|     55|        str = realloc(a_str->strings, new_max * sizeof(*a_str->strings));
   81|       |
   82|     55|        if (NULL == str) return NULL;
   83|       |
   84|     55|        a_str->strings = str;
   85|     55|        a_str->max_strings = new_max;
   86|     55|    }
   87|       |
   88|     55|    str = &a_str->strings[a_str->nstrings];
   89|       |
   90|     55|    str->str = malloc(a_str->max_length);
   91|       |
   92|     55|    if (NULL == str->str) return NULL;
   93|       |
   94|     55|    str->used = 0;
   95|     55|    a_str->nstrings++;
   96|       |
   97|     55|    return str;
   98|     55|}

sam_hdr_update_target_arrays:
  906|     65|                                 int refs_changed) {
  907|     65|    if (!bh || !hrecs)
  908|      0|        return -1;
  909|       |
  910|     65|    if (refs_changed < 0)
  911|      0|        return 0;
  912|       |
  913|       |    // Grow arrays if necessary
  914|     65|    if (bh->n_targets < hrecs->nref) {
  915|      0|        char **new_names = realloc(bh->target_name,
  916|      0|                                   hrecs->nref * sizeof(*new_names));
  917|      0|        if (!new_names)
  918|      0|            return -1;
  919|      0|        bh->target_name = new_names;
  920|      0|        uint32_t *new_lens = realloc(bh->target_len,
  921|      0|                                     hrecs->nref * sizeof(*new_lens));
  922|      0|        if (!new_lens)
  923|      0|            return -1;
  924|      0|        bh->target_len = new_lens;
  925|      0|    }
  926|       |
  927|       |    // Update names and lengths where changed
  928|       |    // hrecs->refs_changed is the first ref that has been updated, so ones
  929|       |    // before that can be skipped.
  930|     65|    int i;
  931|     65|    khint_t k;
  932|     65|    khash_t(s2i) *long_refs = (khash_t(s2i) *) bh->sdict;
  933|     65|    for (i = refs_changed; i < hrecs->nref; i++) {
  934|      0|        if (i >= bh->n_targets
  935|      0|            || strcmp(bh->target_name[i], hrecs->ref[i].name) != 0) {
  936|      0|            if (i < bh->n_targets)
  937|      0|                free(bh->target_name[i]);
  938|      0|            bh->target_name[i] = strdup(hrecs->ref[i].name);
  939|      0|            if (!bh->target_name[i])
  940|      0|                return -1;
  941|      0|        }
  942|      0|        if (hrecs->ref[i].len < UINT32_MAX) {
  943|      0|            bh->target_len[i] = hrecs->ref[i].len;
  944|       |
  945|      0|            if (!long_refs)
  946|      0|                continue;
  947|       |
  948|       |            // Check if we have an old length, if so remove it.
  949|      0|            k = kh_get(s2i, long_refs, bh->target_name[i]);
  950|      0|            if (k < kh_end(long_refs))
  951|      0|                kh_del(s2i, long_refs, k);
  952|      0|        } else {
  953|      0|            bh->target_len[i] = UINT32_MAX;
  954|      0|            if (bh->hrecs != hrecs) {
  955|       |                // Called from sam_hdr_dup; need to add sdict entries
  956|      0|                if (!long_refs) {
  957|      0|                    if (!(bh->sdict = long_refs = kh_init(s2i)))
  958|      0|                        return -1;
  959|      0|                }
  960|       |
  961|       |                // Add / update length
  962|      0|                int absent;
  963|      0|                k = kh_put(s2i, long_refs, bh->target_name[i], &absent);
  964|      0|                if (absent < 0)
  965|      0|                    return -1;
  966|      0|                kh_val(long_refs, k) = hrecs->ref[i].len;
  967|      0|            }
  968|      0|        }
  969|      0|    }
  970|       |
  971|       |    // Free up any names that have been removed
  972|     65|    for (; i < bh->n_targets; i++) {
  973|      0|        if (long_refs) {
  974|      0|            k = kh_get(s2i, long_refs, bh->target_name[i]);
  975|      0|            if (k < kh_end(long_refs))
  976|      0|                kh_del(s2i, long_refs, k);
  977|      0|        }
  978|      0|        free(bh->target_name[i]);
  979|      0|    }
  980|       |
  981|     65|    bh->n_targets = hrecs->nref;
  982|     65|    return 0;
  983|     65|}
sam_hdr_fill_hrecs:
 1118|    391|int sam_hdr_fill_hrecs(sam_hdr_t *bh) {
 1119|    391|    sam_hrecs_t *hrecs = sam_hrecs_new();
 1120|       |
 1121|    391|    if (!hrecs)
 1122|      0|        return -1;
 1123|       |
 1124|    391|    if (bh->target_name && bh->target_len && bh->n_targets > 0) {
 1125|      0|        if (sam_hrecs_refs_from_targets_array(hrecs, bh) != 0) {
 1126|      0|            sam_hrecs_free(hrecs);
 1127|      0|            return -1;
 1128|      0|        }
 1129|    391|    }
 1130|       |
 1131|       |    // Parse existing header text
 1132|    391|    if (bh->text && bh->l_text > 0) {
 1133|    125|        if (sam_hrecs_parse_lines(hrecs, bh->text, bh->l_text) != 0) {
 1134|    102|            sam_hrecs_free(hrecs);
 1135|    102|            return -1;
 1136|    102|        }
 1137|    289|    }
 1138|       |
 1139|    289|    if (add_stub_ref_sq_lines(hrecs) < 0) {
 1140|      0|        sam_hrecs_free(hrecs);
 1141|      0|        return -1;
 1142|      0|    }
 1143|       |
 1144|    289|    bh->hrecs = hrecs;
 1145|       |
 1146|    289|    if (hrecs->refs_changed >= 0 && rebuild_target_arrays(bh) != 0)
 1147|      0|        return -1;
 1148|       |
 1149|    289|    return 0;
 1150|    289|}
sam_hdr_add_lines:
 1286|     67|int sam_hdr_add_lines(sam_hdr_t *bh, const char *lines, size_t len) {
 1287|     67|    sam_hrecs_t *hrecs;
 1288|       |
 1289|     67|    if (!bh || !lines)
 1290|      0|        return -1;
 1291|       |
 1292|     67|    if (len == 0 && *lines == '\0')
 1293|     64|        return 0;
 1294|       |
 1295|      3|    if (!(hrecs = bh->hrecs)) {
 1296|      3|        if (sam_hdr_fill_hrecs(bh) != 0)
 1297|      0|            return -1;
 1298|      3|        hrecs = bh->hrecs;
 1299|      3|    }
 1300|       |
 1301|      3|    if (sam_hrecs_parse_lines(hrecs, lines, len) != 0)
 1302|      2|        return -1;
 1303|       |
 1304|      1|    if (hrecs->refs_changed >= 0 && rebuild_target_arrays(bh) != 0)
 1305|      0|        return -1;
 1306|       |
 1307|      1|    hrecs->dirty = 1;
 1308|      1|    redact_header_text(bh);
 1309|       |
 1310|      1|    return 0;
 1311|      1|}
sam_hdr_count_lines:
 1720|    324|int sam_hdr_count_lines(sam_hdr_t *bh, const char *type) {
 1721|    324|    int count;
 1722|    324|    sam_hrec_type_t *first_ty, *itr_ty;
 1723|       |
 1724|    324|    if (!bh || !type)
 1725|      0|        return -1;
 1726|       |
 1727|    324|    if (!bh->hrecs) {
 1728|    324|        if (sam_hdr_fill_hrecs(bh) != 0)
 1729|    102|            return -1;
 1730|    222|    }
 1731|       |
 1732|       |    // Deal with types that have counts
 1733|    222|    switch (type[0]) {
 1734|    222|    case 'S':
 1735|    222|        if (type[1] == 'Q')
 1736|    222|            return bh->hrecs->nref;
 1737|      0|        break;
 1738|      0|    case 'R':
 1739|      0|        if (type[1] == 'G')
 1740|      0|            return bh->hrecs->nrg;
 1741|      0|        break;
 1742|      0|    case 'P':
 1743|      0|        if (type[1] == 'G')
 1744|      0|            return bh->hrecs->npg;
 1745|      0|        break;
 1746|      0|    default:
 1747|      0|        break;
 1748|      0|    }
 1749|       |
 1750|      0|    first_ty = sam_hrecs_find_type_id(bh->hrecs, type, NULL, NULL);
 1751|      0|    if (!first_ty)
 1752|      0|        return 0;
 1753|       |
 1754|      0|    count = 1;
 1755|      0|    for (itr_ty = first_ty->next;
 1756|      0|         itr_ty && itr_ty != first_ty; itr_ty = itr_ty->next) {
 1757|      0|        count++;
 1758|      0|    }
 1759|       |
 1760|      0|    return count;
 1761|      0|}
sam_hrecs_rebuild_text:
 1954|    287|int sam_hrecs_rebuild_text(const sam_hrecs_t *hrecs, kstring_t *ks) {
 1955|    287|    ks->l = 0;
 1956|       |
 1957|    287|    if (!hrecs->h || !hrecs->h->size) {
 1958|    266|        return kputsn("", 0, ks) >= 0 ? 0 : -1;
 1959|    266|    }
 1960|     21|    if (sam_hrecs_rebuild_lines(hrecs, ks) != 0)
 1961|      0|        return -1;
 1962|       |
 1963|     21|    return 0;
 1964|     21|}
sam_hrecs_new:
 2298|    391|sam_hrecs_t *sam_hrecs_new() {
 2299|    391|    sam_hrecs_t *hrecs = calloc(1, sizeof(*hrecs));
 2300|       |
 2301|    391|    if (!hrecs)
 2302|      0|        return NULL;
 2303|       |
 2304|    391|    hrecs->h = kh_init(sam_hrecs_t);
 2305|    391|    if (!hrecs->h)
 2306|      0|        goto err;
 2307|       |
 2308|    391|    hrecs->ID_cnt = 1;
 2309|       |
 2310|    391|    hrecs->nref = 0;
 2311|    391|    hrecs->ref_sz = 0;
 2312|    391|    hrecs->ref  = NULL;
 2313|    391|    if (!(hrecs->ref_hash = kh_init(m_s2i)))
 2314|      0|        goto err;
 2315|    391|    hrecs->refs_changed = -1;
 2316|       |
 2317|    391|    hrecs->nrg = 0;
 2318|    391|    hrecs->rg_sz = 0;
 2319|    391|    hrecs->rg  = NULL;
 2320|    391|    if (!(hrecs->rg_hash = kh_init(m_s2i)))
 2321|      0|        goto err;
 2322|       |
 2323|    391|    hrecs->npg = 0;
 2324|    391|    hrecs->pg_sz = 0;
 2325|    391|    hrecs->pg  = NULL;
 2326|    391|    hrecs->npg_end = hrecs->npg_end_alloc = 0;
 2327|    391|    hrecs->pg_end = NULL;
 2328|    391|    if (!(hrecs->pg_hash = kh_init(m_s2i)))
 2329|      0|        goto err;
 2330|       |
 2331|    391|    if (!(hrecs->tag_pool = pool_create(sizeof(sam_hrec_tag_t))))
 2332|      0|        goto err;
 2333|       |
 2334|    391|    if (!(hrecs->type_pool = pool_create(sizeof(sam_hrec_type_t))))
 2335|      0|        goto err;
 2336|       |
 2337|    391|    if (!(hrecs->str_pool = string_pool_create(65536)))
 2338|      0|        goto err;
 2339|       |
 2340|    391|    if (sam_hrecs_init_type_order(hrecs, NULL))
 2341|      0|        goto err;
 2342|       |
 2343|    391|    return hrecs;
 2344|       |
 2345|      0|err:
 2346|      0|    if (hrecs->h)
 2347|      0|        kh_destroy(sam_hrecs_t, hrecs->h);
 2348|       |
 2349|      0|    if (hrecs->tag_pool)
 2350|      0|        pool_destroy(hrecs->tag_pool);
 2351|       |
 2352|      0|    if (hrecs->type_pool)
 2353|      0|        pool_destroy(hrecs->type_pool);
 2354|       |
 2355|      0|    if (hrecs->str_pool)
 2356|      0|        string_pool_destroy(hrecs->str_pool);
 2357|       |
 2358|      0|    free(hrecs);
 2359|       |
 2360|      0|    return NULL;
 2361|    391|}
sam_hrecs_free:
 2378|    391|void sam_hrecs_free(sam_hrecs_t *hrecs) {
 2379|    391|    if (!hrecs)
 2380|      0|        return;
 2381|       |
 2382|    391|    if (hrecs->h)
 2383|    391|        kh_destroy(sam_hrecs_t, hrecs->h);
 2384|       |
 2385|    391|    if (hrecs->ref_hash)
 2386|    391|        kh_destroy(m_s2i, hrecs->ref_hash);
 2387|       |
 2388|    391|    if (hrecs->ref)
 2389|      0|        free(hrecs->ref);
 2390|       |
 2391|    391|    if (hrecs->rg_hash)
 2392|    391|        kh_destroy(m_s2i, hrecs->rg_hash);
 2393|       |
 2394|    391|    if (hrecs->rg)
 2395|      0|        free(hrecs->rg);
 2396|       |
 2397|    391|    if (hrecs->pg_hash)
 2398|    391|        kh_destroy(m_s2i, hrecs->pg_hash);
 2399|       |
 2400|    391|    if (hrecs->pg)
 2401|      1|        free(hrecs->pg);
 2402|       |
 2403|    391|    if (hrecs->pg_end)
 2404|      0|        free(hrecs->pg_end);
 2405|       |
 2406|    391|    if (hrecs->type_pool)
 2407|    391|        pool_destroy(hrecs->type_pool);
 2408|       |
 2409|    391|    if (hrecs->tag_pool)
 2410|    391|        pool_destroy(hrecs->tag_pool);
 2411|       |
 2412|    391|    if (hrecs->str_pool)
 2413|    391|        string_pool_destroy(hrecs->str_pool);
 2414|       |
 2415|    391|    if (hrecs->type_order)
 2416|    391|        free(hrecs->type_order);
 2417|       |
 2418|    391|    if (hrecs->ID_buf)
 2419|      0|        free(hrecs->ID_buf);
 2420|       |
 2421|    391|    free(hrecs);
 2422|    391|}
sam_hrecs_find_key:
 2577|      2|                                   sam_hrec_tag_t **prev) {
 2578|      2|    sam_hrec_tag_t *tag, *p = NULL;
 2579|      2|    if (!type)
 2580|      0|        return NULL;
 2581|       |
 2582|      5|    for (tag = type->tag; tag; p = tag, tag = tag->next) {
 2583|      3|        if (tag->str[0] == key[0] && tag->str[1] == key[1]) {
 2584|      0|            if (prev)
 2585|      0|                *prev = p;
 2586|      0|            return tag;
 2587|      0|        }
 2588|      3|    }
 2589|       |
 2590|      2|    if (prev)
 2591|      0|        *prev = p;
 2592|       |
 2593|      2|    return NULL;
 2594|      2|}
header.c:sam_hrecs_parse_lines:
  764|    128|static int sam_hrecs_parse_lines(sam_hrecs_t *hrecs, const char *hdr, size_t len) {
  765|    128|    size_t i, lno;
  766|       |
  767|    128|    if (!hrecs || len > SSIZE_MAX)
  768|      0|        return -1;
  769|       |
  770|    128|    if (!len)
  771|      0|        len = strlen(hdr);
  772|       |
  773|    128|    if (len < 3) {
  774|      3|        if (len == 0 || *hdr == '\0') return 0;
  775|      2|        sam_hrecs_error("Header line too short", hdr, len, 1);
  776|      2|        return -1;
  777|      2|    }
  778|       |
  779|    167|    for (i = 0, lno = 1; i < len - 3 && hdr[i] != '\0'; i++, lno++) {
  780|    144|        khint32_t type;
  781|    144|        khint_t k;
  782|       |
  783|    144|        int l_start = i, new;
  784|    144|        sam_hrec_type_t *h_type;
  785|    144|        sam_hrec_tag_t *h_tag, *last;
  786|       |
  787|    144|        if (hdr[i] != '@') {
  788|      4|            sam_hrecs_error("Header line does not start with '@'",
  789|      4|                          &hdr[l_start], len - l_start, lno);
  790|      4|            return -1;
  791|      4|        }
  792|       |
  793|    140|        if (!isalpha_c(hdr[i+1]) || !isalpha_c(hdr[i+2])) {
  794|      3|            sam_hrecs_error("Header line does not have a two character key",
  795|      3|                          &hdr[l_start], len - l_start, lno);
  796|      3|            return -1;
  797|      3|        }
  798|    137|        type = TYPEKEY(&hdr[i+1]);
  799|       |
  800|    137|        i += 3;
  801|    137|        if (i == len || hdr[i] == '\n')
  802|      1|            continue;
  803|       |
  804|       |        // Add the header line type
  805|    136|        if (!(h_type = pool_alloc(hrecs->type_pool)))
  806|      0|            return -1;
  807|    136|        k = kh_put(sam_hrecs_t, hrecs->h, type, &new);
  808|    136|        if (new < 0)
  809|      0|            return -1;
  810|       |
  811|    136|        h_type->type = type;
  812|       |
  813|       |        // Add to end of global list
  814|    136|        sam_hrecs_global_list_add(hrecs, h_type, NULL);
  815|       |
  816|       |        // Form the ring, either with self or other lines of this type
  817|    136|        if (!new) {
  818|      8|            sam_hrec_type_t *t = kh_val(hrecs->h, k), *p;
  819|      8|            p = t->prev;
  820|       |
  821|      8|            assert(p->next == t);
  822|      8|            p->next = h_type;
  823|      8|            h_type->prev = p;
  824|       |
  825|      8|            t->prev = h_type;
  826|      8|            h_type->next = t;
  827|    128|        } else {
  828|    128|            kh_val(hrecs->h, k) = h_type;
  829|    128|            h_type->prev = h_type->next = h_type;
  830|    128|        }
  831|       |
  832|       |        // Parse the tags on this line
  833|    136|        last = NULL;
  834|    136|        if (type == TYPEKEY("CO")) {
  835|     42|            size_t j;
  836|       |
  837|     42|            if (i == len || hdr[i] != '\t') {
  838|      1|                sam_hrecs_error("Missing tab",
  839|      1|                              &hdr[l_start], len - l_start, lno);
  840|      1|                return -1;
  841|      1|            }
  842|       |
  843|    123|            for (j = ++i; j < len && hdr[j] != '\0' && hdr[j] != '\n'; j++)
  844|     82|                ;
  845|       |
  846|     41|            if (!(h_type->tag = h_tag = pool_alloc(hrecs->tag_pool)))
  847|      0|                return -1;
  848|     41|            h_tag->str = string_ndup(hrecs->str_pool, &hdr[i], j-i);
  849|     41|            h_tag->len = j-i;
  850|     41|            h_tag->next = NULL;
  851|     41|            if (!h_tag->str)
  852|      0|                return -1;
  853|       |
  854|     41|            i = j;
  855|       |
  856|     94|        } else {
  857|    118|            do {
  858|    118|                size_t j;
  859|       |
  860|    118|                if (i == len || hdr[i] != '\t') {
  861|      4|                    sam_hrecs_error("Missing tab",
  862|      4|                                  &hdr[l_start], len - l_start, lno);
  863|      4|                    return -1;
  864|      4|                }
  865|       |
  866|    810|                for (j = ++i; j < len && hdr[j] != '\0' && hdr[j] != '\n' && hdr[j] != '\t'; j++)
  867|    696|                    ;
  868|       |
  869|    114|                if (j - i < 3 || hdr[i + 2] != ':') {
  870|     76|                    sam_hrecs_error("Malformed key:value pair",
  871|     76|                                   &hdr[l_start], len - l_start, lno);
  872|     76|                    return -1;
  873|     76|                }
  874|       |
  875|     38|                if (!(h_tag = pool_alloc(hrecs->tag_pool)))
  876|      0|                    return -1;
  877|     38|                h_tag->str = string_ndup(hrecs->str_pool, &hdr[i], j-i);
  878|     38|                h_tag->len = j-i;
  879|     38|                h_tag->next = NULL;
  880|     38|                if (!h_tag->str)
  881|      0|                    return -1;
  882|       |
  883|     38|                if (last)
  884|     17|                    last->next = h_tag;
  885|     21|                else
  886|     21|                    h_type->tag = h_tag;
  887|       |
  888|     38|                last = h_tag;
  889|     38|                i = j;
  890|     38|            } while (i < len && hdr[i] != '\0' && hdr[i] != '\n');
  891|     94|        }
  892|       |
  893|       |        /* Update RG/SQ hashes */
  894|     55|        if (-1 == sam_hrecs_update_hashes(hrecs, type, h_type))
  895|     14|            return -1;
  896|     55|    }
  897|       |
  898|     23|    return 0;
  899|    125|}
header.c:sam_hrecs_error:
   54|     90|static void sam_hrecs_error(const char *msg, const char *line, size_t len, size_t lno) {
   55|     90|    int j;
   56|       |
   57|     90|    if (len > MAX_ERROR_QUOTE)
   58|      0|        len = MAX_ERROR_QUOTE;
   59|  1.97k|    for (j = 0; j < len && line[j] != '\n'; j++)
   60|  1.88k|        ;
   61|     90|    hts_log_error("%s at line %zd: \"%.*s\"", msg, lno, j, line);
   62|     90|}
header.c:sam_hrecs_global_list_add:
  489|    136|                                      sam_hrec_type_t *after) {
  490|    136|    const khint32_t hd_type = TYPEKEY("HD");
  491|    136|    int update_first_line = 0;
  492|       |
  493|       |    // First line seen
  494|    136|    if (!hrecs->first_line) {
  495|    123|        hrecs->first_line = h_type->global_next = h_type->global_prev = h_type;
  496|    123|        return;
  497|    123|    }
  498|       |
  499|       |    // @HD goes at the top (unless there's one already)
  500|     13|    if (h_type->type == hd_type && hrecs->first_line->type != hd_type) {
  501|      0|        after = hrecs->first_line->global_prev;
  502|      0|        update_first_line = 1;
  503|      0|    }
  504|       |
  505|       |    // If no instructions given, put it at the end
  506|     13|    if (!after)
  507|     13|        after = hrecs->first_line->global_prev;
  508|       |
  509|     13|    h_type->global_prev = after;
  510|     13|    h_type->global_next = after->global_next;
  511|     13|    h_type->global_prev->global_next = h_type;
  512|     13|    h_type->global_next->global_prev = h_type;
  513|       |
  514|     13|    if (update_first_line)
  515|      0|        hrecs->first_line = h_type;
  516|     13|}
header.c:add_stub_ref_sq_lines:
 1095|    289|static int add_stub_ref_sq_lines(sam_hrecs_t *hrecs) {
 1096|    289|    int tid;
 1097|    289|    char len[32];
 1098|       |
 1099|    289|    for (tid = 0; tid < hrecs->nref; tid++) {
 1100|      0|        if (hrecs->ref[tid].ty == NULL) {
 1101|      0|            snprintf(len, sizeof(len), "%"PRIhts_pos, hrecs->ref[tid].len);
 1102|      0|            if (sam_hrecs_add(hrecs, "SQ",
 1103|      0|                              "SN", hrecs->ref[tid].name,
 1104|      0|                              "LN", len, NULL) != 0)
 1105|      0|                return -1;
 1106|       |
 1107|       |            // Check that the stub has actually been filled
 1108|      0|            if(hrecs->ref[tid].ty == NULL) {
 1109|      0|                hts_log_error("Reference stub with tid=%d, name=\"%s\", len=%"PRIhts_pos" could not be filled",
 1110|      0|                        tid, hrecs->ref[tid].name, hrecs->ref[tid].len);
 1111|      0|                return -1;
 1112|      0|            }
 1113|      0|        }
 1114|      0|    }
 1115|    289|    return 0;
 1116|    289|}
header.c:redact_header_text:
 1159|      1|static void redact_header_text(sam_hdr_t *bh) {
 1160|      1|    assert(bh->hrecs && bh->hrecs->dirty);
 1161|      1|    bh->l_text = 0;
 1162|      1|    free(bh->text);
 1163|      1|    bh->text = NULL;
 1164|      1|}
header.c:build_header_line:
  730|     24|static int build_header_line(const sam_hrec_type_t *ty, kstring_t *ks) {
  731|     24|    sam_hrec_tag_t *tag;
  732|     24|    int r = 0;
  733|     24|    char c[2]= { ty->type >> 8, ty->type & 0xff };
  734|       |
  735|     24|    r |= (kputc_('@', ks) == EOF);
  736|     24|    r |= (kputsn(c, 2, ks) == EOF);
  737|     48|    for (tag = ty->tag; tag; tag = tag->next) {
  738|     24|        r |= (kputc_('\t', ks) == EOF);
  739|     24|        r |= (kputsn(tag->str, tag->len, ks) == EOF);
  740|     24|    }
  741|       |
  742|     24|    return r;
  743|     24|}
header.c:sam_hrecs_update_hashes:
  140|     55|                                   sam_hrec_type_t *h_type) {
  141|       |    /* Add to reference hash? */
  142|     55|    if (type == TYPEKEY("SQ")) {
  143|     11|        sam_hrec_tag_t *tag = h_type->tag;
  144|     11|        int nref = hrecs->nref;
  145|     11|        const char *name = NULL;
  146|     11|        const char *altnames = NULL;
  147|     11|        hts_pos_t len = -1;
  148|     11|        int r;
  149|     11|        khint_t k;
  150|       |
  151|     30|        while (tag) {
  152|     19|            if (tag->str[0] == 'S' && tag->str[1] == 'N') {
  153|      3|                assert(tag->len >= 3);
  154|      3|                name = tag->str+3;
  155|     16|            } else if (tag->str[0] == 'L' && tag->str[1] == 'N') {
  156|      6|                assert(tag->len >= 3);
  157|      6|                len = strtoll(tag->str+3, NULL, 10);
  158|     10|            } else if (tag->str[0] == 'A' && tag->str[1] == 'N') {
  159|      0|                assert(tag->len >= 3);
  160|      0|                altnames = tag->str+3;
  161|      0|            }
  162|     19|            tag = tag->next;
  163|     19|        }
  164|       |
  165|     11|        if (!name) {
  166|      9|            hts_log_error("Header includes @SQ line with no SN: tag");
  167|      9|            return -1; // SN should be present, according to spec.
  168|      9|        }
  169|       |
  170|      2|        if (len == -1) {
  171|      2|            hts_log_error("Header includes @SQ line \"%s\" with no LN: tag",
  172|      2|                          name);
  173|      2|            return -1; // LN should be present, according to spec.
  174|      2|        }
  175|       |
  176|       |        // Seen already?
  177|      0|        k = kh_get(m_s2i, hrecs->ref_hash, name);
  178|      0|        if (k < kh_end(hrecs->ref_hash)) {
  179|      0|            nref = kh_val(hrecs->ref_hash, k);
  180|      0|            int ref_changed_flag = 0;
  181|       |
  182|       |            // Check for hash entry added by sam_hrecs_refs_from_targets_array()
  183|      0|            if (hrecs->ref[nref].ty == NULL) {
  184|       |                // Attach header line to existing stub entry.
  185|      0|                hrecs->ref[nref].ty = h_type;
  186|       |                // Check lengths match; correct if not.
  187|      0|                if (len != hrecs->ref[nref].len) {
  188|      0|                    char tmp[32];
  189|      0|                    snprintf(tmp, sizeof(tmp), "%" PRIhts_pos,
  190|      0|                             hrecs->ref[nref].len);
  191|      0|                    if (sam_hrecs_update(hrecs, h_type, "LN", tmp, NULL) < 0)
  192|      0|                        return -1;
  193|      0|                    ref_changed_flag = 1;
  194|      0|                }
  195|      0|                if (sam_hrecs_add_ref_altnames(hrecs, nref, altnames) < 0)
  196|      0|                    return -1;
  197|       |
  198|      0|                if (ref_changed_flag && (hrecs->refs_changed < 0 || hrecs->refs_changed > nref))
  199|      0|                    hrecs->refs_changed = nref;
  200|      0|                return 0;
  201|      0|            }
  202|       |
  203|       |            // Check to see if an existing entry is being updated
  204|      0|            if (hrecs->ref[nref].ty == h_type) {
  205|      0|                if (hrecs->ref[nref].len != len) {
  206|      0|                    hrecs->ref[nref].len = len;
  207|      0|                    ref_changed_flag = 1;
  208|      0|                }
  209|      0|                if (!hrecs->ref[nref].name || strcmp(hrecs->ref[nref].name, name)) {
  210|      0|                    hrecs->ref[nref].name = name;
  211|      0|                    ref_changed_flag = 1;
  212|      0|                }
  213|      0|                if (sam_hrecs_add_ref_altnames(hrecs, nref, altnames) < 0)
  214|      0|                    return -1;
  215|       |
  216|      0|                if (ref_changed_flag && (hrecs->refs_changed < 0 || hrecs->refs_changed > nref))
  217|      0|                    hrecs->refs_changed = nref;
  218|      0|                return 0;
  219|      0|            }
  220|       |
  221|       |            // If here, the name is a duplicate.
  222|       |            // Check to see if it matches the SN: tag from the earlier record.
  223|      0|            if (strcmp(hrecs->ref[nref].name, name) == 0) {
  224|      0|                hts_log_error("Duplicate entry \"%s\" in sam header",
  225|      0|                                name);
  226|      0|                return -1;
  227|      0|            }
  228|       |
  229|       |            // Clash with an already-seen altname
  230|       |            // As SN: should be preferred to AN: add this as a new
  231|       |            // record and update the hash entry to point to it.
  232|      0|            hts_log_warning("Ref name SN:\"%s\" is a duplicate of an existing AN key", name);
  233|      0|            nref = hrecs->nref;
  234|      0|        }
  235|       |
  236|      0|        if (nref == hrecs->ref_sz) {
  237|      0|            size_t new_sz = hrecs->ref_sz >= 4 ? hrecs->ref_sz + (hrecs->ref_sz / 4) : 32;
  238|      0|            sam_hrec_sq_t *new_ref = realloc(hrecs->ref, sizeof(*hrecs->ref) * new_sz);
  239|      0|            if (!new_ref)
  240|      0|                return -1;
  241|      0|            hrecs->ref = new_ref;
  242|      0|            hrecs->ref_sz = new_sz;
  243|      0|        }
  244|       |
  245|      0|        hrecs->ref[nref].name = name;
  246|      0|        hrecs->ref[nref].len  = len;
  247|      0|        hrecs->ref[nref].ty = h_type;
  248|       |
  249|      0|        k = kh_put(m_s2i, hrecs->ref_hash, hrecs->ref[nref].name, &r);
  250|      0|        if (-1 == r) return -1;
  251|      0|        kh_val(hrecs->ref_hash, k) = nref;
  252|       |
  253|      0|        if (sam_hrecs_add_ref_altnames(hrecs, nref, altnames) < 0)
  254|      0|            return -1;
  255|       |
  256|      0|        if (hrecs->refs_changed < 0 || hrecs->refs_changed > hrecs->nref)
  257|      0|            hrecs->refs_changed = hrecs->nref;
  258|      0|        hrecs->nref++;
  259|      0|    }
  260|       |
  261|       |    /* Add to read-group hash? */
  262|     44|    if (type == TYPEKEY("RG")) {
  263|      2|        sam_hrec_tag_t *tag = sam_hrecs_find_key(h_type, "ID", NULL);
  264|      2|        int nrg = hrecs->nrg, r;
  265|      2|        khint_t k;
  266|       |
  267|      2|        if (!tag) {
  268|      2|            hts_log_error("Header includes @RG line with no ID: tag");
  269|      2|            return -1;  // ID should be present, according to spec.
  270|      2|        }
  271|      0|        assert(tag->str && tag->len >= 3);
  272|       |
  273|       |        // Seen already?
  274|      0|        k = kh_get(m_s2i, hrecs->rg_hash, tag->str + 3);
  275|      0|        if (k < kh_end(hrecs->rg_hash)) {
  276|      0|            nrg = kh_val(hrecs->rg_hash, k);
  277|      0|            assert(hrecs->rg[nrg].ty != NULL);
  278|      0|            if (hrecs->rg[nrg].ty != h_type) {
  279|      0|                hts_log_warning("Duplicate entry \"%s\" in sam header",
  280|      0|                                tag->str + 3);
  281|      0|            } else {
  282|      0|                hrecs->rg[nrg].name = tag->str + 3;
  283|      0|                hrecs->rg[nrg].name_len = tag->len - 3;
  284|      0|            }
  285|      0|            return 0;
  286|      0|        }
  287|       |
  288|      0|        if (nrg == hrecs->rg_sz) {
  289|      0|            size_t new_sz = hrecs->rg_sz >= 4 ? hrecs->rg_sz + hrecs->rg_sz / 4 : 4;
  290|      0|            sam_hrec_rg_t *new_rg = realloc(hrecs->rg, sizeof(*hrecs->rg) * new_sz);
  291|      0|            if (!new_rg)
  292|      0|                return -1;
  293|      0|            hrecs->rg = new_rg;
  294|      0|            hrecs->rg_sz = new_sz;
  295|      0|        }
  296|       |
  297|      0|        hrecs->rg[nrg].name = tag->str + 3;
  298|      0|        hrecs->rg[nrg].name_len = tag->len - 3;
  299|      0|        hrecs->rg[nrg].ty   = h_type;
  300|      0|        hrecs->rg[nrg].id   = nrg;
  301|       |
  302|      0|        k = kh_put(m_s2i, hrecs->rg_hash, hrecs->rg[nrg].name, &r);
  303|      0|        if (-1 == r) return -1;
  304|      0|        kh_val(hrecs->rg_hash, k) = nrg;
  305|       |
  306|      0|        hrecs->nrg++;
  307|      0|    }
  308|       |
  309|       |    /* Add to program hash? */
  310|     42|    if (type == TYPEKEY("PG")) {
  311|      1|        sam_hrec_tag_t *tag;
  312|      1|        sam_hrec_pg_t *new_pg;
  313|      1|        int npg = hrecs->npg;
  314|       |
  315|      1|        if (npg == hrecs->pg_sz) {
  316|      1|            size_t new_sz = hrecs->pg_sz >= 4 ? hrecs->pg_sz + hrecs->pg_sz / 4 : 4;
  317|      1|            new_pg = realloc(hrecs->pg, sizeof(*hrecs->pg) * new_sz);
  318|      1|            if (!new_pg)
  319|      0|                return -1;
  320|      1|            hrecs->pg = new_pg;
  321|      1|            hrecs->pg_sz = new_sz;
  322|      1|        }
  323|       |
  324|      1|        tag = h_type->tag;
  325|      1|        hrecs->pg[npg].name = NULL;
  326|      1|        hrecs->pg[npg].name_len = 0;
  327|      1|        hrecs->pg[npg].ty  = h_type;
  328|      1|        hrecs->pg[npg].id   = npg;
  329|      1|        hrecs->pg[npg].prev_id = -1;
  330|       |
  331|      2|        while (tag) {
  332|      1|            if (tag->str[0] == 'I' && tag->str[1] == 'D') {
  333|       |                /* Avoid duplicate ID tags coming from other applications */
  334|      0|                if (!hrecs->pg[npg].name) {
  335|      0|                    assert(tag->len >= 3);
  336|      0|                    hrecs->pg[npg].name = tag->str + 3;
  337|      0|                    hrecs->pg[npg].name_len = tag->len - 3;
  338|      0|                } else {
  339|      0|                    hts_log_warning("PG line with multiple ID tags. The first encountered was preferred - ID:%s", hrecs->pg[npg].name);
  340|      0|                }
  341|      1|            } else if (tag->str[0] == 'P' && tag->str[1] == 'P') {
  342|       |                // Resolve later if needed
  343|      0|                khint_t k;
  344|      0|                k = kh_get(m_s2i, hrecs->pg_hash, tag->str+3);
  345|       |
  346|      0|                if (k != kh_end(hrecs->pg_hash)) {
  347|      0|                    int p_id = kh_val(hrecs->pg_hash, k);
  348|      0|                    hrecs->pg[npg].prev_id = hrecs->pg[p_id].id;
  349|       |
  350|       |                    /* Unmark previous entry as a PG termination */
  351|      0|                    if (hrecs->npg_end > 0 &&
  352|      0|                        hrecs->pg_end[hrecs->npg_end-1] == p_id) {
  353|      0|                        hrecs->npg_end--;
  354|      0|                    } else {
  355|      0|                        int i;
  356|      0|                        for (i = 0; i < hrecs->npg_end; i++) {
  357|      0|                            if (hrecs->pg_end[i] == p_id) {
  358|      0|                                memmove(&hrecs->pg_end[i], &hrecs->pg_end[i+1],
  359|      0|                                        (hrecs->npg_end-i-1)*sizeof(*hrecs->pg_end));
  360|      0|                                hrecs->npg_end--;
  361|      0|                            }
  362|      0|                        }
  363|      0|                    }
  364|      0|                } else {
  365|      0|                    hrecs->pg[npg].prev_id = -1;
  366|      0|                }
  367|      0|            }
  368|      1|            tag = tag->next;
  369|      1|        }
  370|       |
  371|      1|        if (hrecs->pg[npg].name) {
  372|      0|            khint_t k;
  373|      0|            int r;
  374|      0|            k = kh_put(m_s2i, hrecs->pg_hash, hrecs->pg[npg].name, &r);
  375|      0|            if (-1 == r) return -1;
  376|      0|            kh_val(hrecs->pg_hash, k) = npg;
  377|      1|        } else {
  378|      1|            return -1; // ID should be present, according to spec.
  379|      1|        }
  380|       |
  381|       |        /* Add to npg_end[] array. Remove later if we find a PP line */
  382|      0|        if (hrecs->npg_end >= hrecs->npg_end_alloc) {
  383|      0|            int *new_pg_end;
  384|      0|            int  new_alloc = hrecs->npg_end_alloc ? hrecs->npg_end_alloc*2 : 4;
  385|       |
  386|      0|            new_pg_end = realloc(hrecs->pg_end, new_alloc * sizeof(int));
  387|      0|            if (!new_pg_end)
  388|      0|                return -1;
  389|      0|            hrecs->npg_end_alloc = new_alloc;
  390|      0|            hrecs->pg_end = new_pg_end;
  391|      0|        }
  392|      0|        hrecs->pg_end[hrecs->npg_end++] = npg;
  393|       |
  394|      0|        hrecs->npg++;
  395|      0|    }
  396|       |
  397|     41|    return 0;
  398|     42|}
header.c:sam_hrecs_rebuild_lines:
  745|     21|static int sam_hrecs_rebuild_lines(const sam_hrecs_t *hrecs, kstring_t *ks) {
  746|     21|    const sam_hrec_type_t *t1, *t2;
  747|       |
  748|     21|    if (!hrecs->first_line)
  749|      0|        return kputsn("", 0, ks) >= 0 ? 0 : -1;
  750|       |
  751|     21|    t1 = t2 = hrecs->first_line;
  752|     24|    do {
  753|     24|        if (build_header_line(t1, ks) != 0)
  754|      0|            return -1;
  755|     24|        if (kputc('\n', ks) < 0)
  756|      0|            return -1;
  757|       |
  758|     24|        t1 = t1->global_next;
  759|     24|    } while (t1 != t2);
  760|       |
  761|     21|    return 0;
  762|     21|}
header.c:sam_hrecs_init_type_order:
   66|    391|static int sam_hrecs_init_type_order(sam_hrecs_t *hrecs, char *type_list) {
   67|    391|    if (!hrecs)
   68|      0|        return -1;
   69|       |
   70|    391|    if (!type_list) {
   71|    391|        hrecs->type_count = 5;
   72|    391|        hrecs->type_order = calloc(hrecs->type_count, 3);
   73|    391|        if (!hrecs->type_order)
   74|      0|            return -1;
   75|    391|        memcpy(hrecs->type_order[0], "HD", 2);
   76|    391|        memcpy(hrecs->type_order[1], "SQ", 2);
   77|    391|        memcpy(hrecs->type_order[2], "RG", 2);
   78|    391|        memcpy(hrecs->type_order[3], "PG", 2);
   79|    391|        memcpy(hrecs->type_order[4], "CO", 2);
   80|    391|    }
   81|       |
   82|    391|    return 0;
   83|    391|}

header.c:TYPEKEY:
   57|    550|static inline khint32_t TYPEKEY(const char *type) {
   58|    550|    unsigned int u0 = (unsigned char) type[0];
   59|    550|    unsigned int u1 = (unsigned char) type[1];
   60|    550|    return (u0 << 8) | u1;
   61|    550|}

hfile_init:
  106|    367|{
  107|    367|    hFILE *fp = (hFILE *) malloc(struct_size);
  108|    367|    if (fp == NULL) goto error;
  109|       |
  110|    367|    if (capacity == 0) capacity = 32768;
  111|       |    // FIXME For now, clamp input buffer sizes so mpileup doesn't eat memory
  112|    367|    if (strchr(mode, 'r') && capacity > 32768) capacity = 32768;
  113|       |
  114|    367|    fp->buffer = (char *) malloc(capacity);
  115|    367|    if (fp->buffer == NULL) goto error;
  116|       |
  117|    367|    fp->begin = fp->end = fp->buffer;
  118|    367|    fp->limit = &fp->buffer[capacity];
  119|       |
  120|    367|    fp->offset = 0;
  121|    367|    fp->at_eof = 0;
  122|    367|    fp->mobile = 1;
  123|    367|    fp->readonly = (strchr(mode, 'r') && ! strchr(mode, '+'));
  124|    367|    fp->has_errno = 0;
  125|    367|    return fp;
  126|       |
  127|      0|error:
  128|      0|    hfile_destroy(fp);
  129|      0|    return NULL;
  130|    367|}
hfile_init_fixed:
  134|    578|{
  135|    578|    hFILE *fp = (hFILE *) malloc(struct_size);
  136|    578|    if (fp == NULL) return NULL;
  137|       |
  138|    578|    fp->buffer = fp->begin = buffer;
  139|    578|    fp->end = &fp->buffer[buf_filled];
  140|    578|    fp->limit = &fp->buffer[buf_size];
  141|       |
  142|    578|    fp->offset = 0;
  143|    578|    fp->at_eof = 1;
  144|    578|    fp->mobile = 0;
  145|    578|    fp->readonly = (strchr(mode, 'r') && ! strchr(mode, '+'));
  146|    578|    fp->has_errno = 0;
  147|    578|    return fp;
  148|    578|}
hfile_destroy:
  154|    945|{
  155|    945|    int save = errno;
  156|    945|    if (fp) free(fp->buffer);
  157|    945|    free(fp);
  158|    945|    errno = save;
  159|    945|}
hgetc2:
  227|     75|{
  228|      0|    return (refill_buffer(fp) > 0)? (unsigned char) *(fp->begin++) : EOF;
  229|     75|}
hgetdelim:
  232|  2.27k|{
  233|  2.27k|    char *found;
  234|  2.27k|    size_t n, copied = 0;
  235|  2.27k|    ssize_t got;
  236|       |
  237|  2.27k|    if (size < 1 || size > SSIZE_MAX) {
  238|      0|        fp->has_errno = errno = EINVAL;
  239|      0|        return -1;
  240|      0|    }
  241|  2.27k|    if (writebuffer_is_nonempty(fp)) {
  242|      0|        fp->has_errno = errno = EBADF;
  243|      0|        return -1;
  244|      0|    }
  245|       |
  246|  2.27k|    --size; /* to allow space for the NUL terminator */
  247|       |
  248|  2.27k|    do {
  249|  2.27k|        n = fp->end - fp->begin;
  250|  2.27k|        if (n > size - copied) n = size - copied;
  251|       |
  252|       |        /* Look in the hFILE buffer for the delimiter */
  253|  2.27k|        found = memchr(fp->begin, delim, n);
  254|  2.27k|        if (found != NULL) {
  255|  1.69k|            n = found - fp->begin + 1;
  256|  1.69k|            memcpy(buffer + copied, fp->begin, n);
  257|  1.69k|            buffer[n + copied] = '\0';
  258|  1.69k|            fp->begin += n;
  259|  1.69k|            return n + copied;
  260|  1.69k|        }
  261|       |
  262|       |        /* No delimiter yet, copy as much as we can and refill if necessary */
  263|    580|        memcpy(buffer + copied, fp->begin, n);
  264|    580|        fp->begin += n;
  265|    580|        copied += n;
  266|       |
  267|    580|        if (copied == size) { /* Output buffer full */
  268|      0|            buffer[copied] = '\0';
  269|      0|            return copied;
  270|      0|        }
  271|       |
  272|    580|        got = refill_buffer(fp);
  273|    580|    } while (got > 0);
  274|       |
  275|    580|    if (got < 0) return -1; /* Error on refill. */
  276|       |
  277|    580|    buffer[copied] = '\0';  /* EOF, return anything that was copied. */
  278|    580|    return copied;
  279|    580|}
hpeek:
  291|  1.34k|{
  292|  1.34k|    size_t n = fp->end - fp->begin;
  293|  1.34k|    while (n < nbytes) {
  294|    965|        ssize_t ret = refill_buffer(fp);
  295|    965|        if (ret < 0) return ret;
  296|    965|        else if (ret == 0) break;
  297|      0|        else n += ret;
  298|    965|    }
  299|       |
  300|  1.34k|    if (n > nbytes) n = nbytes;
  301|  1.34k|    memcpy(buffer, fp->begin, n);
  302|  1.34k|    return n;
  303|  1.34k|}
hflush:
  368|    414|{
  369|    414|    if (flush_buffer(fp) < 0) return EOF;
  370|    414|    if (fp->backend->flush) {
  371|    414|        if (fp->backend->flush(fp) < 0) { fp->has_errno = errno; return EOF; }
  372|    414|    }
  373|    414|    return 0;
  374|    414|}
hseek:
  424|     33|{
  425|     33|    off_t curpos, pos;
  426|       |
  427|     33|    if (writebuffer_is_nonempty(fp) && fp->mobile) {
  428|      0|        int ret = flush_buffer(fp);
  429|      0|        if (ret < 0) return ret;
  430|     33|    }
  431|       |
  432|     33|    curpos = htell(fp);
  433|       |
  434|       |    // Relative offsets are given relative to the hFILE's stream position,
  435|       |    // which may differ from the backend's physical position due to buffering
  436|       |    // read-ahead.  Correct for this by converting to an absolute position.
  437|     33|    if (whence == SEEK_CUR) {
  438|      0|        if (curpos + offset < 0) {
  439|       |            // Either a negative offset resulted in a position before the
  440|       |            // start of the file, or we overflowed when given a positive offset
  441|      0|            fp->has_errno = errno = (offset < 0)? EINVAL : EOVERFLOW;
  442|      0|            return -1;
  443|      0|        }
  444|       |
  445|      0|        whence = SEEK_SET;
  446|      0|        offset = curpos + offset;
  447|      0|    }
  448|       |    // For fixed immobile buffers, convert everything else to SEEK_SET too
  449|       |    // so that seeking can be avoided for all (within range) requests.
  450|     33|    else if (! fp->mobile && whence == SEEK_END) {
  451|     22|        size_t length = fp->end - fp->buffer;
  452|     22|        if (offset > 0 || -offset > length) {
  453|     11|            fp->has_errno = errno = EINVAL;
  454|     11|            return -1;
  455|     11|        }
  456|       |
  457|     11|        whence = SEEK_SET;
  458|     11|        offset = length + offset;
  459|     11|    }
  460|       |
  461|       |    // Avoid seeking if the desired position is within our read buffer.
  462|       |    // (But not when the next operation may be a write on a mobile buffer.)
  463|     22|    if (whence == SEEK_SET && (! fp->mobile || fp->readonly) &&
  464|     22|        offset >= fp->offset && offset - fp->offset <= fp->end - fp->buffer) {
  465|     22|        fp->begin = &fp->buffer[offset - fp->offset];
  466|     22|        return offset;
  467|     22|    }
  468|       |
  469|      0|    pos = fp->backend->seek(fp, offset, whence);
  470|      0|    if (pos < 0) { fp->has_errno = errno; return pos; }
  471|       |
  472|       |    // Seeking succeeded, so discard any non-empty read buffer
  473|      0|    fp->begin = fp->end = fp->buffer;
  474|      0|    fp->at_eof = 0;
  475|       |
  476|      0|    fp->offset = pos;
  477|      0|    return pos;
  478|      0|}
hclose:
  481|    945|{
  482|    945|    int err = fp->has_errno;
  483|       |
  484|    945|    if (writebuffer_is_nonempty(fp) && hflush(fp) < 0) err = fp->has_errno;
  485|    945|    if (fp->backend->close(fp) < 0) err = errno;
  486|    945|    hfile_destroy(fp);
  487|       |
  488|    945|    if (err) {
  489|      0|        errno = err;
  490|      0|        return EOF;
  491|      0|    }
  492|    945|    else return 0;
  493|    945|}
hfile_oflags:
  724|    367|{
  725|    367|    int rdwr = 0, flags = 0;
  726|    367|    const char *s;
  727|    734|    for (s = mode; *s; s++)
  728|    367|        switch (*s) {
  729|      0|        case 'r': rdwr = O_RDONLY;  break;
  730|    367|        case 'w': rdwr = O_WRONLY; flags |= O_CREAT | O_TRUNC;  break;
  731|      0|        case 'a': rdwr = O_WRONLY; flags |= O_CREAT | O_APPEND;  break;
  732|      0|        case '+': rdwr = O_RDWR;  break;
  733|      0|#ifdef O_CLOEXEC
  734|      0|        case 'e': flags |= O_CLOEXEC;  break;
  735|      0|#endif
  736|      0|#ifdef O_EXCL
  737|      0|        case 'x': flags |= O_EXCL;  break;
  738|      0|#endif
  739|      0|        default:  break;
  740|    367|        }
  741|       |
  742|       |#ifdef O_BINARY
  743|       |    flags |= O_BINARY;
  744|       |#endif
  745|       |
  746|    367|    return rdwr | flags;
  747|    367|}
hfile_plugin_init_mem:
  864|      1|{
  865|       |    // mem files are declared remote so they work with a tabix index
  866|      1|    static const struct hFILE_scheme_handler handler =
  867|      1|            {NULL, hfile_always_remote, "mem", 2000 + 50, hopenv_mem};
  868|      1|    self->name = "mem";
  869|      1|    hfile_add_scheme_handler("mem", &handler);
  870|      1|    return 0;
  871|      1|}
hfile_plugin_init_crypt4gh_needed:
  900|      1|{
  901|      1|    static const struct hFILE_scheme_handler handler =
  902|      1|        { crypt4gh_needed, NULL, "crypt4gh-needed", 0, NULL };
  903|      1|    self->name = "crypt4gh-needed";
  904|      1|    hfile_add_scheme_handler("crypt4gh", &handler);
  905|      1|    return 0;
  906|      1|}
hfile_shutdown:
  927|      1|{
  928|      1|    pthread_mutex_lock(&plugins_lock);
  929|       |
  930|      1|    if (schemes) {
  931|      1|        kh_destroy(scheme_string, schemes);
  932|      1|        schemes = NULL;
  933|      1|    }
  934|       |
  935|      7|    while (plugins != NULL) {
  936|      6|        struct hFILE_plugin_list *p = plugins;
  937|      6|        if (p->plugin.destroy) p->plugin.destroy();
  938|       |#ifdef ENABLE_PLUGINS
  939|       |        if (p->plugin.obj && do_close_plugin) close_plugin(p->plugin.obj);
  940|       |#endif
  941|      6|        plugins = p->next;
  942|      6|        free(p);
  943|      6|    }
  944|       |
  945|      1|    pthread_mutex_unlock(&plugins_lock);
  946|      1|}
hfile_add_scheme_handler:
  999|     37|{
 1000|     37|    int absent;
 1001|     37|    if (!schemes) {
 1002|      0|        if (try_exe_add_scheme_handler(scheme, handler) != 0) {
 1003|      0|            hts_log_warning("Couldn't register scheme handler for %s", scheme);
 1004|      0|        }
 1005|      0|        return;
 1006|      0|    }
 1007|     37|    khint_t k = kh_put(scheme_string, schemes, scheme, &absent);
 1008|     37|    if (absent < 0) {
 1009|      0|        hts_log_warning("Couldn't register scheme handler for %s : %s",
 1010|      0|                        scheme, strerror(errno));
 1011|      0|        return;
 1012|      0|    }
 1013|     37|    if (absent || priority(handler) > priority(kh_value(schemes, k))) {
 1014|     36|        kh_value(schemes, k) = handler;
 1015|     36|    }
 1016|     37|}
hopen:
 1258|    946|{
 1259|    946|    const struct hFILE_scheme_handler *handler = find_scheme_handler(fname);
 1260|    946|    if (handler) {
 1261|    579|        if (strchr(mode, ':') == NULL
 1262|    578|            || handler->priority < 2000
 1263|    578|            || handler->vopen == NULL) {
 1264|      1|            return handler->open(fname, mode);
 1265|      1|        }
 1266|    578|        else {
 1267|    578|            hFILE *fp;
 1268|    578|            va_list arg;
 1269|    578|            va_start(arg, mode);
 1270|    578|            fp = handler->vopen(fname, mode, arg);
 1271|    578|            va_end(arg);
 1272|    578|            return fp;
 1273|    578|        }
 1274|    367|    }
 1275|    367|    else if (strcmp(fname, "-") == 0) return hopen_fd_stdinout(mode);
 1276|    367|    else return hopen_fd(fname, mode);
 1277|    946|}
hfile.c:refill_buffer:
  170|  1.62k|{
  171|  1.62k|    ssize_t n;
  172|       |
  173|       |    // Move any unread characters to the start of the buffer
  174|  1.62k|    if (fp->mobile && fp->begin > fp->buffer) {
  175|      0|        fp->offset += fp->begin - fp->buffer;
  176|      0|        memmove(fp->buffer, fp->begin, fp->end - fp->begin);
  177|      0|        fp->end = &fp->buffer[fp->end - fp->begin];
  178|      0|        fp->begin = fp->buffer;
  179|      0|    }
  180|       |
  181|       |    // Read into the available buffer space at fp->[end,limit)
  182|  1.62k|    if (fp->at_eof || fp->end == fp->limit) n = 0;
  183|      0|    else {
  184|      0|        n = fp->backend->read(fp, fp->end, fp->limit - fp->end);
  185|      0|        if (n < 0) { fp->has_errno = errno; return n; }
  186|      0|        else if (n == 0) fp->at_eof = 1;
  187|      0|    }
  188|       |
  189|  1.62k|    fp->end += n;
  190|  1.62k|    return n;
  191|  1.62k|}
hfile.c:writebuffer_is_nonempty:
  162|  3.24k|{
  163|  3.24k|    return fp->begin > fp->end;
  164|  3.24k|}
hfile.c:flush_buffer:
  354|    414|{
  355|    414|    const char *buffer = fp->buffer;
  356|    627|    while (buffer < fp->begin) {
  357|    213|        ssize_t n = fp->backend->write(fp, buffer, fp->begin - buffer);
  358|    213|        if (n < 0) { fp->has_errno = errno; return n; }
  359|    213|        buffer += n;
  360|    213|        fp->offset += n;
  361|    213|    }
  362|       |
  363|    414|    fp->begin = fp->buffer;  // Leave the buffer empty
  364|    414|    return 0;
  365|    414|}
hfile.c:blksize:
  608|    367|{
  609|    367|#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE
  610|    367|    struct stat sbuf;
  611|    367|    if (fstat(fd, &sbuf) != 0) return 0;
  612|    367|    return sbuf.st_blksize;
  613|       |#else
  614|       |    return 0;
  615|       |#endif
  616|    367|}
hfile.c:fd_write:
  542|    213|{
  543|    213|    hFILE_fd *fp = (hFILE_fd *) fpv;
  544|    213|    ssize_t n;
  545|    213|    do {
  546|      0|        n = fp->is_socket?  send(fp->fd, buffer, nbytes, 0)
  547|    213|                         : write(fp->fd, buffer, nbytes);
  548|    213|    } while (n < 0 && errno == EINTR);
  549|       |#ifdef _WIN32
  550|       |        // On windows we have no SIGPIPE.  Instead write returns
  551|       |        // EINVAL.  We check for this and our fd being a pipe.
  552|       |        // If so, we raise SIGTERM instead of SIGPIPE.  It's not
  553|       |        // ideal, but I think the only alternative is extra checking
  554|       |        // in every single piece of code.
  555|       |        if (n < 0 && errno == EINVAL &&
  556|       |            GetLastError() == ERROR_NO_DATA &&
  557|       |            GetFileType((HANDLE)_get_osfhandle(fp->fd)) == FILE_TYPE_PIPE) {
  558|       |            raise(SIGTERM);
  559|       |        }
  560|       |#endif
  561|    213|    return n;
  562|    213|}
hfile.c:fd_flush:
  571|    414|{
  572|    414|    int ret = 0;
  573|    414|    do {
  574|    414|#ifdef HAVE_FDATASYNC
  575|    414|        hFILE_fd *fp = (hFILE_fd *) fpv;
  576|    414|        ret = fdatasync(fp->fd);
  577|       |#elif defined(HAVE_FSYNC)
  578|       |        hFILE_fd *fp = (hFILE_fd *) fpv;
  579|       |        ret = fsync(fp->fd);
  580|       |#endif
  581|       |        // Ignore invalid-for-fsync(2) errors due to being, e.g., a pipe,
  582|       |        // and operation-not-supported errors (Mac OS X)
  583|    414|        if (ret < 0 && (errno == EINVAL || errno == ENOTSUP)) ret = 0;
  584|    414|    } while (ret < 0 && errno == EINTR);
  585|    414|    return ret;
  586|    414|}
hfile.c:fd_close:
  589|    367|{
  590|    367|    hFILE_fd *fp = (hFILE_fd *) fpv;
  591|    367|    int ret;
  592|    367|    do {
  593|       |#ifdef HAVE_CLOSESOCKET
  594|       |        ret = fp->is_socket? closesocket(fp->fd) : close(fp->fd);
  595|       |#else
  596|    367|        ret = close(fp->fd);
  597|    367|#endif
  598|    367|    } while (ret < 0 && errno == EINTR);
  599|    367|    return ret;
  600|    367|}
hfile.c:mem_close:
  767|    578|{
  768|    578|    return 0;
  769|    578|}
hfile.c:hopenv_mem:
  829|    578|{
  830|    578|    char* buffer = va_arg(args, char*);
  831|    578|    size_t sz = va_arg(args, size_t);
  832|    578|    va_end(args);
  833|       |
  834|    578|    hFILE* hf;
  835|       |
  836|    578|    if(!(hf = create_hfile_mem(buffer, mode, sz, sz))){
  837|      0|        free(buffer);
  838|      0|        return NULL;
  839|      0|    }
  840|       |
  841|    578|    return hf;
  842|    578|}
hfile.c:create_hfile_mem:
  786|    578|{
  787|    578|    hFILE_mem *fp = (hFILE_mem *) hfile_init_fixed(sizeof(hFILE_mem), mode, buffer, buf_filled, buf_size);
  788|    578|    if (fp == NULL)
  789|      0|        return NULL;
  790|       |
  791|    578|    fp->base.backend = &mem_backend;
  792|    578|    return &fp->base;
  793|    578|}
hfile.c:crypt4gh_needed:
  879|      1|{
  880|      1|    const char *u = strncmp(url, "crypt4gh:", 9) == 0 ? url + 9 : url;
  881|       |#if defined(ENABLE_PLUGINS)
  882|       |    const char *enable_plugins = "";
  883|       |#else
  884|      1|    const char *enable_plugins = "You also need to rebuild HTSlib with plug-ins enabled.\n";
  885|      1|#endif
  886|       |
  887|      1|    hts_log_error("Accessing \"%s\" needs the crypt4gh plug-in.\n"
  888|      1|                  "It can be found at "
  889|      1|                  "https://github.com/samtools/htslib-crypt4gh\n"
  890|      1|                  "%s"
  891|      1|                  "If you have the plug-in, please ensure it can be "
  892|      1|                  "found on your HTS_PATH.",
  893|      1|                  u, enable_plugins);
  894|       |
  895|      1|    errno = EPROTONOSUPPORT;
  896|      1|    return NULL;
  897|      1|}
hfile.c:priority:
  955|      2|{
  956|      2|    return handler->priority % 1000;
  957|      2|}
hfile.c:load_hfile_plugins:
 1051|      1|{
 1052|      1|    static const struct hFILE_scheme_handler
 1053|      1|        data = { hopen_mem, hfile_always_local, "built-in", 80 },
 1054|      1|        file = { hopen_fd_fileuri, hfile_always_local, "built-in", 80 },
 1055|      1|        preload = { hopen_preload, is_preload_url_remote, "built-in", 80 };
 1056|       |
 1057|      1|    schemes = kh_init(scheme_string);
 1058|      1|    if (schemes == NULL)
 1059|      0|        return -1;
 1060|       |
 1061|      1|    hfile_add_scheme_handler("data", &data);
 1062|      1|    hfile_add_scheme_handler("file", &file);
 1063|      1|    hfile_add_scheme_handler("preload", &preload);
 1064|      1|    init_add_plugin(NULL, hfile_plugin_init_mem, "mem");
 1065|      1|    init_add_plugin(NULL, hfile_plugin_init_crypt4gh_needed, "crypt4gh-needed");
 1066|       |
 1067|       |#ifdef ENABLE_PLUGINS
 1068|       |    struct hts_path_itr path;
 1069|       |    const char *pluginname;
 1070|       |    hts_path_itr_setup(&path, NULL, NULL, "hfile_", 6, NULL, 0);
 1071|       |    while ((pluginname = hts_path_itr_next(&path)) != NULL) {
 1072|       |        void *obj;
 1073|       |        int (*init)(struct hFILE_plugin *) = (int (*)(struct hFILE_plugin *))
 1074|       |            load_plugin(&obj, pluginname, "hfile_plugin_init");
 1075|       |
 1076|       |        if (init) {
 1077|       |            if (init_add_plugin(obj, init, pluginname) != 0)
 1078|       |                close_plugin(obj);
 1079|       |        }
 1080|       |    }
 1081|       |#else
 1082|       |
 1083|      1|#ifdef HAVE_LIBCURL
 1084|      1|    init_add_plugin(NULL, hfile_plugin_init_libcurl, "libcurl");
 1085|      1|#endif
 1086|      1|#ifdef ENABLE_GCS
 1087|      1|    init_add_plugin(NULL, hfile_plugin_init_gcs, "gcs");
 1088|      1|#endif
 1089|      1|#ifdef ENABLE_S3
 1090|      1|    init_add_plugin(NULL, hfile_plugin_init_s3, "s3");
 1091|      1|    init_add_plugin(NULL, hfile_plugin_init_s3_write, "s3w");
 1092|      1|#endif
 1093|       |
 1094|      1|#endif
 1095|       |
 1096|       |    // In the unlikely event atexit() fails, it's better to succeed here and
 1097|       |    // carry on; then eventually when the program exits, we'll merely close
 1098|       |    // down the plugins uncleanly, as if we had aborted.
 1099|      1|    (void) atexit(hfile_exit);
 1100|       |
 1101|      1|    return 0;
 1102|      1|}
hfile.c:init_add_plugin:
 1020|      6|{
 1021|      6|    struct hFILE_plugin_list *p = malloc (sizeof (struct hFILE_plugin_list));
 1022|      6|    if (p == NULL) {
 1023|      0|        hts_log_debug("Failed to allocate memory for plugin \"%s\"", pluginname);
 1024|      0|        return -1;
 1025|      0|    }
 1026|       |
 1027|      6|    p->plugin.api_version = 1;
 1028|      6|    p->plugin.obj = obj;
 1029|      6|    p->plugin.name = NULL;
 1030|      6|    p->plugin.destroy = NULL;
 1031|       |
 1032|      6|    int ret = (*init)(&p->plugin);
 1033|       |
 1034|      6|    if (ret != 0) {
 1035|      0|        hts_log_debug("Initialisation failed for plugin \"%s\": %d", pluginname, ret);
 1036|      0|        free(p);
 1037|      0|        return ret;
 1038|      0|    }
 1039|       |
 1040|      6|    hts_log_debug("Loaded \"%s\"", pluginname);
 1041|       |
 1042|      6|    p->next = plugins, plugins = p;
 1043|      6|    return 0;
 1044|      6|}
hfile.c:hfile_exit:
  949|      1|{
  950|      1|    hfile_shutdown(0);
  951|      1|    pthread_mutex_destroy(&plugins_lock);
  952|      1|}
hfile.c:find_scheme_handler:
 1117|    946|{
 1118|    946|    static const struct hFILE_scheme_handler unknown_scheme =
 1119|    946|        { hopen_unknown_scheme, hfile_always_local, "built-in", 0 };
 1120|       |
 1121|    946|    char scheme[12];
 1122|    946|    int i;
 1123|       |
 1124|  2.68k|    for (i = 0; i < sizeof scheme; i++)
 1125|  2.68k|        if (isalnum_c(s[i]) || s[i] == '+' || s[i] == '-' || s[i] == '.')
 1126|  1.74k|            scheme[i] = tolower_c(s[i]);
 1127|    946|        else if (s[i] == ':') break;
 1128|    367|        else return NULL;
 1129|       |
 1130|       |    // 1 byte schemes are likely windows C:/foo pathnames
 1131|    579|    if (i <= 1 || i >= sizeof scheme) return NULL;
 1132|    579|    scheme[i] = '\0';
 1133|       |
 1134|    579|    pthread_mutex_lock(&plugins_lock);
 1135|    579|    if (!schemes && load_hfile_plugins() < 0) {
 1136|      0|        pthread_mutex_unlock(&plugins_lock);
 1137|      0|        return NULL;
 1138|      0|    }
 1139|    579|    pthread_mutex_unlock(&plugins_lock);
 1140|       |
 1141|    579|    khint_t k = kh_get(scheme_string, schemes, scheme);
 1142|    579|    return (k != kh_end(schemes))? kh_value(schemes, k) : &unknown_scheme;
 1143|    579|}
hfile.c:hopen_fd:
  619|    367|{
  620|    367|    hFILE_fd *fp = NULL;
  621|    367|    int fd = open(filename, hfile_oflags(mode), 0666);
  622|    367|    if (fd < 0) goto error;
  623|       |
  624|    367|    fp = (hFILE_fd *) hfile_init(sizeof (hFILE_fd), mode, blksize(fd));
  625|    367|    if (fp == NULL) goto error;
  626|       |
  627|    367|    fp->fd = fd;
  628|    367|    fp->is_socket = 0;
  629|    367|    fp->base.backend = &fd_backend;
  630|    367|    return &fp->base;
  631|       |
  632|      0|error:
  633|      0|    if (fd >= 0) { int save = errno; (void) close(fd); errno = save; }
  634|      0|    hfile_destroy((hFILE *) fp);
  635|      0|    return NULL;
  636|    367|}

hfile_plugin_init_gcs:
  142|      1|{
  143|      1|    static const struct hFILE_scheme_handler handler =
  144|      1|        { gcs_open, hfile_always_remote, "Google Cloud Storage",
  145|      1|          2000 + 50, gcs_vopen
  146|      1|        };
  147|       |
  148|       |#ifdef ENABLE_PLUGINS
  149|       |    // Embed version string for examination via strings(1) or what(1)
  150|       |    static const char id[] = "@(#)hfile_gcs plugin (htslib)\t" HTS_VERSION_TEXT;
  151|       |    if (hts_verbose >= 9)
  152|       |        fprintf(stderr, "[M::hfile_gcs.init] version %s\n", strchr(id, '\t')+1);
  153|       |#endif
  154|       |
  155|      1|    self->name = "Google Cloud Storage";
  156|      1|    hfile_add_scheme_handler("gs", &handler);
  157|      1|    hfile_add_scheme_handler("gs+http", &handler);
  158|      1|    hfile_add_scheme_handler("gs+https", &handler);
  159|      1|    return 0;
  160|      1|}

hfile_plugin_init_libcurl:
 1494|      1|{
 1495|      1|    static const struct hFILE_scheme_handler handler =
 1496|      1|        { hopen_libcurl, hfile_always_remote, "libcurl",
 1497|      1|          2000 + 50,
 1498|      1|          vhopen_libcurl };
 1499|       |
 1500|       |#ifdef ENABLE_PLUGINS
 1501|       |    // Embed version string for examination via strings(1) or what(1)
 1502|       |    static const char id[] =
 1503|       |        "@(#)hfile_libcurl plugin (htslib)\t" HTS_VERSION_TEXT;
 1504|       |    const char *version = strchr(id, '\t')+1;
 1505|       |#else
 1506|      1|    const char *version = hts_version();
 1507|      1|#endif
 1508|      1|    const curl_version_info_data *info;
 1509|      1|    const char * const *protocol;
 1510|      1|    const char *auth;
 1511|      1|    CURLcode err;
 1512|      1|    CURLSHcode errsh;
 1513|       |
 1514|      1|    err = curl_global_init(CURL_GLOBAL_ALL);
 1515|      1|    if (err != CURLE_OK) { errno = easy_errno(NULL, err); return -1; }
 1516|       |
 1517|      1|    curl.share = curl_share_init();
 1518|      1|    if (curl.share == NULL) { curl_global_cleanup(); errno = EIO; return -1; }
 1519|      1|    errsh = curl_share_setopt(curl.share, CURLSHOPT_LOCKFUNC, share_lock);
 1520|      1|    errsh |= curl_share_setopt(curl.share, CURLSHOPT_UNLOCKFUNC, share_unlock);
 1521|      1|    errsh |= curl_share_setopt(curl.share, CURLSHOPT_SHARE, CURL_LOCK_DATA_DNS);
 1522|      1|    if (errsh != 0) {
 1523|      0|        curl_share_cleanup(curl.share);
 1524|      0|        curl_global_cleanup();
 1525|      0|        errno = EIO;
 1526|      0|        return -1;
 1527|      0|    }
 1528|       |
 1529|      1|    if ((auth = getenv("HTS_AUTH_LOCATION")) != NULL) {
 1530|      0|        curl.auth_path = strdup(auth);
 1531|      0|        curl.auth_map = kh_init(auth_map);
 1532|      0|        if (!curl.auth_path || !curl.auth_map) {
 1533|      0|            int save_errno = errno;
 1534|      0|            free(curl.auth_path);
 1535|      0|            kh_destroy(auth_map, curl.auth_map);
 1536|      0|            curl_share_cleanup(curl.share);
 1537|      0|            curl_global_cleanup();
 1538|      0|            errno = save_errno;
 1539|      0|            return -1;
 1540|      0|        }
 1541|      1|    }
 1542|      1|    if ((auth = getenv("HTS_ALLOW_UNENCRYPTED_AUTHORIZATION_HEADER")) != NULL
 1543|      0|        && strcmp(auth, "I understand the risks") == 0) {
 1544|      0|        curl.allow_unencrypted_auth_header = 1;
 1545|      0|    }
 1546|       |
 1547|      1|    info = curl_version_info(CURLVERSION_NOW);
 1548|      1|    ksprintf(&curl.useragent, "htslib/%s libcurl/%s", version, info->version);
 1549|       |
 1550|      1|    self->name = "libcurl";
 1551|      1|    self->destroy = libcurl_exit;
 1552|       |
 1553|     24|    for (protocol = info->protocols; *protocol; protocol++)
 1554|     23|        hfile_add_scheme_handler(*protocol, &handler);
 1555|      1|    return 0;
 1556|      1|}
hfile_libcurl.c:share_lock:
  264|      1|                       curl_lock_access access, void *userptr) {
  265|      1|    pthread_mutex_lock(&curl.share_lock);
  266|      1|}
hfile_libcurl.c:share_unlock:
  268|      1|static void share_unlock(CURL *handle, curl_lock_data data, void *userptr) {
  269|      1|    pthread_mutex_unlock(&curl.share_lock);
  270|      1|}
hfile_libcurl.c:libcurl_exit:
  281|      1|{
  282|      1|    if (curl_share_cleanup(curl.share) == CURLSHE_OK)
  283|      1|        curl.share = NULL;
  284|       |
  285|      1|    free(curl.useragent.s);
  286|      1|    curl.useragent.l = curl.useragent.m = 0; curl.useragent.s = NULL;
  287|       |
  288|      1|    free(curl.auth_path);
  289|      1|    curl.auth_path = NULL;
  290|       |
  291|      1|    if (curl.auth_map) {
  292|      0|        khiter_t i;
  293|      0|        for (i = kh_begin(curl.auth_map); i != kh_end(curl.auth_map); ++i) {
  294|      0|            if (kh_exist(curl.auth_map, i)) {
  295|      0|                free_auth(kh_value(curl.auth_map, i));
  296|      0|                kh_key(curl.auth_map, i) = NULL;
  297|      0|                kh_value(curl.auth_map, i) = NULL;
  298|      0|            }
  299|      0|        }
  300|      0|        kh_destroy(auth_map, curl.auth_map);
  301|      0|        curl.auth_map = NULL;
  302|      0|    }
  303|       |
  304|      1|    curl_global_cleanup();
  305|      1|}

hfile_plugin_init_s3:
 1293|      1|{
 1294|      1|    static const struct hFILE_scheme_handler handler =
 1295|      1|        { s3_open, hfile_always_remote, "Amazon S3", 2000 + 50, s3_vopen
 1296|      1|        };
 1297|       |
 1298|       |#ifdef ENABLE_PLUGINS
 1299|       |    // Embed version string for examination via strings(1) or what(1)
 1300|       |    static const char id[] = "@(#)hfile_s3 plugin (htslib)\t" HTS_VERSION_TEXT;
 1301|       |    if (hts_verbose >= 9)
 1302|       |        fprintf(stderr, "[M::hfile_s3.init] version %s\n", strchr(id, '\t')+1);
 1303|       |#endif
 1304|       |
 1305|      1|    self->name = "Amazon S3";
 1306|      1|    hfile_add_scheme_handler("s3", &handler);
 1307|      1|    hfile_add_scheme_handler("s3+http", &handler);
 1308|      1|    hfile_add_scheme_handler("s3+https", &handler);
 1309|      1|    return 0;
 1310|      1|}

hfile_plugin_init_s3_write:
  835|      1|int PLUGIN_GLOBAL(hfile_plugin_init,_s3_write)(struct hFILE_plugin *self) {
  836|       |
  837|      1|    static const struct hFILE_scheme_handler handler =
  838|      1|        { hopen_s3_write, hfile_always_remote, "S3 Multipart Upload",
  839|      1|          2000 + 50, vhopen_s3_write
  840|      1|        };
  841|       |
  842|       |#ifdef ENABLE_PLUGINS
  843|       |    // Embed version string for examination via strings(1) or what(1)
  844|       |    static const char id[] =
  845|       |        "@(#)hfile_s3_write plugin (htslib)\t" HTS_VERSION_TEXT;
  846|       |    const char *version = strchr(id, '\t') + 1;
  847|       |
  848|       |    if (hts_verbose >= 9)
  849|       |        fprintf(stderr, "[M::hfile_s3_write.init] version %s\n",
  850|       |                version);
  851|       |#else
  852|      1|    const char *version = hts_version();
  853|      1|#endif
  854|       |
  855|      1|    const curl_version_info_data *info;
  856|      1|    CURLcode err;
  857|      1|    CURLSHcode errsh;
  858|       |
  859|      1|    err = curl_global_init(CURL_GLOBAL_ALL);
  860|       |
  861|      1|    if (err != CURLE_OK) {
  862|       |        // look at putting in an errno here
  863|      0|        return -1;
  864|      0|    }
  865|       |
  866|      1|    curl.share = curl_share_init();
  867|       |
  868|      1|    if (curl.share == NULL) {
  869|      0|        curl_global_cleanup();
  870|      0|        errno = EIO;
  871|      0|        return -1;
  872|      0|    }
  873|       |
  874|      1|    errsh  = curl_share_setopt(curl.share, CURLSHOPT_LOCKFUNC, share_lock);
  875|      1|    errsh |= curl_share_setopt(curl.share, CURLSHOPT_UNLOCKFUNC, share_unlock);
  876|      1|    errsh |= curl_share_setopt(curl.share, CURLSHOPT_SHARE, CURL_LOCK_DATA_DNS);
  877|       |
  878|      1|    if (errsh != 0) {
  879|      0|        curl_share_cleanup(curl.share);
  880|      0|        curl_global_cleanup();
  881|      0|        errno = EIO;
  882|      0|        return -1;
  883|      0|    }
  884|       |
  885|      1|    info = curl_version_info(CURLVERSION_NOW);
  886|      1|    ksprintf(&curl.useragent, "htslib/%s libcurl/%s", version, info->version);
  887|       |
  888|      1|    self->name = "S3 Multipart Upload";
  889|      1|    self->destroy = s3_write_exit;
  890|       |
  891|      1|    hfile_add_scheme_handler("s3w",       &handler);
  892|      1|    hfile_add_scheme_handler("s3w+http",  &handler);
  893|      1|    hfile_add_scheme_handler("s3w+https", &handler);
  894|       |
  895|      1|    return 0;
  896|      1|}
hfile_s3_write.c:share_lock:
  103|      1|                       curl_lock_access access, void *userptr) {
  104|      1|    pthread_mutex_lock(&curl.share_lock);
  105|      1|}
hfile_s3_write.c:share_unlock:
  107|      1|static void share_unlock(CURL *handle, curl_lock_data data, void *userptr) {
  108|      1|    pthread_mutex_unlock(&curl.share_lock);
  109|      1|}
hfile_s3_write.c:s3_write_exit:
  825|      1|static void s3_write_exit() {
  826|      1|    if (curl_share_cleanup(curl.share) == CURLSHE_OK)
  827|      1|        curl.share = NULL;
  828|       |
  829|      1|    free(curl.useragent.s);
  830|      1|    curl.useragent.l = curl.useragent.m = 0; curl.useragent.s = NULL;
  831|      1|    curl_global_cleanup();
  832|      1|}

hts_version:
   85|      2|{
   86|      2|    return HTS_VERSION_TEXT;
   87|      2|}
hts_detect_format2:
  512|    578|{
  513|    578|    char extension[HTS_MAX_EXT_LEN], columns[24];
  514|    578|    unsigned char s[1024];
  515|    578|    int complete = 0;
  516|    578|    ssize_t len = hpeek(hfile, s, 18);
  517|    578|    if (len < 0) return -1;
  518|       |
  519|    578|    fmt->category = unknown_category;
  520|    578|    fmt->format = unknown_format;
  521|    578|    fmt->version.major = fmt->version.minor = -1;
  522|    578|    fmt->compression = no_compression;
  523|    578|    fmt->compression_level = -1;
  524|    578|    fmt->specific = NULL;
  525|       |
  526|    578|    if (len >= 2 && s[0] == 0x1f && s[1] == 0x8b) {
  527|       |        // The stream is either gzip-compressed or BGZF-compressed.
  528|       |        // Determine which, and decompress the first few records or lines.
  529|      0|        fmt->compression = gzip;
  530|      0|        if (len >= 18 && (s[3] & 4)) {
  531|      0|            if (memcmp(&s[12], "BC\2\0", 4) == 0)
  532|      0|                fmt->compression = bgzf;
  533|      0|            else if (memcmp(&s[12], "RAZF", 4) == 0)
  534|      0|                fmt->compression = razf_compression;
  535|      0|        }
  536|      0|        if (len >= 9 && s[2] == 8)
  537|      0|            fmt->compression_level = (s[8] == 2)? 9 : (s[8] == 4)? 1 : -1;
  538|       |
  539|      0|        len = decompress_peek_gz(hfile, s, sizeof s);
  540|      0|    }
  541|    578|    else if (len >= 10 && memcmp(s, "BZh", 3) == 0 &&
  542|      1|             (memcmp(&s[4], "\x31\x41\x59\x26\x53\x59", 6) == 0 ||
  543|      1|              memcmp(&s[4], "\x17\x72\x45\x38\x50\x90", 6) == 0)) {
  544|      0|        fmt->compression = bzip2_compression;
  545|      0|        fmt->compression_level = s[3] - '0';
  546|       |        // Decompressing via libbz2 produces no output until it has a whole
  547|       |        // block (of size 100Kb x level), which is too large for peeking.
  548|       |        // So unfortunately we can recognise bzip2 but not the contents,
  549|       |        // except that \x1772... magic indicates the stream is empty.
  550|      0|        if (s[4] == '\x31') return 0;
  551|      0|        else len = 0;
  552|      0|    }
  553|    578|    else if (len >= 6 && memcmp(s, "\xfd""7zXZ\0", 6) == 0) {
  554|      2|        fmt->compression = xz_compression;
  555|      2|#ifdef HAVE_LIBLZMA
  556|      2|        len = decompress_peek_xz(hfile, s, sizeof s);
  557|       |#else
  558|       |        // Without liblzma, we can't recognise the decompressed contents.
  559|       |        return 0;
  560|       |#endif
  561|      2|    }
  562|    576|    else if (len >= 4 && memcmp(s, "\x28\xb5\x2f\xfd", 4) == 0) {
  563|      2|        fmt->compression = zstd_compression;
  564|      2|        return 0;
  565|      2|    }
  566|    574|    else {
  567|    574|        len = hpeek(hfile, s, sizeof s);
  568|    574|    }
  569|    576|    if (len < 0) return -1;
  570|       |
  571|    575|    if (len == 0) {
  572|      1|        fmt->format = empty_format;
  573|      1|        return 0;
  574|      1|    }
  575|       |
  576|       |    // We avoid using filename extensions wherever possible (as filenames are
  577|       |    // not always available), but in a few cases they must be considered:
  578|       |    //  - FASTA/Q indexes are simply tab-separated text; files that match these
  579|       |    //    patterns but not the fai/fqi extension are usually generic BED files
  580|       |    //  - GZI indexes have no magic numbers so can only be detected by filename
  581|    574|    if (fname && strcmp(fname, "-") != 0) {
  582|    574|        char *s;
  583|    574|        if (find_file_extension(fname, extension) < 0) extension[0] = '\0';
  584|    574|        for (s = extension; *s; s++) *s = tolower_c(*s);
  585|    574|    }
  586|      0|    else extension[0] = '\0';
  587|       |
  588|    574|    if (len >= 6 && memcmp(s,"CRAM",4) == 0 && s[4]>=1 && s[4]<=7 && s[5]<=7) {
  589|    121|        fmt->category = sequence_data;
  590|    121|        fmt->format = cram;
  591|    121|        fmt->version.major = s[4], fmt->version.minor = s[5];
  592|    121|        fmt->compression = custom;
  593|    121|        return 0;
  594|    121|    }
  595|    453|    else if (len >= 4 && s[3] <= '\4') {
  596|     34|        if (memcmp(s, "BAM\1", 4) == 0) {
  597|     22|            fmt->category = sequence_data;
  598|     22|            fmt->format = bam;
  599|       |            // TODO Decompress enough to pick version from @HD-VN header
  600|     22|            fmt->version.major = 1, fmt->version.minor = -1;
  601|     22|            return 0;
  602|     22|        }
  603|     12|        else if (memcmp(s, "BAI\1", 4) == 0) {
  604|      1|            fmt->category = index_file;
  605|      1|            fmt->format = bai;
  606|      1|            fmt->version.major = -1, fmt->version.minor = -1;
  607|      1|            return 0;
  608|      1|        }
  609|     11|        else if (memcmp(s, "BCF\4", 4) == 0) {
  610|      3|            fmt->category = variant_data;
  611|      3|            fmt->format = bcf;
  612|      3|            fmt->version.major = 1, fmt->version.minor = -1;
  613|      3|            return 0;
  614|      3|        }
  615|      8|        else if (memcmp(s, "BCF\2", 4) == 0) {
  616|      5|            fmt->category = variant_data;
  617|      5|            fmt->format = bcf;
  618|      5|            fmt->version.major = s[3];
  619|      5|            fmt->version.minor = (len >= 5 && s[4] <= 2)? s[4] : 0;
  620|      5|            return 0;
  621|      5|        }
  622|      3|        else if (memcmp(s, "CSI\1", 4) == 0) {
  623|      1|            fmt->category = index_file;
  624|      1|            fmt->format = csi;
  625|      1|            fmt->version.major = 1, fmt->version.minor = -1;
  626|      1|            return 0;
  627|      1|        }
  628|      2|        else if (memcmp(s, "TBI\1", 4) == 0) {
  629|      1|            fmt->category = index_file;
  630|      1|            fmt->format = tbi;
  631|      1|            return 0;
  632|      1|        }
  633|       |        // GZI indexes have no magic numbers, so must be recognised solely by
  634|       |        // filename extension.
  635|      1|        else if (strcmp(extension, "gzi") == 0) {
  636|      0|            fmt->category = index_file;
  637|      0|            fmt->format = gzi;
  638|      0|            return 0;
  639|      0|        }
  640|    419|    }
  641|    419|    else if (len >= 16 && memcmp(s, "##fileformat=VCF", 16) == 0) {
  642|     12|        fmt->category = variant_data;
  643|     12|        fmt->format = vcf;
  644|     12|        if (len >= 21 && s[16] == 'v')
  645|      0|            parse_version(fmt, &s[17], &s[len]);
  646|     12|        return 0;
  647|     12|    }
  648|    407|    else if (len >= 4 && s[0] == '@' &&
  649|    182|             (memcmp(s, "@HD\t", 4) == 0 || memcmp(s, "@SQ\t", 4) == 0 ||
  650|    110|              memcmp(s, "@RG\t", 4) == 0 || memcmp(s, "@PG\t", 4) == 0 ||
  651|    133|              memcmp(s, "@CO\t", 4) == 0)) {
  652|    133|        fmt->category = sequence_data;
  653|    133|        fmt->format = sam;
  654|       |        // @HD-VN is not guaranteed to be the first tag, but then @HD is
  655|       |        // not guaranteed to be present at all...
  656|    133|        if (len >= 9 && memcmp(s, "@HD\tVN:", 7) == 0)
  657|      2|            parse_version(fmt, &s[7], &s[len]);
  658|    131|        else
  659|    131|            fmt->version.major = 1, fmt->version.minor = -1;
  660|    133|        return 0;
  661|    133|    }
  662|    274|    else if (len >= 8 && memcmp(s, "d4\xdd\xdd", 4) == 0) {
  663|      1|        fmt->category = region_list;
  664|      1|        fmt->format = d4_format;
  665|       |        // How to decode the D4 Format Version bytes is not yet specified
  666|       |        // so we don't try to set fmt->version.{major,minor}.
  667|      1|        return 0;
  668|      1|    }
  669|    273|    else if (cmp_nonblank("{\"htsget\":", s, &s[len]) == 0) {
  670|      0|        fmt->category = unknown_category;
  671|      0|        fmt->format = htsget;
  672|      0|        return 0;
  673|      0|    }
  674|    273|    else if (len > 8 && memcmp(s, "crypt4gh", 8) == 0) {
  675|      1|        fmt->category = unknown_category;
  676|      1|        fmt->format = hts_crypt4gh_format;
  677|      1|        return 0;
  678|      1|    }
  679|    272|    else if (len >= 1 && s[0] == '>' && secondline_is_bases(s, &s[len])) {
  680|     86|        fmt->category = sequence_data;
  681|     86|        fmt->format = fasta_format;
  682|     86|        return 0;
  683|     86|    }
  684|    186|    else if (len >= 1 && s[0] == '@' && secondline_is_bases(s, &s[len])) {
  685|     41|        fmt->category = sequence_data;
  686|     41|        fmt->format = fastq_format;
  687|     41|        return 0;
  688|     41|    }
  689|    145|    else if (parse_tabbed_text(columns, sizeof columns, s,
  690|     73|                               &s[len], &complete) > 0) {
  691|       |        // A complete SAM line is at least 11 columns.  On unmapped long reads may
  692|       |        // be missing two.  (On mapped long reads we must have an @ header so long
  693|       |        // CIGAR is irrelevant.)
  694|     73|        if (colmatch(columns, "ZiZiiCZiiZZOOOOOOOOOOOOOOOOOOOO+")
  695|      0|            >= 9 + 2*complete) {
  696|      0|            fmt->category = sequence_data;
  697|      0|            fmt->format = sam;
  698|      0|            fmt->version.major = 1, fmt->version.minor = -1;
  699|      0|            return 0;
  700|      0|        }
  701|     73|        else if (fmt->compression == gzip && colmatch(columns, "iiiiii") == 6) {
  702|      0|            fmt->category = index_file;
  703|      0|            fmt->format = crai;
  704|      0|            return 0;
  705|      0|        }
  706|     73|        else if (strstr(extension, "fqi") && colmatch(columns, "Ziiiii") == 6) {
  707|      0|            fmt->category = index_file;
  708|      0|            fmt->format = fqi_format;
  709|      0|            return 0;
  710|      0|        }
  711|     73|        else if (strstr(extension, "fai") && colmatch(columns, "Ziiii") == 5) {
  712|      0|            fmt->category = index_file;
  713|      0|            fmt->format = fai_format;
  714|      0|            return 0;
  715|      0|        }
  716|     73|        else if (colmatch(columns, "Zii+") >= 3) {
  717|      4|            fmt->category = region_list;
  718|      4|            fmt->format = bed;
  719|      4|            return 0;
  720|      4|        }
  721|    142|    }
  722|       |
  723|       |    // Arbitrary text files can be read using hts_getline().
  724|    142|    if (is_text_only(s, &s[len])) fmt->format = text_format;
  725|       |
  726|       |    // Nothing recognised: leave unset fmt-> fields as unknown.
  727|    142|    return 0;
  728|    142|}
hts_open_format:
  830|    367|{
  831|    367|    char smode[101], *cp, *cp2, *mode_c;
  832|    367|    htsFile *fp = NULL;
  833|    367|    hFILE *hfile = NULL;
  834|    367|    char fmt_code = '\0';
  835|       |    // see enum htsExactFormat in htslib/hts.h
  836|    367|    const char format_to_mode[] = "\0g\0\0b\0c\0\0b\0g\0\0\0\0\0Ff\0\0";
  837|       |
  838|    367|    strncpy(smode, mode, 99);
  839|    367|    smode[99]=0;
  840|    367|    if ((cp = strchr(smode, ',')))
  841|      0|        *cp = '\0';
  842|       |
  843|       |    // Migrate format code (b or c) to the end of the smode buffer.
  844|    734|    for (cp2 = cp = smode; *cp; cp++) {
  845|    367|        if (*cp == 'b')
  846|      0|            fmt_code = 'b';
  847|    367|        else if (*cp == 'c')
  848|      0|            fmt_code = 'c';
  849|    367|        else
  850|    367|            *cp2++ = *cp;
  851|    367|    }
  852|    367|    mode_c = cp2;
  853|    367|    *cp2++ = fmt_code;
  854|    367|    *cp2++ = 0;
  855|       |
  856|       |    // Set or reset the format code if opts->format is used
  857|    367|    if (fmt && fmt->format > unknown_format
  858|      0|        && fmt->format < sizeof(format_to_mode)) {
  859|      0|        *mode_c = format_to_mode[fmt->format];
  860|      0|    }
  861|       |
  862|       |    // If we really asked for a compressed text format then mode_c above will
  863|       |    // point to nul.  We set to 'z' to enable bgzf.
  864|    367|    if (strchr(mode, 'w') && fmt && fmt->compression == bgzf) {
  865|      0|        if (fmt->format == sam || fmt->format == vcf || fmt->format == text_format)
  866|      0|            *mode_c = 'z';
  867|      0|    }
  868|       |
  869|    367|    char *rmme = NULL, *fnidx = strstr(fn, HTS_IDX_DELIM);
  870|    367|    if ( fnidx ) {
  871|      0|        rmme = strdup(fn);
  872|      0|        if ( !rmme ) goto error;
  873|      0|        rmme[fnidx-fn] = 0;
  874|      0|        fn = rmme;
  875|      0|    }
  876|       |
  877|    367|    hfile = hopen(fn, smode);
  878|    367|    if (hfile == NULL) goto error;
  879|       |
  880|    367|    fp = hts_hopen(hfile, fn, smode);
  881|    367|    if (fp == NULL) goto error;
  882|       |
  883|       |    // Compensate for the loss of exactness in htsExactFormat.
  884|       |    // hts_hopen returns generics such as binary or text, but we
  885|       |    // have been given something explicit here so use that instead.
  886|    367|    if (fp->is_write && fmt &&
  887|      0|        (fmt->format == bam || fmt->format == sam ||
  888|      0|         fmt->format == vcf || fmt->format == bcf ||
  889|      0|         fmt->format == bed || fmt->format == fasta_format ||
  890|      0|         fmt->format == fastq_format))
  891|      0|        fp->format.format = fmt->format;
  892|       |
  893|    367|    if (fmt && fmt->specific)
  894|      0|        if (hts_opt_apply(fp, fmt->specific) != 0)
  895|      0|            goto error;
  896|       |
  897|    367|    if ( rmme ) free(rmme);
  898|    367|    return fp;
  899|       |
  900|      0|error:
  901|      0|    hts_log_error("Failed to open file \"%s\"%s%s", fn,
  902|      0|                  errno ? " : " : "", errno ? strerror(errno) : "");
  903|      0|    if ( rmme ) free(rmme);
  904|       |
  905|      0|    if (hfile)
  906|      0|        hclose_abruptly(hfile);
  907|       |
  908|      0|    return NULL;
  909|    367|}
hts_open:
  911|    367|htsFile *hts_open(const char *fn, const char *mode) {
  912|    367|    return hts_open_format(fn, mode, NULL);
  913|    367|}
hts_hopen:
 1370|    945|{
 1371|    945|    hFILE *hfile_orig = hfile;
 1372|    945|    htsFile *fp = (htsFile*)calloc(1, sizeof(htsFile));
 1373|    945|    char simple_mode[101], *cp, *opts;
 1374|    945|    simple_mode[100] = '\0';
 1375|       |
 1376|    945|    if (fp == NULL) goto error;
 1377|       |
 1378|    945|    fp->fn = strdup(fn);
 1379|    945|    fp->is_be = ed_is_big();
 1380|       |
 1381|       |    // Split mode into simple_mode,opts strings
 1382|    945|    if ((cp = strchr(mode, ','))) {
 1383|      0|        strncpy(simple_mode, mode, cp-mode <= 100 ? cp-mode : 100);
 1384|      0|        simple_mode[cp-mode] = '\0';
 1385|      0|        opts = cp+1;
 1386|    945|    } else {
 1387|    945|        strncpy(simple_mode, mode, 100);
 1388|    945|        opts = NULL;
 1389|    945|    }
 1390|       |
 1391|    945|    if (strchr(simple_mode, 'r')) {
 1392|    578|        const int max_loops = 5; // Should be plenty
 1393|    578|        int loops = 0;
 1394|    578|        if (hts_detect_format2(hfile, fn, &fp->format) < 0) goto error;
 1395|       |
 1396|       |        // Deal with formats that re-direct an underlying file via a plug-in.
 1397|       |        // Loops as we may have crypt4gh served via htsget, or
 1398|       |        // crypt4gh-in-crypt4gh.
 1399|    577|        while (fp->format.format == htsget ||
 1400|    577|               fp->format.format == hts_crypt4gh_format) {
 1401|       |            // Ensure we don't get stuck in an endless redirect loop
 1402|      1|            if (++loops > max_loops) {
 1403|      0|                errno = ELOOP;
 1404|      0|                goto error;
 1405|      0|            }
 1406|       |
 1407|      1|            if (fp->format.format == htsget) {
 1408|      0|                hFILE *hfile2 = hopen_htsget_redirect(hfile, simple_mode);
 1409|      0|                if (hfile2 == NULL) goto error;
 1410|       |
 1411|      0|                hfile = hfile2;
 1412|      0|            }
 1413|      1|            else if (fp->format.format == hts_crypt4gh_format) {
 1414|      1|                if (hts_crypt4gh_redirect(fn, simple_mode, &hfile, fp) < 0)
 1415|      1|                    goto error;
 1416|      0|            }
 1417|       |
 1418|       |            // Re-detect format against the result of the redirection
 1419|      0|            if (hts_detect_format2(hfile, fn, &fp->format) < 0) goto error;
 1420|      0|        }
 1421|    577|    }
 1422|    367|    else if (strchr(simple_mode, 'w') || strchr(simple_mode, 'a')) {
 1423|    367|        htsFormat *fmt = &fp->format;
 1424|    367|        fp->is_write = 1;
 1425|       |
 1426|    367|        if (strchr(simple_mode, 'b')) fmt->format = binary_format;
 1427|    367|        else if (strchr(simple_mode, 'c')) fmt->format = cram;
 1428|    367|        else if (strchr(simple_mode, 'f')) fmt->format = fastq_format;
 1429|    367|        else if (strchr(simple_mode, 'F')) fmt->format = fasta_format;
 1430|    367|        else fmt->format = text_format;
 1431|       |
 1432|    367|        if (strchr(simple_mode, 'z')) fmt->compression = bgzf;
 1433|    367|        else if (strchr(simple_mode, 'g')) fmt->compression = gzip;
 1434|    367|        else if (strchr(simple_mode, 'u')) fmt->compression = no_compression;
 1435|    367|        else {
 1436|       |            // No compression mode specified, set to the default for the format
 1437|    367|            switch (fmt->format) {
 1438|      0|            case binary_format: fmt->compression = bgzf; break;
 1439|      0|            case cram: fmt->compression = custom; break;
 1440|      0|            case fastq_format: fmt->compression = no_compression; break;
 1441|      0|            case fasta_format: fmt->compression = no_compression; break;
 1442|    367|            case text_format: fmt->compression = no_compression; break;
 1443|      0|            default: abort();
 1444|    367|            }
 1445|    367|        }
 1446|       |
 1447|       |        // Fill in category (if determinable; e.g. 'b' could be BAM or BCF)
 1448|    367|        fmt->category = format_category(fmt->format);
 1449|       |
 1450|    367|        fmt->version.major = fmt->version.minor = -1;
 1451|    367|        fmt->compression_level = -1;
 1452|    367|        fmt->specific = NULL;
 1453|    367|    }
 1454|      0|    else { errno = EINVAL; goto error; }
 1455|       |
 1456|    943|    switch (fp->format.format) {
 1457|      0|    case binary_format:
 1458|     22|    case bam:
 1459|     30|    case bcf:
 1460|     30|        fp->fp.bgzf = bgzf_hopen(hfile, simple_mode);
 1461|     30|        if (fp->fp.bgzf == NULL) goto error;
 1462|     30|        fp->is_bin = fp->is_bgzf = 1;
 1463|     30|        break;
 1464|       |
 1465|    121|    case cram:
 1466|    121|        fp->fp.cram = cram_dopen(hfile, fn, simple_mode);
 1467|    121|        if (fp->fp.cram == NULL) goto error;
 1468|     65|        if (!fp->is_write)
 1469|     65|            cram_set_option(fp->fp.cram, CRAM_OPT_DECODE_MD, -1); // auto
 1470|     65|        fp->is_cram = 1;
 1471|     65|        break;
 1472|       |
 1473|      1|    case empty_format:
 1474|    489|    case text_format:
 1475|    493|    case bed:
 1476|    579|    case fasta_format:
 1477|    620|    case fastq_format:
 1478|    753|    case sam:
 1479|    765|    case vcf:
 1480|    765|        if (fp->format.compression != no_compression) {
 1481|      1|            fp->fp.bgzf = bgzf_hopen(hfile, simple_mode);
 1482|      1|            if (fp->fp.bgzf == NULL) goto error;
 1483|      1|            fp->is_bgzf = 1;
 1484|      1|        }
 1485|    764|        else
 1486|    764|            fp->fp.hfile = hfile;
 1487|    765|        break;
 1488|       |
 1489|     27|    default:
 1490|     27|        errno = EFTYPE;
 1491|     27|        goto error;
 1492|    860|    }
 1493|       |
 1494|    860|    if (opts)
 1495|      0|        hts_process_opts(fp, opts);
 1496|       |
 1497|       |    // If redirecting, close the original hFILE now (pedantically we would
 1498|       |    // instead close it in hts_close(), but this a simplifying optimisation)
 1499|    860|    if (hfile != hfile_orig) hclose_abruptly(hfile_orig);
 1500|       |
 1501|    860|    return fp;
 1502|       |
 1503|     85|error:
 1504|     85|    hts_log_error("Failed to open file %s", fn);
 1505|       |
 1506|       |    // If redirecting, close the failed redirection hFILE that we have opened
 1507|     85|    if (hfile != hfile_orig) hclose_abruptly(hfile);
 1508|       |
 1509|     85|    if (fp) {
 1510|     85|        free(fp->fn);
 1511|     85|        free(fp->fn_aux);
 1512|     85|        free(fp);
 1513|     85|    }
 1514|     85|    return NULL;
 1515|    860|}
hts_close:
 1518|    860|{
 1519|    860|    int ret = 0, save;
 1520|       |
 1521|    860|    switch (fp->format.format) {
 1522|      0|    case binary_format:
 1523|     22|    case bam:
 1524|     30|    case bcf:
 1525|     30|        ret = bgzf_close(fp->fp.bgzf);
 1526|     30|        break;
 1527|       |
 1528|     65|    case cram:
 1529|     65|        if (!fp->is_write) {
 1530|     65|            switch (cram_eof(fp->fp.cram)) {
 1531|      6|            case 2:
 1532|      6|                hts_log_warning("EOF marker is absent. The input is probably truncated");
 1533|      6|                break;
 1534|     59|            case 0:  /* not at EOF, but may not have wanted all seqs */
 1535|     59|            default: /* case 1, expected EOF */
 1536|     59|                break;
 1537|     65|            }
 1538|     65|        }
 1539|     65|        ret = cram_close(fp->fp.cram);
 1540|     65|        break;
 1541|       |
 1542|      1|    case empty_format:
 1543|    165|    case text_format:
 1544|    169|    case bed:
 1545|    255|    case fasta_format:
 1546|    296|    case fastq_format:
 1547|    753|    case sam:
 1548|    765|    case vcf:
 1549|    765|        if (fp->format.format == sam)
 1550|    457|            ret = sam_state_destroy(fp);
 1551|    308|        else if (fp->format.format == fastq_format ||
 1552|    267|                 fp->format.format == fasta_format)
 1553|    127|            fastq_state_destroy(fp);
 1554|       |
 1555|    765|        if (fp->format.compression != no_compression)
 1556|      1|            ret |= bgzf_close(fp->fp.bgzf);
 1557|    764|        else
 1558|    764|            ret |= hclose(fp->fp.hfile);
 1559|    765|        break;
 1560|       |
 1561|      0|    default:
 1562|      0|        ret = -1;
 1563|      0|        break;
 1564|    860|    }
 1565|       |
 1566|    860|    save = errno;
 1567|    860|    sam_hdr_destroy(fp->bam_header);
 1568|    860|    hts_idx_destroy(fp->idx);
 1569|    860|    hts_filter_free(fp->filter);
 1570|    860|    free(fp->fn);
 1571|    860|    free(fp->fn_aux);
 1572|    860|    free(fp->line.s);
 1573|    860|    free(fp);
 1574|    860|    errno = save;
 1575|    860|    return ret;
 1576|    860|}
hts_getline:
 1889|  2.09k|{
 1890|  2.09k|    int ret;
 1891|  2.09k|    if (! (delimiter == KS_SEP_LINE || delimiter == '\n')) {
 1892|      0|        hts_log_error("Unexpected delimiter %d", delimiter);
 1893|      0|        abort();
 1894|      0|    }
 1895|       |
 1896|  2.09k|    switch (fp->format.compression) {
 1897|  2.09k|    case no_compression:
 1898|  2.09k|        str->l = 0;
 1899|  2.09k|        ret = kgetline2(str, (kgets_func2 *) hgetln, fp->fp.hfile);
 1900|  2.09k|        if (ret >= 0) ret = str->l;
 1901|    228|        else if (herrno(fp->fp.hfile)) ret = -2, errno = herrno(fp->fp.hfile);
 1902|    228|        else ret = -1;
 1903|  2.09k|        break;
 1904|       |
 1905|      0|    case gzip:
 1906|      0|    case bgzf:
 1907|      0|        ret = bgzf_getline(fp->fp.bgzf, '\n', str);
 1908|      0|        break;
 1909|       |
 1910|      0|    default:
 1911|      0|        abort();
 1912|  2.09k|    }
 1913|       |
 1914|  2.09k|    ++fp->lineno;
 1915|  2.09k|    return ret;
 1916|  2.09k|}
hts_idx_destroy:
 2491|    860|{
 2492|    860|    khint_t k;
 2493|    860|    int i;
 2494|    860|    if (idx == 0) return;
 2495|       |
 2496|       |    // For HTS_FMT_CRAI, idx actually points to a different type -- see sam.c
 2497|      0|    if (idx->fmt == HTS_FMT_CRAI) {
 2498|      0|        hts_cram_idx_t *cidx = (hts_cram_idx_t *) idx;
 2499|      0|        cram_index_free(cidx->cram);
 2500|      0|        free(cidx);
 2501|      0|        return;
 2502|      0|    }
 2503|       |
 2504|      0|    for (i = 0; i < idx->m; ++i) {
 2505|      0|        bidx_t *bidx = idx->bidx[i];
 2506|      0|        free(idx->lidx[i].offset);
 2507|      0|        if (bidx == 0) continue;
 2508|      0|        for (k = kh_begin(bidx); k != kh_end(bidx); ++k)
 2509|      0|            if (kh_exist(bidx, k))
 2510|      0|                free(kh_value(bidx, k).list);
 2511|      0|        kh_destroy(bin, bidx);
 2512|      0|    }
 2513|      0|    free(idx->bidx); free(idx->lidx); free(idx->meta);
 2514|      0|    free(idx);
 2515|      0|}
hts_resize_array_:
 4659|      7|                      const char *func) {
 4660|       |    /* If new_size and item_size are both below this limit, multiplying them
 4661|       |       together can't overflow */
 4662|      7|    const size_t safe = (size_t) 1 << (sizeof(size_t) * 4);
 4663|      7|    void *new_ptr;
 4664|      7|    size_t bytes, new_size;
 4665|       |
 4666|      7|    new_size = num;
 4667|      7|    kroundup_size_t(new_size);
 4668|      7|    bytes = item_size * new_size;
 4669|       |
 4670|       |    /* Check for overflow.  Both ensure that alloc will fit in alloc_in_out (we
 4671|       |       make the pessimistic assumption that *alloc_in_out is signed), and that
 4672|       |       bytes has not wrapped around. */
 4673|       |
 4674|      7|    if ((new_size > (((size_t) 1 << (size_sz * 8 - 1)) - 1))
 4675|      7|        || (((item_size > safe) || (new_size > safe))
 4676|      0|            && bytes / new_size != item_size)) {
 4677|      0|        hts_log(HTS_LOG_ERROR, func, "Memory allocation too large");
 4678|      0|        errno = ENOMEM;
 4679|      0|        return -1;
 4680|      0|    }
 4681|       |
 4682|      7|    new_ptr = realloc(*ptr_in_out, bytes);
 4683|      7|    if (new_ptr == NULL) {
 4684|      0|        int save_errno = errno;
 4685|      0|        hts_log(HTS_LOG_ERROR, func, "%s", strerror(errno));
 4686|      0|        errno = save_errno;
 4687|      0|        return -1;
 4688|      0|    }
 4689|       |
 4690|      7|    if (flags & HTS_RESIZE_CLEAR) {
 4691|      7|        size_t old_size;
 4692|      7|        switch (size_sz) {
 4693|      7|        case 4: old_size = *((uint32_t *) size_in_out); break;
 4694|      0|        case 8: old_size = *((uint64_t *) size_in_out); break;
 4695|      0|        default: abort();
 4696|      7|        }
 4697|      7|        if (new_size > old_size) {
 4698|      7|            memset((char *) new_ptr + old_size * item_size, 0,
 4699|      7|                   (new_size - old_size) * item_size);
 4700|      7|        }
 4701|      7|    }
 4702|       |
 4703|      7|    switch (size_sz) {
 4704|      7|    case 4: *((uint32_t *) size_in_out) = new_size; break;
 4705|      0|    case 8: *((uint64_t *) size_in_out) = new_size; break;
 4706|      0|    default: abort();
 4707|      7|    }
 4708|       |
 4709|      7|    *ptr_in_out = new_ptr;
 4710|      7|    return 0;
 4711|      7|}
hts_log:
 4753|    461|{
 4754|    461|    int save_errno = errno;
 4755|    461|    if (severity <= hts_verbose) {
 4756|    455|        va_list argptr;
 4757|       |
 4758|    455|        fprintf(stderr, "[%c::%s] ", get_severity_tag(severity), context);
 4759|       |
 4760|    455|        va_start(argptr, format);
 4761|    455|        vfprintf(stderr, format, argptr);
 4762|    455|        va_end(argptr);
 4763|       |
 4764|    455|        fprintf(stderr, "\n");
 4765|    455|    }
 4766|    461|    errno = save_errno;
 4767|    461|}
hts.c:decompress_peek_xz:
  339|      2|{
  340|      2|    unsigned char buffer[2048];
  341|      2|    ssize_t npeek = hpeek(fp, buffer, sizeof buffer);
  342|      2|    if (npeek < 0) return -1;
  343|       |
  344|      2|    lzma_stream ls = LZMA_STREAM_INIT;
  345|      2|    if (lzma_stream_decoder(&ls, lzma_easy_decoder_memusage(9), 0) != LZMA_OK)
  346|      0|        return -1;
  347|       |
  348|      2|    ls.next_in = buffer;
  349|      2|    ls.avail_in = npeek;
  350|      2|    ls.next_out = dest;
  351|      2|    ls.avail_out = destsize;
  352|       |
  353|      2|    int r = lzma_code(&ls, LZMA_RUN);
  354|      2|    if (! (r == LZMA_OK || r == LZMA_STREAM_END)) {
  355|      1|        lzma_end(&ls);
  356|      1|        return -1;
  357|      1|    }
  358|       |
  359|      1|    destsize = ls.total_out;
  360|      1|    lzma_end(&ls);
  361|       |
  362|      1|    return destsize;
  363|      1|}
hts.c:parse_version:
  371|      2|{
  372|      2|    const char *s    = (const char *) u;
  373|      2|    const char *slim = (const char *) ulim;
  374|      2|    short v;
  375|       |
  376|      2|    fmt->version.major = fmt->version.minor = -1;
  377|       |
  378|      4|    for (v = 0; s < slim && isdigit_c(*s); s++)
  379|      2|        v = 10 * v + *s - '0';
  380|       |
  381|      2|    if (s < slim) {
  382|      2|        fmt->version.major = v;
  383|      2|        if (*s == '.') {
  384|      0|            s++;
  385|      0|            for (v = 0; s < slim && isdigit_c(*s); s++)
  386|      0|                v = 10 * v + *s - '0';
  387|      0|            if (s < slim)
  388|      0|                fmt->version.minor = v;
  389|      0|        }
  390|      2|        else
  391|      2|            fmt->version.minor = 0;
  392|      2|    }
  393|      2|}
hts.c:cmp_nonblank:
  397|    273|{
  398|    273|    const unsigned char *ukey = (const unsigned char *) key;
  399|       |
  400|    387|    while (*ukey)
  401|    387|        if (u >= ulim) return +1;
  402|    373|        else if (isspace_c(*u)) u++;
  403|    263|        else if (*u != *ukey) return (*ukey < *u)? -1 : +1;
  404|      4|        else u++, ukey++;
  405|       |
  406|      0|    return 0;
  407|    273|}
hts.c:secondline_is_bases:
  420|    144|{
  421|       |    // Skip to second line, returning false if there isn't one
  422|    144|    u = memchr(u, '\n', ulim - u);
  423|    144|    if (u == NULL || ++u == ulim) return 0;
  424|       |
  425|       |    // Scan over all base-encoding letters (including 'N' but not SEQ's '=')
  426|    423|    while (u < ulim && (seq_nt16_table[*u] != 15 || toupper(*u) == 'N')) {
  427|    290|        if (*u == '=') return 0;
  428|    289|        u++;
  429|    289|    }
  430|       |
  431|    133|    return (u == ulim || *u == '\r' || *u == '\n')? 1 : 0;
  432|    134|}
hts.c:parse_tabbed_text:
  442|    145|{
  443|    145|    const char *str  = (const char *) u;
  444|    145|    const char *slim = (const char *) ulim;
  445|    145|    const char *s;
  446|    145|    int ncolumns = 0;
  447|       |
  448|    145|    enum { digit = 1, leading_sign = 2, cigar_operator = 4, other = 8 };
  449|    145|    unsigned seen = 0;
  450|    145|    *complete = 0;
  451|       |
  452|  1.70k|    for (s = str; s < slim; s++)
  453|  1.63k|        if (*s >= ' ') {
  454|  1.27k|            if (isdigit_c(*s))
  455|    209|                seen |= digit;
  456|  1.06k|            else if ((*s == '+' || *s == '-') && s == str)
  457|     64|                seen |= leading_sign;
  458|    999|            else if (strchr(BAM_CIGAR_STR, *s) && s > str && isdigit_c(s[-1]))
  459|     74|                seen |= cigar_operator;
  460|    925|            else
  461|    925|                seen |= other;
  462|  1.27k|        }
  463|    359|        else if (*s == '\t' || *s == '\r' || *s == '\n') {
  464|    321|            size_t len = s - str;
  465|    321|            char type;
  466|       |
  467|    321|            if (seen == digit || seen == (leading_sign|digit)) type = 'i';
  468|    295|            else if (seen == (digit|cigar_operator)) type = 'C';
  469|    271|            else if (len == 1)
  470|     66|                switch (str[0]) {
  471|      0|                case '*': type = 'C'; break;
  472|     25|                case '+': case '-': case '.': type = 's'; break;
  473|     41|                default: type = 'Z'; break;
  474|    205|                }
  475|    205|            else if (len >= 5 && str[2] == ':' && str[4] == ':') type = 'O';
  476|    201|            else type = 'Z';
  477|       |
  478|    321|            columns[ncolumns++] = type;
  479|    321|            if (*s != '\t' || ncolumns >= column_len - 1) {
  480|     29|                *complete = 1; // finished the line or more columns than needed
  481|     29|                break;
  482|     29|            }
  483|       |
  484|    292|            str = s + 1;
  485|    292|            seen = 0;
  486|    292|        }
  487|     38|        else return -1;
  488|       |
  489|    107|    columns[ncolumns] = '\0';
  490|    107|    return ncolumns;
  491|    145|}
hts.c:colmatch:
  496|    146|{
  497|    146|    int i;
  498|    318|    for (i = 0; columns[i] != '\0'; i++) {
  499|    250|        if (pattern[i] == '+') return i;
  500|    246|        if (! (columns[i] == pattern[i] || pattern[i] == 'Z')) return 0;
  501|    246|    }
  502|       |
  503|     68|    return i;
  504|    146|}
hts.c:is_text_only:
  410|    142|{
  411|  2.24k|    for (; u < ulim; u++)
  412|  2.12k|        if (! (*u >= ' ' || *u == '\t' || *u == '\r' || *u == '\n'))
  413|     21|            return 0;
  414|       |
  415|    121|    return 1;
  416|    142|}
hts.c:hts_crypt4gh_redirect:
 1341|      1|                                 hFILE **hfile_ptr, htsFile *fp) {
 1342|      1|    hFILE *hfile1 = *hfile_ptr;
 1343|      1|    hFILE *hfile2 = NULL;
 1344|      1|    char fn_buf[512], *fn2 = fn_buf;
 1345|      1|    const char *prefix = "crypt4gh:";
 1346|      1|    size_t fn2_len = strlen(prefix) + strlen(fn) + 1;
 1347|      1|    int ret = -1;
 1348|       |
 1349|      1|    if (fn2_len > sizeof(fn_buf)) {
 1350|      0|        fn2 = malloc(fn2_len);
 1351|      0|        if (!fn2) return -1;
 1352|      1|    }
 1353|       |
 1354|       |    // Reopen fn using the crypt4gh plug-in (if available)
 1355|      1|    snprintf(fn2, fn2_len, "%s%s", prefix, fn);
 1356|      1|    hfile2 = hopen(fn2, mode, "parent", hfile1, NULL);
 1357|      1|    if (hfile2) {
 1358|       |        // Replace original hfile with the new one.  The original is now
 1359|       |        // enclosed within hfile2
 1360|      0|        *hfile_ptr = hfile2;
 1361|      0|        ret = 0;
 1362|      0|    }
 1363|       |
 1364|      1|    if (fn2 != fn_buf)
 1365|      0|        free(fn2);
 1366|      1|    return ret;
 1367|      1|}
hts.c:format_category:
  265|    367|{
  266|    367|    switch (fmt) {
  267|      0|    case bam:
  268|      0|    case sam:
  269|      0|    case cram:
  270|      0|    case fastq_format:
  271|      0|    case fasta_format:
  272|      0|        return sequence_data;
  273|       |
  274|      0|    case vcf:
  275|      0|    case bcf:
  276|      0|        return variant_data;
  277|       |
  278|      0|    case bai:
  279|      0|    case crai:
  280|      0|    case csi:
  281|      0|    case fai_format:
  282|      0|    case fqi_format:
  283|      0|    case gzi:
  284|      0|    case tbi:
  285|      0|        return index_file;
  286|       |
  287|      0|    case bed:
  288|      0|    case d4_format:
  289|      0|        return region_list;
  290|       |
  291|      0|    case htsget:
  292|      0|    case hts_crypt4gh_format:
  293|      0|        return unknown_category;
  294|       |
  295|      0|    case unknown_format:
  296|      0|    case binary_format:
  297|    367|    case text_format:
  298|    367|    case empty_format:
  299|    367|    case format_maximum:
  300|    367|        break;
  301|    367|    }
  302|       |
  303|    367|    return unknown_category;
  304|    367|}
hts.c:get_severity_tag:
 4733|    455|{
 4734|    455|    switch (severity) {
 4735|    243|    case HTS_LOG_ERROR:
 4736|    243|        return 'E';
 4737|    212|    case HTS_LOG_WARNING:
 4738|    212|        return 'W';
 4739|      0|    case HTS_LOG_INFO:
 4740|      0|        return 'I';
 4741|      0|    case HTS_LOG_DEBUG:
 4742|      0|        return 'D';
 4743|      0|    case HTS_LOG_TRACE:
 4744|      0|        return 'T';
 4745|      0|    default:
 4746|      0|        break;
 4747|      0|    }
 4748|       |
 4749|      0|    return '*';
 4750|      0|}

hts_filter_free:
  668|    860|void hts_filter_free(hts_filter_t *filt) {
  669|    860|    if (!filt)
  670|    860|        return;
  671|       |
  672|      0|    int i;
  673|      0|    for (i = 0; i < filt->max_regex; i++)
  674|      0|        regfree(&filt->preg[i]);
  675|       |
  676|      0|    free(filt->str);
  677|      0|    free(filt);
  678|      0|}

hts.c:find_file_extension:
  131|    574|{
  132|    574|    const char *delim = fn ? strstr(fn, HTS_IDX_DELIM) : NULL, *ext;
  133|    574|    if (!fn) return -1;
  134|    574|    if (!delim) delim = fn + strlen(fn);
  135|  2.87k|    for (ext = delim; ext > fn && *ext != '.' && *ext != '/'; --ext) {}
  136|    574|    if (*ext == '.' &&
  137|      0|        ((delim - ext == 3 && ext[1] == 'g' && ext[2] == 'z') || // permit .sam.gz as a valid file extension
  138|      0|        (delim - ext == 4 && ext[1] == 'b' && ext[2] == 'g' && ext[3] == 'z'))) // permit .vcf.bgz as a valid file extension
  139|      0|    {
  140|      0|        for (ext--; ext > fn && *ext != '.' && *ext != '/'; --ext) {}
  141|      0|    }
  142|    574|    if (*ext != '.' || delim - ext > HTS_MAX_EXT_LEN || delim - ext < 4) return -1;
  143|      0|    memcpy(ext_out, ext + 1, delim - ext - 1);
  144|      0|    ext_out[delim - ext - 1] = '\0';
  145|      0|    return 0;
  146|      0|}

hfile.c:htell:
  145|     33|{
  146|     33|    return fp->offset + (fp->begin - fp->buffer);
  147|     33|}
hts.c:hgetln:
  185|  2.27k|{
  186|  2.27k|    return hgetdelim(buffer, size, '\n', fp);
  187|  2.27k|}
hts.c:herrno:
  124|    228|{
  125|    228|    return fp->has_errno;
  126|    228|}
sam.c:hwrite:
  266|    755|{
  267|    755|    extern ssize_t hwrite2(hFILE *, const void *, size_t, size_t);
  268|    755|    extern int hfile_set_blksize(hFILE *fp, size_t bufsiz);
  269|       |
  270|    755|    if (!fp->mobile) {
  271|      0|        size_t n = fp->limit - fp->begin;
  272|      0|        if (n < nbytes) {
  273|      0|            hfile_set_blksize(fp, fp->limit - fp->buffer + nbytes);
  274|      0|            fp->end = fp->limit;
  275|      0|        }
  276|      0|    }
  277|       |
  278|    755|    size_t n = fp->limit - fp->begin;
  279|    755|    if (nbytes >= n && fp->begin == fp->buffer) {
  280|       |        // Go straight to hwrite2 if the buffer is empty and the request
  281|       |        // won't fit.
  282|      0|        return hwrite2(fp, buffer, nbytes, 0);
  283|      0|    }
  284|       |
  285|    755|    if (n > nbytes) n = nbytes;
  286|    755|    memcpy(fp->begin, buffer, n);
  287|    755|    fp->begin += n;
  288|    755|    return (n==nbytes)? (ssize_t) n : hwrite2(fp, buffer, nbytes, n);
  289|    755|}
cram_io.c:hgetc:
  153|  3.09k|{
  154|  3.09k|    extern int hgetc2(hFILE *);
  155|  3.02k|    return (fp->end > fp->begin)? (unsigned char) *(fp->begin++) : hgetc2(fp);
  156|  3.09k|}
cram_io.c:hread:
  224|    646|{
  225|    646|    extern ssize_t hread2(hFILE *, void *, size_t, size_t);
  226|       |
  227|    646|    size_t n = fp->end - fp->begin;
  228|    646|    if (n > nbytes) n = nbytes;
  229|    646|    memcpy(buffer, fp->begin, n);
  230|    646|    fp->begin += n;
  231|    646|    return (n == nbytes || !fp->mobile)? (ssize_t) n : hread2(fp, buffer, nbytes, n);
  232|    646|}
bgzf.c:hread:
  224|     59|{
  225|     59|    extern ssize_t hread2(hFILE *, void *, size_t, size_t);
  226|       |
  227|     59|    size_t n = fp->end - fp->begin;
  228|     59|    if (n > nbytes) n = nbytes;
  229|     59|    memcpy(buffer, fp->begin, n);
  230|     59|    fp->begin += n;
  231|     59|    return (n == nbytes || !fp->mobile)? (ssize_t) n : hread2(fp, buffer, nbytes, n);
  232|     59|}
bgzf.c:htell:
  145|     89|{
  146|     89|    return fp->offset + (fp->begin - fp->buffer);
  147|     89|}
bgzf.c:hclearerr:
  130|     11|{
  131|     11|    fp->has_errno = 0;
  132|     11|}

hts.c:ed_is_big:
 1523|    945|{
 1524|    945|    long one= 1;
 1525|    945|    return !(*((char *)(&one)));
 1526|    945|}
sam.c:hts_reg2bin:
 1487|    431|{
 1488|    431|    int l, s = min_shift, t = ((1<<((n_lvls<<1) + n_lvls)) - 1) / 7;
 1489|    431|    for (--end, l = n_lvls; l > 0; --l, s += 3, t -= 1<<((l<<1)+l))
 1490|    431|        if (beg>>s == end>>s) return t + (beg>>s);
 1491|      0|    return 0;
 1492|    431|}
bgzf.c:ed_is_big:
 1523|     31|{
 1524|     31|    long one= 1;
 1525|     31|    return !(*((char *)(&one)));
 1526|     31|}

sam.c:le_to_u32:
  134|     21|static inline uint32_t le_to_u32(const uint8_t *buf) {
  135|     21|#if defined(HTS_LITTLE_ENDIAN) && HTS_ALLOW_UNALIGNED != 0
  136|     21|    return *((uint32_u *) buf);
  137|       |#else
  138|       |    return ((uint32_t) buf[0] |
  139|       |            ((uint32_t) buf[1] << 8) |
  140|       |            ((uint32_t) buf[2] << 16) |
  141|       |            ((uint32_t) buf[3] << 24));
  142|       |#endif
  143|     21|}

header.c:kh_put_sam_hrecs_t:
  312|    136|	{																	\
  313|    136|		khint_t x;														\
  314|    136|		if (h->n_occupied >= h->upper_bound) { /* update the hash table */ \
  315|    123|			if (h->n_buckets > (h->size<<1)) {							\
  316|      0|				if (kh_resize_##name(h, h->n_buckets - 1) < 0) { /* clear "deleted" elements */ \
  317|      0|					*ret = -1; return h->n_buckets;						\
  318|      0|				}														\
  319|    123|			} else if (kh_resize_##name(h, h->n_buckets + 1) < 0) { /* expand the hash table */ \
  320|      0|				*ret = -1; return h->n_buckets;							\
  321|      0|			}															\
  322|    123|		} /* TODO: to implement automatically shrinking; resize() already support shrinking */ \
  323|    136|		{																\
  324|    136|			khint_t k, i, site, last, mask = h->n_buckets - 1, step = 0; \
  325|    136|			x = site = h->n_buckets; k = __hash_func(key); i = k & mask; \
  326|    136|			if (__ac_isempty(h->flags, i)) x = i; /* for speed up */	\
  327|      9|			else {														\
  328|      9|				last = i; \
  329|     10|				while (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i) || !__hash_equal(h->keys[i], key))) { \
  330|      1|					if (__ac_isdel(h->flags, i)) site = i;				\
  331|      1|					i = (i + (++step)) & mask; \
  332|      1|					if (i == last) { x = site; break; }					\
  333|      1|				}														\
  334|      9|				if (x == h->n_buckets) {								\
  335|      9|					if (__ac_isempty(h->flags, i) && site != h->n_buckets) x = site; \
  336|      9|					else x = i;											\
  337|      9|				}														\
  338|      9|			}															\
  339|    136|		}																\
  340|    136|		if (__ac_isempty(h->flags, x)) { /* not present at all */		\
  341|    128|			h->keys[x] = key;											\
  342|    128|			__ac_set_isboth_false(h->flags, x);							\
  343|    128|			++h->size; ++h->n_occupied;									\
  344|    128|			*ret = 1;													\
  345|      8|		} else if (__ac_isdel(h->flags, x)) { /* deleted */				\
  346|      0|			h->keys[x] = key;											\
  347|      0|			__ac_set_isboth_false(h->flags, x);							\
  348|      0|			++h->size;													\
  349|      0|			*ret = 2;													\
  350|      8|		} else *ret = 0; /* Don't touch h->keys[x] if present and not deleted */ \
  351|    136|		return x;														\
  352|    136|	}																	\
header.c:kh_resize_sam_hrecs_t:
  249|    123|	{ /* This function uses 0.25*n_buckets bytes of working space instead of [sizeof(key_t+val_t)+.25]*n_buckets. */ \
  250|    123|		khint32_t *new_flags = 0;										\
  251|    123|		khint_t j = 1;													\
  252|    123|		{																\
  253|    123|			kroundup32(new_n_buckets); 									\
  254|    123|			if (new_n_buckets < 4) new_n_buckets = 4;					\
  255|    123|			if (h->size >= (khint_t)(new_n_buckets * __ac_HASH_UPPER + 0.5)) j = 0;	/* requested size is too small */ \
  256|    123|			else { /* hash table size to be changed (shrink or expand); rehash */ \
  257|    123|				new_flags = (khint32_t*)kmalloc(__ac_fsize(new_n_buckets) * sizeof(khint32_t));	\
  258|    123|				if (!new_flags) return -1;								\
  259|    123|				memset(new_flags, 0xaa, __ac_fsize(new_n_buckets) * sizeof(khint32_t)); \
  260|    123|				if (h->n_buckets < new_n_buckets) {	/* expand */		\
  261|    123|					khkey_t *new_keys = (khkey_t*)krealloc((void *)h->keys, new_n_buckets * sizeof(khkey_t)); \
  262|    123|					if (!new_keys) { kfree(new_flags); return -1; }		\
  263|    123|					h->keys = new_keys;									\
  264|    123|					if (kh_is_map) {									\
  265|    123|						khval_t *new_vals = (khval_t*)krealloc((void *)h->vals, new_n_buckets * sizeof(khval_t)); \
  266|    123|						if (!new_vals) { kfree(new_flags); return -1; }	\
  267|    123|						h->vals = new_vals;								\
  268|    123|					}													\
  269|    123|				} /* otherwise shrink */								\
  270|    123|			}															\
  271|    123|		}																\
  272|    123|		if (j) { /* rehashing is needed */								\
  273|    123|			for (j = 0; j != h->n_buckets; ++j) {						\
  274|      0|				if (__ac_iseither(h->flags, j) == 0) {					\
  275|      0|					khkey_t key = h->keys[j];							\
  276|      0|					khval_t val;										\
  277|      0|					khint_t new_mask;									\
  278|      0|					new_mask = new_n_buckets - 1; 						\
  279|      0|					if (kh_is_map) val = h->vals[j];					\
  280|      0|					__ac_set_isdel_true(h->flags, j);					\
  281|      0|					while (1) { /* kick-out process; sort of like in Cuckoo hashing */ \
  282|      0|						khint_t k, i, step = 0; \
  283|      0|						k = __hash_func(key);							\
  284|      0|						i = k & new_mask;								\
  285|      0|						while (!__ac_isempty(new_flags, i)) i = (i + (++step)) & new_mask; \
  286|      0|						__ac_set_isempty_false(new_flags, i);			\
  287|      0|						if (i < h->n_buckets && __ac_iseither(h->flags, i) == 0) { /* kick out the existing element */ \
  288|      0|							{ khkey_t tmp = h->keys[i]; h->keys[i] = key; key = tmp; } \
  289|      0|							if (kh_is_map) { khval_t tmp = h->vals[i]; h->vals[i] = val; val = tmp; } \
  290|      0|							__ac_set_isdel_true(h->flags, i); /* mark it as deleted in the old hash table */ \
  291|      0|						} else { /* write the element and jump out of the loop */ \
  292|      0|							h->keys[i] = key;							\
  293|      0|							if (kh_is_map) h->vals[i] = val;			\
  294|      0|							break;										\
  295|      0|						}												\
  296|      0|					}													\
  297|      0|				}														\
  298|      0|			}															\
  299|    123|			if (h->n_buckets > new_n_buckets) { /* shrink the hash table */ \
  300|      0|				h->keys = (khkey_t*)krealloc((void *)h->keys, new_n_buckets * sizeof(khkey_t)); \
  301|      0|				if (kh_is_map) h->vals = (khval_t*)krealloc((void *)h->vals, new_n_buckets * sizeof(khval_t)); \
  302|      0|			}															\
  303|    123|			kfree(h->flags); /* free the working space */				\
  304|    123|			h->flags = new_flags;										\
  305|    123|			h->n_buckets = new_n_buckets;								\
  306|    123|			h->n_occupied = h->size;									\
  307|    123|			h->upper_bound = (khint_t)(h->n_buckets * __ac_HASH_UPPER + 0.5); \
  308|    123|		}																\
  309|    123|		return 0;														\
  310|    123|	}																	\
header.c:kh_init_sam_hrecs_t:
  216|    391|	SCOPE kh_##name##_t *kh_init_##name(void) {							\
  217|    391|		return (kh_##name##_t*)kcalloc(1, sizeof(kh_##name##_t));		\
  218|    391|	}																	\
header.c:kh_init_m_s2i:
  216|  1.17k|	SCOPE kh_##name##_t *kh_init_##name(void) {							\
  217|  1.17k|		return (kh_##name##_t*)kcalloc(1, sizeof(kh_##name##_t));		\
  218|  1.17k|	}																	\
header.c:kh_destroy_sam_hrecs_t:
  220|    391|	{																	\
  221|    391|		if (h) {														\
  222|    391|			kfree((void *)h->keys); kfree(h->flags);					\
  223|    391|			kfree((void *)h->vals);										\
  224|    391|			kfree(h);													\
  225|    391|		}																\
  226|    391|	}																	\
header.c:kh_destroy_m_s2i:
  220|  1.17k|	{																	\
  221|  1.17k|		if (h) {														\
  222|  1.17k|			kfree((void *)h->keys); kfree(h->flags);					\
  223|  1.17k|			kfree((void *)h->vals);										\
  224|  1.17k|			kfree(h);													\
  225|  1.17k|		}																\
  226|  1.17k|	}																	\
hfile.c:kh_destroy_scheme_string:
  220|      1|	{																	\
  221|      1|		if (h) {														\
  222|      1|			kfree((void *)h->keys); kfree(h->flags);					\
  223|      1|			kfree((void *)h->vals);										\
  224|      1|			kfree(h);													\
  225|      1|		}																\
  226|      1|	}																	\
hfile.c:kh_put_scheme_string:
  312|     37|	{																	\
  313|     37|		khint_t x;														\
  314|     37|		if (h->n_occupied >= h->upper_bound) { /* update the hash table */ \
  315|      5|			if (h->n_buckets > (h->size<<1)) {							\
  316|      0|				if (kh_resize_##name(h, h->n_buckets - 1) < 0) { /* clear "deleted" elements */ \
  317|      0|					*ret = -1; return h->n_buckets;						\
  318|      0|				}														\
  319|      5|			} else if (kh_resize_##name(h, h->n_buckets + 1) < 0) { /* expand the hash table */ \
  320|      0|				*ret = -1; return h->n_buckets;							\
  321|      0|			}															\
  322|      5|		} /* TODO: to implement automatically shrinking; resize() already support shrinking */ \
  323|     37|		{																\
  324|     37|			khint_t k, i, site, last, mask = h->n_buckets - 1, step = 0; \
  325|     37|			x = site = h->n_buckets; k = __hash_func(key); i = k & mask; \
  326|     37|			if (__ac_isempty(h->flags, i)) x = i; /* for speed up */	\
  327|     16|			else {														\
  328|     16|				last = i; \
  329|     44|				while (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i) || !__hash_equal(h->keys[i], key))) { \
  330|     28|					if (__ac_isdel(h->flags, i)) site = i;				\
  331|     28|					i = (i + (++step)) & mask; \
  332|     28|					if (i == last) { x = site; break; }					\
  333|     28|				}														\
  334|     16|				if (x == h->n_buckets) {								\
  335|     16|					if (__ac_isempty(h->flags, i) && site != h->n_buckets) x = site; \
  336|     16|					else x = i;											\
  337|     16|				}														\
  338|     16|			}															\
  339|     37|		}																\
  340|     37|		if (__ac_isempty(h->flags, x)) { /* not present at all */		\
  341|     36|			h->keys[x] = key;											\
  342|     36|			__ac_set_isboth_false(h->flags, x);							\
  343|     36|			++h->size; ++h->n_occupied;									\
  344|     36|			*ret = 1;													\
  345|      1|		} else if (__ac_isdel(h->flags, x)) { /* deleted */				\
  346|      0|			h->keys[x] = key;											\
  347|      0|			__ac_set_isboth_false(h->flags, x);							\
  348|      0|			++h->size;													\
  349|      0|			*ret = 2;													\
  350|      1|		} else *ret = 0; /* Don't touch h->keys[x] if present and not deleted */ \
  351|     37|		return x;														\
  352|     37|	}																	\
hfile.c:kh_resize_scheme_string:
  249|      5|	{ /* This function uses 0.25*n_buckets bytes of working space instead of [sizeof(key_t+val_t)+.25]*n_buckets. */ \
  250|      5|		khint32_t *new_flags = 0;										\
  251|      5|		khint_t j = 1;													\
  252|      5|		{																\
  253|      5|			kroundup32(new_n_buckets); 									\
  254|      5|			if (new_n_buckets < 4) new_n_buckets = 4;					\
  255|      5|			if (h->size >= (khint_t)(new_n_buckets * __ac_HASH_UPPER + 0.5)) j = 0;	/* requested size is too small */ \
  256|      5|			else { /* hash table size to be changed (shrink or expand); rehash */ \
  257|      5|				new_flags = (khint32_t*)kmalloc(__ac_fsize(new_n_buckets) * sizeof(khint32_t));	\
  258|      5|				if (!new_flags) return -1;								\
  259|      5|				memset(new_flags, 0xaa, __ac_fsize(new_n_buckets) * sizeof(khint32_t)); \
  260|      5|				if (h->n_buckets < new_n_buckets) {	/* expand */		\
  261|      5|					khkey_t *new_keys = (khkey_t*)krealloc((void *)h->keys, new_n_buckets * sizeof(khkey_t)); \
  262|      5|					if (!new_keys) { kfree(new_flags); return -1; }		\
  263|      5|					h->keys = new_keys;									\
  264|      5|					if (kh_is_map) {									\
  265|      5|						khval_t *new_vals = (khval_t*)krealloc((void *)h->vals, new_n_buckets * sizeof(khval_t)); \
  266|      5|						if (!new_vals) { kfree(new_flags); return -1; }	\
  267|      5|						h->vals = new_vals;								\
  268|      5|					}													\
  269|      5|				} /* otherwise shrink */								\
  270|      5|			}															\
  271|      5|		}																\
  272|      5|		if (j) { /* rehashing is needed */								\
  273|     65|			for (j = 0; j != h->n_buckets; ++j) {						\
  274|     60|				if (__ac_iseither(h->flags, j) == 0) {					\
  275|     46|					khkey_t key = h->keys[j];							\
  276|     46|					khval_t val;										\
  277|     46|					khint_t new_mask;									\
  278|     46|					new_mask = new_n_buckets - 1; 						\
  279|     46|					if (kh_is_map) val = h->vals[j];					\
  280|     46|					__ac_set_isdel_true(h->flags, j);					\
  281|     46|					while (1) { /* kick-out process; sort of like in Cuckoo hashing */ \
  282|     46|						khint_t k, i, step = 0; \
  283|     46|						k = __hash_func(key);							\
  284|     46|						i = k & new_mask;								\
  285|     51|						while (!__ac_isempty(new_flags, i)) i = (i + (++step)) & new_mask; \
  286|     46|						__ac_set_isempty_false(new_flags, i);			\
  287|     46|						if (i < h->n_buckets && __ac_iseither(h->flags, i) == 0) { /* kick out the existing element */ \
  288|      0|							{ khkey_t tmp = h->keys[i]; h->keys[i] = key; key = tmp; } \
  289|      0|							if (kh_is_map) { khval_t tmp = h->vals[i]; h->vals[i] = val; val = tmp; } \
  290|      0|							__ac_set_isdel_true(h->flags, i); /* mark it as deleted in the old hash table */ \
  291|     46|						} else { /* write the element and jump out of the loop */ \
  292|     46|							h->keys[i] = key;							\
  293|     46|							if (kh_is_map) h->vals[i] = val;			\
  294|     46|							break;										\
  295|     46|						}												\
  296|     46|					}													\
  297|     46|				}														\
  298|     60|			}															\
  299|      5|			if (h->n_buckets > new_n_buckets) { /* shrink the hash table */ \
  300|      0|				h->keys = (khkey_t*)krealloc((void *)h->keys, new_n_buckets * sizeof(khkey_t)); \
  301|      0|				if (kh_is_map) h->vals = (khval_t*)krealloc((void *)h->vals, new_n_buckets * sizeof(khval_t)); \
  302|      0|			}															\
  303|      5|			kfree(h->flags); /* free the working space */				\
  304|      5|			h->flags = new_flags;										\
  305|      5|			h->n_buckets = new_n_buckets;								\
  306|      5|			h->n_occupied = h->size;									\
  307|      5|			h->upper_bound = (khint_t)(h->n_buckets * __ac_HASH_UPPER + 0.5); \
  308|      5|		}																\
  309|      5|		return 0;														\
  310|      5|	}																	\
hfile.c:__ac_X31_hash_string:
  400|    662|{
  401|    662|	khint_t h = (khint_t)*s;
  402|  2.13k|	if (h) for (++s ; *s; ++s) h = (h << 5) - h + (khint_t)*s;
  403|    662|	return h;
  404|    662|}
hfile.c:kh_init_scheme_string:
  216|      1|	SCOPE kh_##name##_t *kh_init_##name(void) {							\
  217|      1|		return (kh_##name##_t*)kcalloc(1, sizeof(kh_##name##_t));		\
  218|      1|	}																	\
hfile.c:kh_get_scheme_string:
  235|    579|	{																	\
  236|    579|		if (h->n_buckets) {												\
  237|    579|			khint_t k, i, last, mask, step = 0; \
  238|    579|			mask = h->n_buckets - 1;									\
  239|    579|			k = __hash_func(key); i = k & mask;							\
  240|    579|			last = i; \
  241|    580|			while (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i) || !__hash_equal(h->keys[i], key))) { \
  242|      1|				i = (i + (++step)) & mask; \
  243|      1|				if (i == last) return h->n_buckets;						\
  244|      1|			}															\
  245|    579|			return __ac_iseither(h->flags, i)? h->n_buckets : i;		\
  246|      0|		} else return 0;												\
  247|    579|	}																	\
kh_init_s2i:
  216|    133|	SCOPE kh_##name##_t *kh_init_##name(void) {							\
  217|    133|		return (kh_##name##_t*)kcalloc(1, sizeof(kh_##name##_t));		\
  218|    133|	}																	\
kh_destroy_s2i:
  220|    143|	{																	\
  221|    143|		if (h) {														\
  222|    133|			kfree((void *)h->keys); kfree(h->flags);					\
  223|    133|			kfree((void *)h->vals);										\
  224|    133|			kfree(h);													\
  225|    133|		}																\
  226|    143|	}																	\
vcf.c:kh_get_vdict:
  235|      7|	{																	\
  236|      7|		if (h->n_buckets) {												\
  237|      0|			khint_t k, i, last, mask, step = 0; \
  238|      0|			mask = h->n_buckets - 1;									\
  239|      0|			k = __hash_func(key); i = k & mask;							\
  240|      0|			last = i; \
  241|      0|			while (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i) || !__hash_equal(h->keys[i], key))) { \
  242|      0|				i = (i + (++step)) & mask; \
  243|      0|				if (i == last) return h->n_buckets;						\
  244|      0|			}															\
  245|      0|			return __ac_iseither(h->flags, i)? h->n_buckets : i;		\
  246|      7|		} else return 0;												\
  247|      7|	}																	\
vcf.c:__ac_X31_hash_string:
  400|      7|{
  401|      7|	khint_t h = (khint_t)*s;
  402|     28|	if (h) for (++s ; *s; ++s) h = (h << 5) - h + (khint_t)*s;
  403|      7|	return h;
  404|      7|}
vcf.c:kh_init_vdict:
  216|     60|	SCOPE kh_##name##_t *kh_init_##name(void) {							\
  217|     60|		return (kh_##name##_t*)kcalloc(1, sizeof(kh_##name##_t));		\
  218|     60|	}																	\
vcf.c:kh_destroy_vdict:
  220|     60|	{																	\
  221|     60|		if (h) {														\
  222|     60|			kfree((void *)h->keys); kfree(h->flags);					\
  223|     60|			kfree((void *)h->vals);										\
  224|     60|			kfree(h);													\
  225|     60|		}																\
  226|     60|	}																	\
vcf.c:kh_put_vdict:
  312|      7|	{																	\
  313|      7|		khint_t x;														\
  314|      7|		if (h->n_occupied >= h->upper_bound) { /* update the hash table */ \
  315|      7|			if (h->n_buckets > (h->size<<1)) {							\
  316|      0|				if (kh_resize_##name(h, h->n_buckets - 1) < 0) { /* clear "deleted" elements */ \
  317|      0|					*ret = -1; return h->n_buckets;						\
  318|      0|				}														\
  319|      7|			} else if (kh_resize_##name(h, h->n_buckets + 1) < 0) { /* expand the hash table */ \
  320|      0|				*ret = -1; return h->n_buckets;							\
  321|      0|			}															\
  322|      7|		} /* TODO: to implement automatically shrinking; resize() already support shrinking */ \
  323|      7|		{																\
  324|      7|			khint_t k, i, site, last, mask = h->n_buckets - 1, step = 0; \
  325|      7|			x = site = h->n_buckets; k = __hash_func(key); i = k & mask; \
  326|      7|			if (__ac_isempty(h->flags, i)) x = i; /* for speed up */	\
  327|      0|			else {														\
  328|      0|				last = i; \
  329|      0|				while (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i) || !__hash_equal(h->keys[i], key))) { \
  330|      0|					if (__ac_isdel(h->flags, i)) site = i;				\
  331|      0|					i = (i + (++step)) & mask; \
  332|      0|					if (i == last) { x = site; break; }					\
  333|      0|				}														\
  334|      0|				if (x == h->n_buckets) {								\
  335|      0|					if (__ac_isempty(h->flags, i) && site != h->n_buckets) x = site; \
  336|      0|					else x = i;											\
  337|      0|				}														\
  338|      0|			}															\
  339|      7|		}																\
  340|      7|		if (__ac_isempty(h->flags, x)) { /* not present at all */		\
  341|      7|			h->keys[x] = key;											\
  342|      7|			__ac_set_isboth_false(h->flags, x);							\
  343|      7|			++h->size; ++h->n_occupied;									\
  344|      7|			*ret = 1;													\
  345|      0|		} else if (__ac_isdel(h->flags, x)) { /* deleted */				\
  346|      0|			h->keys[x] = key;											\
  347|      0|			__ac_set_isboth_false(h->flags, x);							\
  348|      0|			++h->size;													\
  349|      0|			*ret = 2;													\
  350|      0|		} else *ret = 0; /* Don't touch h->keys[x] if present and not deleted */ \
  351|      7|		return x;														\
  352|      7|	}																	\
vcf.c:kh_resize_vdict:
  249|      7|	{ /* This function uses 0.25*n_buckets bytes of working space instead of [sizeof(key_t+val_t)+.25]*n_buckets. */ \
  250|      7|		khint32_t *new_flags = 0;										\
  251|      7|		khint_t j = 1;													\
  252|      7|		{																\
  253|      7|			kroundup32(new_n_buckets); 									\
  254|      7|			if (new_n_buckets < 4) new_n_buckets = 4;					\
  255|      7|			if (h->size >= (khint_t)(new_n_buckets * __ac_HASH_UPPER + 0.5)) j = 0;	/* requested size is too small */ \
  256|      7|			else { /* hash table size to be changed (shrink or expand); rehash */ \
  257|      7|				new_flags = (khint32_t*)kmalloc(__ac_fsize(new_n_buckets) * sizeof(khint32_t));	\
  258|      7|				if (!new_flags) return -1;								\
  259|      7|				memset(new_flags, 0xaa, __ac_fsize(new_n_buckets) * sizeof(khint32_t)); \
  260|      7|				if (h->n_buckets < new_n_buckets) {	/* expand */		\
  261|      7|					khkey_t *new_keys = (khkey_t*)krealloc((void *)h->keys, new_n_buckets * sizeof(khkey_t)); \
  262|      7|					if (!new_keys) { kfree(new_flags); return -1; }		\
  263|      7|					h->keys = new_keys;									\
  264|      7|					if (kh_is_map) {									\
  265|      7|						khval_t *new_vals = (khval_t*)krealloc((void *)h->vals, new_n_buckets * sizeof(khval_t)); \
  266|      7|						if (!new_vals) { kfree(new_flags); return -1; }	\
  267|      7|						h->vals = new_vals;								\
  268|      7|					}													\
  269|      7|				} /* otherwise shrink */								\
  270|      7|			}															\
  271|      7|		}																\
  272|      7|		if (j) { /* rehashing is needed */								\
  273|      7|			for (j = 0; j != h->n_buckets; ++j) {						\
  274|      0|				if (__ac_iseither(h->flags, j) == 0) {					\
  275|      0|					khkey_t key = h->keys[j];							\
  276|      0|					khval_t val;										\
  277|      0|					khint_t new_mask;									\
  278|      0|					new_mask = new_n_buckets - 1; 						\
  279|      0|					if (kh_is_map) val = h->vals[j];					\
  280|      0|					__ac_set_isdel_true(h->flags, j);					\
  281|      0|					while (1) { /* kick-out process; sort of like in Cuckoo hashing */ \
  282|      0|						khint_t k, i, step = 0; \
  283|      0|						k = __hash_func(key);							\
  284|      0|						i = k & new_mask;								\
  285|      0|						while (!__ac_isempty(new_flags, i)) i = (i + (++step)) & new_mask; \
  286|      0|						__ac_set_isempty_false(new_flags, i);			\
  287|      0|						if (i < h->n_buckets && __ac_iseither(h->flags, i) == 0) { /* kick out the existing element */ \
  288|      0|							{ khkey_t tmp = h->keys[i]; h->keys[i] = key; key = tmp; } \
  289|      0|							if (kh_is_map) { khval_t tmp = h->vals[i]; h->vals[i] = val; val = tmp; } \
  290|      0|							__ac_set_isdel_true(h->flags, i); /* mark it as deleted in the old hash table */ \
  291|      0|						} else { /* write the element and jump out of the loop */ \
  292|      0|							h->keys[i] = key;							\
  293|      0|							if (kh_is_map) h->vals[i] = val;			\
  294|      0|							break;										\
  295|      0|						}												\
  296|      0|					}													\
  297|      0|				}														\
  298|      0|			}															\
  299|      7|			if (h->n_buckets > new_n_buckets) { /* shrink the hash table */ \
  300|      0|				h->keys = (khkey_t*)krealloc((void *)h->keys, new_n_buckets * sizeof(khkey_t)); \
  301|      0|				if (kh_is_map) h->vals = (khval_t*)krealloc((void *)h->vals, new_n_buckets * sizeof(khval_t)); \
  302|      0|			}															\
  303|      7|			kfree(h->flags); /* free the working space */				\
  304|      7|			h->flags = new_flags;										\
  305|      7|			h->n_buckets = new_n_buckets;								\
  306|      7|			h->n_occupied = h->size;									\
  307|      7|			h->upper_bound = (khint_t)(h->n_buckets * __ac_HASH_UPPER + 0.5); \
  308|      7|		}																\
  309|      7|		return 0;														\
  310|      7|	}																	\
cram_decode.c:kh_init_map:
  216|      1|	SCOPE kh_##name##_t *kh_init_##name(void) {							\
  217|      1|		return (kh_##name##_t*)kcalloc(1, sizeof(kh_##name##_t));		\
  218|      1|	}																	\
cram_io.c:kh_destroy_refs:
  220|     65|	{																	\
  221|     65|		if (h) {														\
  222|     65|			kfree((void *)h->keys); kfree(h->flags);					\
  223|     65|			kfree((void *)h->vals);										\
  224|     65|			kfree(h);													\
  225|     65|		}																\
  226|     65|	}																	\
cram_io.c:kh_init_refs:
  216|     65|	SCOPE kh_##name##_t *kh_init_##name(void) {							\
  217|     65|		return (kh_##name##_t*)kcalloc(1, sizeof(kh_##name##_t));		\
  218|     65|	}																	\
cram_io.c:kh_destroy_map:
  220|      1|	{																	\
  221|      1|		if (h) {														\
  222|      1|			kfree((void *)h->keys); kfree(h->flags);					\
  223|      1|			kfree((void *)h->vals);										\
  224|      1|			kfree(h);													\
  225|      1|		}																\
  226|      1|	}																	\
cram_io.c:kh_init_m_metrics:
  216|     65|	SCOPE kh_##name##_t *kh_init_##name(void) {							\
  217|     65|		return (kh_##name##_t*)kcalloc(1, sizeof(kh_##name##_t));		\
  218|     65|	}																	\
cram_io.c:kh_destroy_m_metrics:
  220|     65|	{																	\
  221|     65|		if (h) {														\
  222|     65|			kfree((void *)h->keys); kfree(h->flags);					\
  223|     65|			kfree((void *)h->vals);										\
  224|     65|			kfree(h);													\
  225|     65|		}																\
  226|     65|	}																	\
bgzf.c:kh_init_cache:
  216|     31|	SCOPE kh_##name##_t *kh_init_##name(void) {							\
  217|     31|		return (kh_##name##_t*)kcalloc(1, sizeof(kh_##name##_t));		\
  218|     31|	}																	\
bgzf.c:kh_destroy_cache:
  220|     31|	{																	\
  221|     31|		if (h) {														\
  222|     31|			kfree((void *)h->keys); kfree(h->flags);					\
  223|     31|			kfree((void *)h->vals);										\
  224|     31|			kfree(h);													\
  225|     31|		}																\
  226|     31|	}																	\

header.c:kputc_:
  254|     48|{
  255|     48|	if (ks_resize(s, s->l + 1) < 0)
  256|      0|		return EOF;
  257|     48|	s->s[s->l++] = c;
  258|     48|	return 1;
  259|     48|}
header.c:ks_resize:
  149|    386|{
  150|    386|	if (s->m < size) {
  151|    317|	    char *tmp;
  152|    317|	    size = (size > (SIZE_MAX>>2)) ? size : size + (size >> 1);
  153|    317|	    tmp = (char*)realloc(s->s, size);
  154|    317|	    if (!tmp)
  155|      0|	        return -1;
  156|    317|	    s->s = tmp;
  157|    317|	    s->m = size;
  158|    317|	}
  159|    386|	return 0;
  160|    386|}
header.c:kputsn:
  228|    314|{
  229|    314|	size_t new_sz = s->l + l + 2;
  230|    314|	if (new_sz <= s->l || ks_resize(s, new_sz) < 0)
  231|      0|		return EOF;
  232|    314|	memcpy(s->s + s->l, p, l);
  233|    314|	s->l += l;
  234|    314|	s->s[s->l] = 0;
  235|    314|	return l;
  236|    314|}
header.c:kputc:
  245|     24|{
  246|     24|	if (ks_resize(s, s->l + 2) < 0)
  247|      0|		return EOF;
  248|     24|	s->s[s->l++] = c;
  249|     24|	s->s[s->l] = 0;
  250|     24|	return (unsigned char)c;
  251|     24|}
sam.c:ks_release:
  211|    188|{
  212|    188|	char *ss = s->s;
  213|    188|	s->l = s->m = 0;
  214|    188|	s->s = NULL;
  215|    188|	return ss;
  216|    188|}
sam.c:kputll:
  370|  1.29k|{
  371|  1.29k|	char buf[32];
  372|  1.29k|	int i, l = 0;
  373|  1.29k|	unsigned long long x = c;
  374|  1.29k|	if (c < 0) x = -x;
  375|  1.29k|	do { buf[l++] = x%10 + '0'; x /= 10; } while (x > 0);
  376|  1.29k|	if (c < 0) buf[l++] = '-';
  377|  1.29k|	if (ks_resize(s, s->l + l + 2) < 0)
  378|      0|		return EOF;
  379|  2.58k|	for (i = l - 1; i >= 0; --i) s->s[s->l++] = buf[i];
  380|  1.29k|	s->s[s->l] = 0;
  381|  1.29k|	return 0;
  382|  1.29k|}
sam.c:kputsn:
  228|  1.75k|{
  229|  1.75k|	size_t new_sz = s->l + l + 2;
  230|  1.75k|	if (new_sz <= s->l || ks_resize(s, new_sz) < 0)
  231|      0|		return EOF;
  232|  1.75k|	memcpy(s->s + s->l, p, l);
  233|  1.75k|	s->l += l;
  234|  1.75k|	s->s[s->l] = 0;
  235|  1.75k|	return l;
  236|  1.75k|}
sam.c:kputw:
  357|    862|{
  358|    862|    unsigned int x = c;
  359|    862|    if (c < 0) {
  360|      0|        x = -x;
  361|      0|        if (ks_resize(s, s->l + 3) < 0)
  362|      0|            return EOF;
  363|      0|        s->s[s->l++] = '-';
  364|      0|    }
  365|       |
  366|    862|    return kputuw(x, s);
  367|    862|}
sam.c:kputuw:
  272|    862|{
  273|    862|#if HAVE___BUILTIN_CLZ && UINT_MAX == 4294967295U
  274|    862|    static const unsigned int kputuw_num_digits[32] = {
  275|    862|        10, 10, 10,  9,  9,  9,  8,  8,
  276|    862|        8,   7,  7,  7,  7,  6,  6,  6,
  277|    862|        5,   5,  5,  4,  4,  4,  4,  3,
  278|    862|        3,   3,  2,  2,  2,  1,  1,  1
  279|    862|    };
  280|    862|    static const unsigned int kputuw_thresholds[32] = {
  281|    862|        0,        0, 1000000000U, 0,       0, 100000000U,   0,      0,
  282|    862|        10000000, 0,          0,  0, 1000000,         0,    0, 100000,
  283|    862|        0,        0,      10000,  0,       0,         0, 1000,      0,
  284|    862|        0,      100,          0,  0,      10,         0,    0,      0
  285|    862|    };
  286|       |#else
  287|       |    uint64_t m;
  288|       |#endif
  289|    862|    static const char kputuw_dig2r[] =
  290|    862|        "00010203040506070809"
  291|    862|        "10111213141516171819"
  292|    862|        "20212223242526272829"
  293|    862|        "30313233343536373839"
  294|    862|        "40414243444546474849"
  295|    862|        "50515253545556575859"
  296|    862|        "60616263646566676869"
  297|    862|        "70717273747576777879"
  298|    862|        "80818283848586878889"
  299|    862|        "90919293949596979899";
  300|    862|    unsigned int l, j;
  301|    862|    char *cp;
  302|       |
  303|       |    // Trivial case - also prevents __builtin_clz(0), which is undefined
  304|    862|    if (x < 10) {
  305|    849|        if (ks_resize(s, s->l + 2) < 0)
  306|      0|            return EOF;
  307|    849|        s->s[s->l++] = '0'+x;
  308|    849|        s->s[s->l] = 0;
  309|    849|        return 0;
  310|    849|    }
  311|       |
  312|       |    // Find out how many digits are to be printed.
  313|     13|#if HAVE___BUILTIN_CLZ && UINT_MAX == 4294967295U
  314|       |    /*
  315|       |     * Table method - should be quick if clz can be done in hardware.
  316|       |     * Find the most significant bit of the value to print and look
  317|       |     * up in a table to find out how many decimal digits are needed.
  318|       |     * This number needs to be adjusted by 1 for cases where the decimal
  319|       |     * length could vary for a given number of bits (for example,
  320|       |     * a four bit number could be between 8 and 15).
  321|       |     */
  322|       |
  323|     13|    l = __builtin_clz(x);
  324|     13|    l = kputuw_num_digits[l] - (x < kputuw_thresholds[l]);
  325|       |#else
  326|       |    // Fallback for when clz is not available
  327|       |    m = 1;
  328|       |    l = 0;
  329|       |    do {
  330|       |        l++;
  331|       |        m *= 10;
  332|       |    } while (x >= m);
  333|       |#endif
  334|       |
  335|     13|    if (ks_resize(s, s->l + l + 2) < 0)
  336|      0|        return EOF;
  337|       |
  338|       |    // Add digits two at a time
  339|     13|    j = l;
  340|     13|    cp = s->s + s->l;
  341|     26|    while (x >= 10) {
  342|     13|        const char *d = &kputuw_dig2r[2*(x%100)];
  343|     13|        x /= 100;
  344|     13|        memcpy(&cp[j-=2], d, 2);
  345|     13|    }
  346|       |
  347|       |    // Last one (if necessary).  We know that x < 10 by now.
  348|     13|    if (j == 1)
  349|     13|        cp[0] = x + '0';
  350|       |
  351|     13|    s->l += l;
  352|     13|    s->s[s->l] = 0;
  353|     13|    return 0;
  354|     13|}
sam.c:kputc:
  245|    589|{
  246|    589|	if (ks_resize(s, s->l + 2) < 0)
  247|      0|		return EOF;
  248|    589|	s->s[s->l++] = c;
  249|    589|	s->s[s->l] = 0;
  250|    589|	return (unsigned char)c;
  251|    589|}
sam.c:ks_free:
  220|    391|{
  221|    391|    if (s) {
  222|    391|        free(s->s);
  223|    391|        ks_initialize(s);
  224|    391|    }
  225|    391|}
sam.c:ks_initialize:
  142|    391|{
  143|    391|    s->l = s->m = 0;
  144|    391|    s->s = NULL;
  145|    391|}
sam.c:kputsn_:
  262|  1.57k|{
  263|  1.57k|	size_t new_sz = s->l + l;
  264|  1.57k|	if (new_sz < s->l || ks_resize(s, new_sz ? new_sz : 1) < 0)
  265|      0|		return EOF;
  266|  1.57k|	memcpy(s->s + s->l, p, l);
  267|  1.57k|	s->l += l;
  268|  1.57k|	return l;
  269|  1.57k|}
sam.c:kputc_:
  254|  3.44k|{
  255|  3.44k|	if (ks_resize(s, s->l + 1) < 0)
  256|      0|		return EOF;
  257|  3.44k|	s->s[s->l++] = c;
  258|  3.44k|	return 1;
  259|  3.44k|}
sam.c:ks_resize:
  149|  9.66k|{
  150|  9.66k|	if (s->m < size) {
  151|    875|	    char *tmp;
  152|    875|	    size = (size > (SIZE_MAX>>2)) ? size : size + (size >> 1);
  153|    875|	    tmp = (char*)realloc(s->s, size);
  154|    875|	    if (!tmp)
  155|      0|	        return -1;
  156|    875|	    s->s = tmp;
  157|    875|	    s->m = size;
  158|    875|	}
  159|  9.66k|	return 0;
  160|  9.66k|}
vcf.c:kputw:
  357|      7|{
  358|      7|    unsigned int x = c;
  359|      7|    if (c < 0) {
  360|      0|        x = -x;
  361|      0|        if (ks_resize(s, s->l + 3) < 0)
  362|      0|            return EOF;
  363|      0|        s->s[s->l++] = '-';
  364|      0|    }
  365|       |
  366|      7|    return kputuw(x, s);
  367|      7|}
vcf.c:kputuw:
  272|      7|{
  273|      7|#if HAVE___BUILTIN_CLZ && UINT_MAX == 4294967295U
  274|      7|    static const unsigned int kputuw_num_digits[32] = {
  275|      7|        10, 10, 10,  9,  9,  9,  8,  8,
  276|      7|        8,   7,  7,  7,  7,  6,  6,  6,
  277|      7|        5,   5,  5,  4,  4,  4,  4,  3,
  278|      7|        3,   3,  2,  2,  2,  1,  1,  1
  279|      7|    };
  280|      7|    static const unsigned int kputuw_thresholds[32] = {
  281|      7|        0,        0, 1000000000U, 0,       0, 100000000U,   0,      0,
  282|      7|        10000000, 0,          0,  0, 1000000,         0,    0, 100000,
  283|      7|        0,        0,      10000,  0,       0,         0, 1000,      0,
  284|      7|        0,      100,          0,  0,      10,         0,    0,      0
  285|      7|    };
  286|       |#else
  287|       |    uint64_t m;
  288|       |#endif
  289|      7|    static const char kputuw_dig2r[] =
  290|      7|        "00010203040506070809"
  291|      7|        "10111213141516171819"
  292|      7|        "20212223242526272829"
  293|      7|        "30313233343536373839"
  294|      7|        "40414243444546474849"
  295|      7|        "50515253545556575859"
  296|      7|        "60616263646566676869"
  297|      7|        "70717273747576777879"
  298|      7|        "80818283848586878889"
  299|      7|        "90919293949596979899";
  300|      7|    unsigned int l, j;
  301|      7|    char *cp;
  302|       |
  303|       |    // Trivial case - also prevents __builtin_clz(0), which is undefined
  304|      7|    if (x < 10) {
  305|      7|        if (ks_resize(s, s->l + 2) < 0)
  306|      0|            return EOF;
  307|      7|        s->s[s->l++] = '0'+x;
  308|      7|        s->s[s->l] = 0;
  309|      7|        return 0;
  310|      7|    }
  311|       |
  312|       |    // Find out how many digits are to be printed.
  313|      0|#if HAVE___BUILTIN_CLZ && UINT_MAX == 4294967295U
  314|       |    /*
  315|       |     * Table method - should be quick if clz can be done in hardware.
  316|       |     * Find the most significant bit of the value to print and look
  317|       |     * up in a table to find out how many decimal digits are needed.
  318|       |     * This number needs to be adjusted by 1 for cases where the decimal
  319|       |     * length could vary for a given number of bits (for example,
  320|       |     * a four bit number could be between 8 and 15).
  321|       |     */
  322|       |
  323|      0|    l = __builtin_clz(x);
  324|      0|    l = kputuw_num_digits[l] - (x < kputuw_thresholds[l]);
  325|       |#else
  326|       |    // Fallback for when clz is not available
  327|       |    m = 1;
  328|       |    l = 0;
  329|       |    do {
  330|       |        l++;
  331|       |        m *= 10;
  332|       |    } while (x >= m);
  333|       |#endif
  334|       |
  335|      0|    if (ks_resize(s, s->l + l + 2) < 0)
  336|      0|        return EOF;
  337|       |
  338|       |    // Add digits two at a time
  339|      0|    j = l;
  340|      0|    cp = s->s + s->l;
  341|      0|    while (x >= 10) {
  342|      0|        const char *d = &kputuw_dig2r[2*(x%100)];
  343|      0|        x /= 100;
  344|      0|        memcpy(&cp[j-=2], d, 2);
  345|      0|    }
  346|       |
  347|       |    // Last one (if necessary).  We know that x < 10 by now.
  348|      0|    if (j == 1)
  349|      0|        cp[0] = x + '0';
  350|       |
  351|      0|    s->l += l;
  352|      0|    s->s[s->l] = 0;
  353|      0|    return 0;
  354|      0|}
vcf.c:kputc:
  245|     12|{
  246|     12|	if (ks_resize(s, s->l + 2) < 0)
  247|      0|		return EOF;
  248|     12|	s->s[s->l++] = c;
  249|     12|	s->s[s->l] = 0;
  250|     12|	return (unsigned char)c;
  251|     12|}
vcf.c:kputsn:
  228|     12|{
  229|     12|	size_t new_sz = s->l + l + 2;
  230|     12|	if (new_sz <= s->l || ks_resize(s, new_sz) < 0)
  231|      0|		return EOF;
  232|     12|	memcpy(s->s + s->l, p, l);
  233|     12|	s->l += l;
  234|     12|	s->s[s->l] = 0;
  235|     12|	return l;
  236|     12|}
vcf.c:ks_resize:
  149|     31|{
  150|     31|	if (s->m < size) {
  151|     19|	    char *tmp;
  152|     19|	    size = (size > (SIZE_MAX>>2)) ? size : size + (size >> 1);
  153|     19|	    tmp = (char*)realloc(s->s, size);
  154|     19|	    if (!tmp)
  155|      0|	        return -1;
  156|     19|	    s->s = tmp;
  157|     19|	    s->m = size;
  158|     19|	}
  159|     31|	return 0;
  160|     31|}
kstring.c:ks_resize:
  149|    745|{
  150|    745|	if (s->m < size) {
  151|    745|	    char *tmp;
  152|    745|	    size = (size > (SIZE_MAX>>2)) ? size : size + (size >> 1);
  153|    745|	    tmp = (char*)realloc(s->s, size);
  154|    745|	    if (!tmp)
  155|      0|	        return -1;
  156|    745|	    s->s = tmp;
  157|    745|	    s->m = size;
  158|    745|	}
  159|    745|	return 0;
  160|    745|}

sam.c:bam_get_mempolicy:
  956|  1.12k|static inline uint32_t bam_get_mempolicy(bam1_t *b) {
  957|  1.12k|    return b->mempolicy;
  958|  1.12k|}

kvsprintf:
  144|      2|{
  145|      2|	va_list args;
  146|      2|	int l;
  147|      2|	va_copy(args, ap);
  148|       |
  149|      2|	if (fmt[0] == '%' && fmt[1] == 'g' && fmt[2] == 0) {
  150|      0|		double d = va_arg(args, double);
  151|      0|		l = kputd(d, s);
  152|      0|		va_end(args);
  153|      0|		return l;
  154|      0|	}
  155|       |
  156|      2|	if (!s->s) {
  157|      2|		const size_t sz = 64;
  158|      2|		s->s = malloc(sz);
  159|      2|		if (!s->s)
  160|      0|			return -1;
  161|      2|		s->m = sz;
  162|      2|		s->l = 0;
  163|      2|	}
  164|       |
  165|      2|	l = vsnprintf(s->s + s->l, s->m - s->l, fmt, args); // This line does not work with glibc 2.0. See `man snprintf'.
  166|      2|	va_end(args);
  167|      2|	if (l + 1 > s->m - s->l) {
  168|      0|		if (ks_resize(s, s->l + l + 2) < 0)
  169|      0|			return -1;
  170|      0|		va_copy(args, ap);
  171|      0|		l = vsnprintf(s->s + s->l, s->m - s->l, fmt, args);
  172|      0|		va_end(args);
  173|      0|	}
  174|      2|	s->l += l;
  175|      2|	return l;
  176|      2|}
ksprintf:
  179|      2|{
  180|      2|	va_list ap;
  181|      2|	int l;
  182|      2|	va_start(ap, fmt);
  183|      2|	l = kvsprintf(s, fmt, ap);
  184|      2|	va_end(ap);
  185|      2|	return l;
  186|      2|}
kgetline2:
  286|  2.09k|{
  287|  2.09k|	size_t l0 = s->l;
  288|       |
  289|  3.96k|	while (s->l == l0 || s->s[s->l-1] != '\n') {
  290|  2.27k|		if (s->m - s->l < 200) {
  291|       |			// We return EOF for both EOF and error and the caller
  292|       |			// needs to check for errors in fp, and we haven't
  293|       |			// even got there yet.
  294|       |			//
  295|       |			// The only way of propagating memory errors is to
  296|       |			// deliberately call something that we know triggers
  297|       |			// and error so fp is also set.  This works for
  298|       |			// hgets, but not for gets where reading <= 0 bytes
  299|       |			// isn't an error.
  300|    745|			if (ks_resize(s, s->m + 200) < 0) {
  301|      0|				fgets_fn(s->s + s->l, 0, fp);
  302|      0|				return EOF;
  303|      0|			}
  304|  2.27k|		}
  305|  2.27k|		ssize_t len = fgets_fn(s->s + s->l, s->m - s->l, fp);
  306|  2.27k|		if (len <= 0) break;
  307|  1.86k|		s->l += len;
  308|  1.86k|	}
  309|       |
  310|  2.09k|	if (s->l == l0) return EOF;
  311|       |
  312|  1.86k|	if (s->l > l0 && s->s[s->l-1] == '\n') {
  313|  1.69k|		s->l--;
  314|  1.69k|		if (s->l > l0 && s->s[s->l-1] == '\r') s->l--;
  315|  1.69k|	}
  316|  1.86k|	s->s[s->l] = '\0';
  317|  1.86k|	return 0;
  318|  1.86k|}

sam_hdr_init:
  104|    414|{
  105|    414|    sam_hdr_t *bh = (sam_hdr_t*)calloc(1, sizeof(sam_hdr_t));
  106|    414|    if (bh == NULL) return NULL;
  107|       |
  108|    414|    bh->cigar_tab = bam_cigar_table;
  109|    414|    return bh;
  110|    414|}
sam_hdr_destroy:
  113|  1.27k|{
  114|  1.27k|    int32_t i;
  115|       |
  116|  1.27k|    if (bh == NULL) return;
  117|       |
  118|    537|    if (bh->ref_count > 0) {
  119|    123|        --bh->ref_count;
  120|    123|        return;
  121|    123|    }
  122|       |
  123|    414|    if (bh->target_name) {
  124|     75|        for (i = 0; i < bh->n_targets; ++i)
  125|      7|            free(bh->target_name[i]);
  126|     68|        free(bh->target_name);
  127|     68|        free(bh->target_len);
  128|     68|    }
  129|    414|    free(bh->text);
  130|    414|    if (bh->hrecs)
  131|    289|        sam_hrecs_free(bh->hrecs);
  132|    414|    if (bh->sdict)
  133|    414|        kh_destroy(s2i, (khash_t(s2i) *) bh->sdict);
  134|    414|    free(bh);
  135|    414|}
sam_hdr_dup:
  165|     65|{
  166|     65|    if (h0 == NULL) return NULL;
  167|     65|    sam_hdr_t *h;
  168|     65|    if ((h = sam_hdr_init()) == NULL) return NULL;
  169|       |    // copy the simple data
  170|     65|    h->n_targets = 0;
  171|     65|    h->ignore_sam_err = h0->ignore_sam_err;
  172|     65|    h->l_text = 0;
  173|       |
  174|       |    // Then the pointery stuff
  175|       |
  176|     65|    if (!h0->hrecs) {
  177|      0|        h->target_len = (uint32_t*)calloc(h0->n_targets, sizeof(uint32_t));
  178|      0|        if (!h->target_len) goto fail;
  179|      0|        h->target_name = (char**)calloc(h0->n_targets, sizeof(char*));
  180|      0|        if (!h->target_name) goto fail;
  181|       |
  182|      0|        int i;
  183|      0|        for (i = 0; i < h0->n_targets; ++i) {
  184|      0|            h->target_len[i] = h0->target_len[i];
  185|      0|            h->target_name[i] = strdup(h0->target_name[i]);
  186|      0|            if (!h->target_name[i]) break;
  187|      0|        }
  188|      0|        h->n_targets = i;
  189|      0|        if (i < h0->n_targets) goto fail;
  190|       |
  191|      0|        if (h0->sdict) {
  192|      0|            if (sam_hdr_dup_sdict(h0, h) < 0) goto fail;
  193|     65|        }
  194|      0|    }
  195|       |
  196|     65|    if (h0->hrecs) {
  197|     65|        kstring_t tmp = { 0, 0, NULL };
  198|     65|        if (sam_hrecs_rebuild_text(h0->hrecs, &tmp) != 0) {
  199|      0|            free(ks_release(&tmp));
  200|      0|            goto fail;
  201|      0|        }
  202|       |
  203|     65|        h->l_text = tmp.l;
  204|     65|        h->text   = ks_release(&tmp);
  205|       |
  206|     65|        if (sam_hdr_update_target_arrays(h, h0->hrecs, 0) != 0)
  207|      0|            goto fail;
  208|      0|    } else {
  209|      0|        h->l_text = h0->l_text;
  210|      0|        h->text = malloc(h->l_text + 1);
  211|      0|        if (!h->text) goto fail;
  212|      0|        memcpy(h->text, h0->text, h->l_text);
  213|      0|        h->text[h->l_text] = '\0';
  214|      0|    }
  215|       |
  216|     65|    return h;
  217|       |
  218|      0| fail:
  219|      0|    sam_hdr_destroy(h);
  220|      0|    return NULL;
  221|     65|}
bam_hdr_read:
  224|     22|{
  225|     22|    sam_hdr_t *h;
  226|     22|    uint8_t buf[4];
  227|     22|    int magic_len, has_EOF;
  228|     22|    int32_t i, name_len, num_names = 0;
  229|     22|    size_t bufsize;
  230|     22|    ssize_t bytes;
  231|       |    // check EOF
  232|     22|    has_EOF = bgzf_check_EOF(fp);
  233|     22|    if (has_EOF < 0) {
  234|      0|        perror("[W::bam_hdr_read] bgzf_check_EOF");
  235|     22|    } else if (has_EOF == 0) {
  236|     22|        hts_log_warning("EOF marker is absent. The input is probably truncated");
  237|     22|    }
  238|       |    // read "BAM1"
  239|     22|    magic_len = bgzf_read(fp, buf, 4);
  240|     22|    if (magic_len != 4 || memcmp(buf, "BAM\1", 4)) {
  241|      0|        hts_log_error("Invalid BAM binary header");
  242|      0|        return 0;
  243|      0|    }
  244|     22|    h = sam_hdr_init();
  245|     22|    if (!h) goto nomem;
  246|       |
  247|       |    // read plain text and the number of reference sequences
  248|     22|    bytes = bgzf_read(fp, buf, 4);
  249|     22|    if (bytes != 4) goto read_err;
  250|     21|    h->l_text = le_to_u32(buf);
  251|       |
  252|     21|    bufsize = h->l_text + 1;
  253|     21|    if (bufsize < h->l_text) goto nomem; // so large that adding 1 overflowed
  254|     21|    h->text = (char*)malloc(bufsize);
  255|     21|    if (!h->text) goto nomem;
  256|     21|    h->text[h->l_text] = 0; // make sure it is NULL terminated
  257|     21|    bytes = bgzf_read(fp, h->text, h->l_text);
  258|     21|    if (bytes != h->l_text) goto read_err;
  259|       |
  260|     18|    bytes = bgzf_read(fp, &h->n_targets, 4);
  261|     18|    if (bytes != 4) goto read_err;
  262|     17|    if (fp->is_be) ed_swap_4p(&h->n_targets);
  263|       |
  264|     17|    if (h->n_targets < 0) goto invalid;
  265|       |
  266|       |    // read reference sequence names and lengths
  267|     16|    if (h->n_targets > 0) {
  268|      6|        h->target_name = (char**)calloc(h->n_targets, sizeof(char*));
  269|      6|        if (!h->target_name) goto nomem;
  270|      6|        h->target_len = (uint32_t*)calloc(h->n_targets, sizeof(uint32_t));
  271|      6|        if (!h->target_len) goto nomem;
  272|     10|    }
  273|     10|    else {
  274|     10|        h->target_name = NULL;
  275|     10|        h->target_len = NULL;
  276|     10|    }
  277|       |
  278|     20|    for (i = 0; i != h->n_targets; ++i) {
  279|     10|        bytes = bgzf_read(fp, &name_len, 4);
  280|     10|        if (bytes != 4) goto read_err;
  281|      9|        if (fp->is_be) ed_swap_4p(&name_len);
  282|      9|        if (name_len <= 0) goto invalid;
  283|       |
  284|      7|        h->target_name[i] = (char*)malloc(name_len);
  285|      7|        if (!h->target_name[i]) goto nomem;
  286|      7|        num_names++;
  287|       |
  288|      7|        bytes = bgzf_read(fp, h->target_name[i], name_len);
  289|      7|        if (bytes != name_len) goto read_err;
  290|       |
  291|      4|        if (h->target_name[i][name_len - 1] != '\0') {
  292|       |            /* Fix missing NUL-termination.  Is this being too nice?
  293|       |               We could alternatively bail out with an error. */
  294|      1|            char *new_name;
  295|      1|            if (name_len == INT32_MAX) goto invalid;
  296|      1|            new_name = realloc(h->target_name[i], name_len + 1);
  297|      1|            if (new_name == NULL) goto nomem;
  298|      1|            h->target_name[i] = new_name;
  299|      1|            h->target_name[i][name_len] = '\0';
  300|      1|        }
  301|       |
  302|      4|        bytes = bgzf_read(fp, &h->target_len[i], 4);
  303|      4|        if (bytes != 4) goto read_err;
  304|      4|        if (fp->is_be) ed_swap_4p(&h->target_len[i]);
  305|      4|    }
  306|     10|    return h;
  307|       |
  308|      0| nomem:
  309|      0|    hts_log_error("Out of memory");
  310|      0|    goto clean;
  311|       |
  312|      9| read_err:
  313|      9|    if (bytes < 0) {
  314|      0|        hts_log_error("Error reading BGZF stream");
  315|      9|    } else {
  316|      9|        hts_log_error("Truncated BAM header");
  317|      9|    }
  318|      9|    goto clean;
  319|       |
  320|      3| invalid:
  321|      3|    hts_log_error("Invalid BAM binary header");
  322|       |
  323|     12| clean:
  324|     12|    if (h != NULL) {
  325|     12|        h->n_targets = num_names; // ensure we free only allocated target_names
  326|     12|        sam_hdr_destroy(h);
  327|     12|    }
  328|     12|    return NULL;
  329|      3|}
bam_init1:
  408|    324|{
  409|    324|    return (bam1_t*)calloc(1, sizeof(bam1_t));
  410|    324|}
sam_realloc_bam_data:
  413|    152|{
  414|    152|    uint32_t new_m_data;
  415|    152|    uint8_t *new_data;
  416|    152|    new_m_data = desired;
  417|    152|    kroundup32(new_m_data);
  418|    152|    if (new_m_data < desired) {
  419|      0|        errno = ENOMEM; // Not strictly true but we can't store the size
  420|      0|        return -1;
  421|      0|    }
  422|    152|    if ((bam_get_mempolicy(b) & BAM_USER_OWNS_DATA) == 0) {
  423|    152|        new_data = realloc(b->data, new_m_data);
  424|      0|    } else {
  425|      0|        if ((new_data = malloc(new_m_data)) != NULL) {
  426|      0|            if (b->l_data > 0)
  427|      0|                memcpy(new_data, b->data,
  428|      0|                       b->l_data < b->m_data ? b->l_data : b->m_data);
  429|      0|            bam_set_mempolicy(b, bam_get_mempolicy(b) & (~BAM_USER_OWNS_DATA));
  430|      0|        }
  431|      0|    }
  432|    152|    if (!new_data) return -1;
  433|    152|    b->data = new_data;
  434|    152|    b->m_data = new_m_data;
  435|    152|    return 0;
  436|    152|}
bam_destroy1:
  439|    324|{
  440|    324|    if (b == 0) return;
  441|    324|    if ((bam_get_mempolicy(b) & BAM_USER_OWNS_DATA) == 0) {
  442|    324|        free(b->data);
  443|    324|        if ((bam_get_mempolicy(b) & BAM_USER_OWNS_STRUCT) != 0) {
  444|       |            // In case of reuse
  445|      0|            b->data = NULL;
  446|      0|            b->m_data = 0;
  447|      0|            b->l_data = 0;
  448|      0|        }
  449|    324|    }
  450|       |
  451|    324|    if ((bam_get_mempolicy(b) & BAM_USER_OWNS_STRUCT) == 0)
  452|    324|        free(b);
  453|    324|}
bam_set1:
  507|    431|{
  508|       |    // use a default qname "*" if none is provided
  509|    431|    if (l_qname == 0) {
  510|    302|        l_qname = 1;
  511|    302|        qname = "*";
  512|    302|    }
  513|       |
  514|       |    // note: the qname is stored nul terminated and padded as described in the
  515|       |    // documentation for the bam1_t struct.
  516|    431|    size_t qname_nuls = 4 - l_qname % 4;
  517|       |
  518|       |    // the aligment length, needed for bam_reg2bin(), is calculated as in bam_endpos().
  519|       |    // can't use bam_endpos() directly as some fields not yet set up.
  520|    431|    hts_pos_t rlen = 0, qlen = 0;
  521|    431|    if (!(flag & BAM_FUNMAP)) {
  522|      0|        bam_cigar2rqlens((int)n_cigar, cigar, &rlen, &qlen);
  523|      0|    }
  524|    431|    if (rlen == 0) {
  525|    431|        rlen = 1;
  526|    431|    }
  527|       |
  528|       |    // validate parameters
  529|    431|    if (l_qname > 254) {
  530|      0|        hts_log_error("Query name too long");
  531|      0|        errno = EINVAL;
  532|      0|        return -1;
  533|      0|    }
  534|    431|    if (HTS_POS_MAX - rlen <= pos) {
  535|      0|        hts_log_error("Read ends beyond highest supported position");
  536|      0|        errno = EINVAL;
  537|      0|        return -1;
  538|      0|    }
  539|    431|    if (!(flag & BAM_FUNMAP) && l_seq > 0 && n_cigar == 0) {
  540|      0|        hts_log_error("Mapped query must have a CIGAR");
  541|      0|        errno = EINVAL;
  542|      0|        return -1;
  543|      0|    }
  544|    431|    if (!(flag & BAM_FUNMAP) && l_seq > 0 && l_seq != qlen) {
  545|      0|        hts_log_error("CIGAR and query sequence are of different length");
  546|      0|        errno = EINVAL;
  547|      0|        return -1;
  548|      0|    }
  549|       |
  550|    431|    size_t limit = INT32_MAX;
  551|    431|    int u = subtract_check_underflow(l_qname + qname_nuls, &limit);
  552|    431|    u    += subtract_check_underflow(n_cigar * 4, &limit);
  553|    431|    u    += subtract_check_underflow((l_seq + 1) / 2, &limit);
  554|    431|    u    += subtract_check_underflow(l_seq, &limit);
  555|    431|    u    += subtract_check_underflow(l_aux, &limit);
  556|    431|    if (u != 0) {
  557|      0|        hts_log_error("Size overflow");
  558|      0|        errno = EINVAL;
  559|      0|        return -1;
  560|      0|    }
  561|       |
  562|       |    // re-allocate the data buffer as needed.
  563|    431|    size_t data_len = l_qname + qname_nuls + n_cigar * 4 + (l_seq + 1) / 2 + l_seq;
  564|    431|    if (realloc_bam_data(bam, data_len + l_aux) < 0) {
  565|      0|        return -1;
  566|      0|    }
  567|       |
  568|    431|    bam->l_data = (int)data_len;
  569|    431|    bam->core.pos = pos;
  570|    431|    bam->core.tid = tid;
  571|    431|    bam->core.bin = bam_reg2bin(pos, pos + rlen);
  572|    431|    bam->core.qual = mapq;
  573|    431|    bam->core.l_extranul = (uint8_t)(qname_nuls - 1);
  574|    431|    bam->core.flag = flag;
  575|    431|    bam->core.l_qname = (uint16_t)(l_qname + qname_nuls);
  576|    431|    bam->core.n_cigar = (uint32_t)n_cigar;
  577|    431|    bam->core.l_qseq = (int32_t)l_seq;
  578|    431|    bam->core.mtid = mtid;
  579|    431|    bam->core.mpos = mpos;
  580|    431|    bam->core.isize = isize;
  581|       |
  582|    431|    uint8_t *cp = bam->data;
  583|    431|    strncpy((char *)cp, qname, l_qname);
  584|    431|    int i;
  585|  1.61k|    for (i = 0; i < qname_nuls; i++) {
  586|  1.18k|        cp[l_qname + i] = '\0';
  587|  1.18k|    }
  588|    431|    cp += l_qname + qname_nuls;
  589|       |
  590|    431|    if (n_cigar > 0) {
  591|      0|        memcpy(cp, cigar, n_cigar * 4);
  592|      0|    }
  593|    431|    cp += n_cigar * 4;
  594|       |
  595|    776|    for (i = 0; i + 1 < l_seq; i += 2) {
  596|    345|        *cp++ = (seq_nt16_table[(unsigned char)seq[i]] << 4) | seq_nt16_table[(unsigned char)seq[i + 1]];
  597|    345|    }
  598|    495|    for (; i < l_seq; i++) {
  599|     64|        *cp++ = seq_nt16_table[(unsigned char)seq[i]] << 4;
  600|     64|    }
  601|       |
  602|    431|    if (qual) {
  603|      4|        memcpy(cp, qual, l_seq);
  604|      4|    }
  605|    427|    else {
  606|    427|        memset(cp, '\xff', l_seq);
  607|    427|    }
  608|       |
  609|    431|    return (int)data_len;
  610|    431|}
bam_read1:
  730|      9|{
  731|      9|    bam1_core_t *c = &b->core;
  732|      9|    int32_t block_len, ret, i;
  733|      9|    uint32_t x[8], new_l_data;
  734|       |
  735|      9|    b->l_data = 0;
  736|       |
  737|      9|    if ((ret = bgzf_read(fp, &block_len, 4)) != 4) {
  738|      1|        if (ret == 0) return -1; // normal end-of-file
  739|      1|        else return -2; // truncated
  740|      8|    }
  741|      8|    if (fp->is_be)
  742|      0|        ed_swap_4p(&block_len);
  743|      8|    if (block_len < 32) return -4;  // block_len includes core data
  744|      7|    if (bgzf_read(fp, x, 32) != 32) return -3;
  745|      5|    if (fp->is_be) {
  746|      0|        for (i = 0; i < 8; ++i) ed_swap_4p(x + i);
  747|      0|    }
  748|      5|    c->tid = x[0]; c->pos = (int32_t)x[1];
  749|      5|    c->bin = x[2]>>16; c->qual = x[2]>>8&0xff; c->l_qname = x[2]&0xff;
  750|      4|    c->l_extranul = (c->l_qname%4 != 0)? (4 - c->l_qname%4) : 0;
  751|      5|    c->flag = x[3]>>16; c->n_cigar = x[3]&0xffff;
  752|      5|    c->l_qseq = x[4];
  753|      5|    c->mtid = x[5]; c->mpos = (int32_t)x[6]; c->isize = (int32_t)x[7];
  754|       |
  755|      5|    new_l_data = block_len - 32 + c->l_extranul;
  756|      5|    if (new_l_data > INT_MAX || c->l_qseq < 0 || c->l_qname < 1) return -4;
  757|      3|    if (((uint64_t) c->n_cigar << 2) + c->l_qname + c->l_extranul
  758|      3|        + (((uint64_t) c->l_qseq + 1) >> 1) + c->l_qseq > (uint64_t) new_l_data)
  759|      1|        return -4;
  760|      2|    if (realloc_bam_data(b, new_l_data) < 0) return -4;
  761|      2|    b->l_data = new_l_data;
  762|       |
  763|      2|    if (bgzf_read(fp, b->data, c->l_qname) != c->l_qname) return -4;
  764|      1|    if (b->data[c->l_qname - 1] != '\0') { // Try to fix missing NUL termination
  765|      0|        if (fixup_missing_qname_nul(b) < 0) return -4;
  766|      1|    }
  767|      3|    for (i = 0; i < c->l_extranul; ++i) b->data[c->l_qname+i] = '\0';
  768|      1|    c->l_qname += c->l_extranul;
  769|      1|    if (b->l_data < c->l_qname ||
  770|      1|        bgzf_read(fp, b->data + c->l_qname, b->l_data - c->l_qname) != b->l_data - c->l_qname)
  771|      1|        return -4;
  772|      0|    if (fp->is_be) swap_data(c, b->l_data, b->data, 0);
  773|      0|    if (bam_tag2cigar(b, 0, 0) < 0)
  774|      0|        return -4;
  775|       |
  776|      0|    if (c->n_cigar > 0) { // recompute "bin" and check CIGAR-qlen consistency
  777|      0|        hts_pos_t rlen, qlen;
  778|      0|        bam_cigar2rqlens(c->n_cigar, bam_get_cigar(b), &rlen, &qlen);
  779|      0|        if ((b->core.flag & BAM_FUNMAP) || rlen == 0) rlen = 1;
  780|      0|        b->core.bin = hts_reg2bin(b->core.pos, b->core.pos + rlen, 14, 5);
  781|       |        // Sanity check for broken CIGAR alignments
  782|      0|        if (c->l_qseq > 0 && !(c->flag & BAM_FUNMAP) && qlen != c->l_qseq) {
  783|      0|            hts_log_error("CIGAR and query sequence lengths differ for %s",
  784|      0|                    bam_get_qname(b));
  785|      0|            return -4;
  786|      0|        }
  787|      0|    }
  788|       |
  789|      0|    return 4 + block_len;
  790|      0|}
sam_hdr_read:
 2077|    347|{
 2078|    347|    if (!fp) {
 2079|      0|        errno = EINVAL;
 2080|      0|        return NULL;
 2081|      0|    }
 2082|       |
 2083|    347|    switch (fp->format.format) {
 2084|     22|    case bam:
 2085|     22|        return sam_hdr_sanitise(bam_hdr_read(fp->fp.bgzf));
 2086|       |
 2087|     65|    case cram:
 2088|     65|        return sam_hdr_sanitise(sam_hdr_dup(fp->fp.cram->header));
 2089|       |
 2090|    133|    case sam:
 2091|    133|        return sam_hdr_create(fp);
 2092|       |
 2093|     41|    case fastq_format:
 2094|    127|    case fasta_format:
 2095|    127|        return sam_hdr_init();
 2096|       |
 2097|      0|    case empty_format:
 2098|      0|        errno = EPIPE;
 2099|      0|        return NULL;
 2100|       |
 2101|      0|    default:
 2102|      0|        errno = EFTYPE;
 2103|      0|        return NULL;
 2104|    347|    }
 2105|    347|}
sam_hdr_write:
 2108|    324|{
 2109|    324|    if (!fp || !h) {
 2110|      0|        errno = EINVAL;
 2111|      0|        return -1;
 2112|      0|    }
 2113|       |
 2114|    324|    switch (fp->format.format) {
 2115|      0|    case binary_format:
 2116|      0|        fp->format.category = sequence_data;
 2117|      0|        fp->format.format = bam;
 2118|       |        /* fall-through */
 2119|      0|    case bam:
 2120|      0|        if (bam_hdr_write(fp->fp.bgzf, h) < 0) return -1;
 2121|      0|        break;
 2122|       |
 2123|      0|    case cram: {
 2124|      0|        cram_fd *fd = fp->fp.cram;
 2125|      0|        if (cram_set_header2(fd, h) < 0) return -1;
 2126|      0|        if (fp->fn_aux)
 2127|      0|            cram_load_reference(fd, fp->fn_aux);
 2128|      0|        if (cram_write_SAM_hdr(fd, fd->header) < 0) return -1;
 2129|      0|        }
 2130|      0|        break;
 2131|       |
 2132|    324|    case text_format:
 2133|    324|        fp->format.category = sequence_data;
 2134|    324|        fp->format.format = sam;
 2135|       |        /* fall-through */
 2136|    324|    case sam: {
 2137|    324|        if (!h->hrecs && !h->text)
 2138|      0|            return 0;
 2139|    324|        char *text;
 2140|    324|        kstring_t hdr_ks = { 0, 0, NULL };
 2141|    324|        size_t l_text;
 2142|    324|        ssize_t bytes;
 2143|    324|        int r = 0, no_sq = 0;
 2144|       |
 2145|    324|        if (h->hrecs) {
 2146|    222|            if (sam_hrecs_rebuild_text(h->hrecs, &hdr_ks) != 0)
 2147|      0|                return -1;
 2148|    222|            text = hdr_ks.s;
 2149|    222|            l_text = hdr_ks.l;
 2150|    102|        } else {
 2151|    102|            const char *p = NULL;
 2152|    105|            do {
 2153|    102|                const char *q = p == NULL ? h->text : p + 4;
 2154|    105|                p = strstr(q, "@SQ\t");
 2155|    105|            } while (!(p == NULL || p == h->text || *(p - 1) == '\n'));
 2156|    102|            no_sq = p == NULL;
 2157|    102|            text = h->text;
 2158|    102|            l_text = h->l_text;
 2159|    102|        }
 2160|       |
 2161|    324|        if (fp->is_bgzf) {
 2162|      0|            bytes = bgzf_write(fp->fp.bgzf, text, l_text);
 2163|    324|        } else {
 2164|    324|            bytes = hwrite(fp->fp.hfile, text, l_text);
 2165|    324|        }
 2166|    324|        free(hdr_ks.s);
 2167|    324|        if (bytes != l_text)
 2168|      0|            return -1;
 2169|       |
 2170|    324|        if (no_sq) {
 2171|     39|            int i;
 2172|     39|            for (i = 0; i < h->n_targets; ++i) {
 2173|      0|                fp->line.l = 0;
 2174|      0|                r |= kputsn("@SQ\tSN:", 7, &fp->line) < 0;
 2175|      0|                r |= kputs(h->target_name[i], &fp->line) < 0;
 2176|      0|                r |= kputsn("\tLN:", 4, &fp->line) < 0;
 2177|      0|                r |= kputw(h->target_len[i], &fp->line) < 0;
 2178|      0|                r |= kputc('\n', &fp->line) < 0;
 2179|      0|                if (r != 0)
 2180|      0|                    return -1;
 2181|       |
 2182|      0|                if (fp->is_bgzf) {
 2183|      0|                    bytes = bgzf_write(fp->fp.bgzf, fp->line.s, fp->line.l);
 2184|      0|                } else {
 2185|      0|                    bytes = hwrite(fp->fp.hfile, fp->line.s, fp->line.l);
 2186|      0|                }
 2187|      0|                if (bytes != fp->line.l)
 2188|      0|                    return -1;
 2189|      0|            }
 2190|     39|        }
 2191|    324|        if (fp->is_bgzf) {
 2192|      0|            if (bgzf_flush(fp->fp.bgzf) != 0) return -1;
 2193|    324|        } else {
 2194|    324|            if (hflush(fp->fp.hfile) != 0) return -1;
 2195|    324|        }
 2196|    324|        }
 2197|    324|        break;
 2198|       |
 2199|      0|    case fastq_format:
 2200|      0|    case fasta_format:
 2201|       |        // Nothing to output; FASTQ has no file headers.
 2202|      0|        break;
 2203|       |
 2204|      0|    default:
 2205|      0|        errno = EBADF;
 2206|      0|        return -1;
 2207|    324|    }
 2208|    324|    return 0;
 2209|    324|}
sam_parse1:
 2611|     25|{
 2612|     25|#define _read_token(_p) (_p); do { char *tab = strchr((_p), '\t'); if (!tab) goto err_ret; *tab = '\0'; (_p) = tab + 1; } while (0)
 2613|       |
 2614|     25|#if HTS_ALLOW_UNALIGNED != 0 && ULONG_MAX == 0xffffffffffffffff
 2615|       |
 2616|       |// Macro that operates on 64-bits at a time.
 2617|     25|#define COPY_MINUS_N(to,from,n,l,failed)                        \
 2618|     25|    do {                                                        \
 2619|     25|        uint64_u *from8 = (uint64_u *)(from);                   \
 2620|     25|        uint64_u *to8 = (uint64_u *)(to);                       \
 2621|     25|        uint64_t uflow = 0;                                     \
 2622|     25|        size_t l8 = (l)>>3, i;                                  \
 2623|     25|        for (i = 0; i < l8; i++) {                              \
 2624|     25|            to8[i] = from8[i] - (n)*0x0101010101010101UL;       \
 2625|     25|            uflow |= to8[i];                                    \
 2626|     25|        }                                                       \
 2627|     25|        for (i<<=3; i < (l); ++i) {                             \
 2628|     25|            to[i] = from[i] - (n);                              \
 2629|     25|            uflow |= to[i];                                     \
 2630|     25|        }                                                       \
 2631|     25|        failed = (uflow & 0x8080808080808080UL) > 0;            \
 2632|     25|    } while (0)
 2633|       |
 2634|       |#else
 2635|       |
 2636|       |// Basic version which operates a byte at a time
 2637|       |#define COPY_MINUS_N(to,from,n,l,failed) do {                \
 2638|       |        uint8_t uflow = 0;                                   \
 2639|       |        for (i = 0; i < (l); ++i) {                          \
 2640|       |            (to)[i] = (from)[i] - (n);                       \
 2641|       |            uflow |= (uint8_t) (to)[i];                      \
 2642|       |        }                                                    \
 2643|       |        failed = (uflow & 0x80) > 0;                         \
 2644|       |    } while (0)
 2645|       |
 2646|       |#endif
 2647|       |
 2648|     25|#define _get_mem(type_t, x, b, l) if (possibly_expand_bam_data((b), (l)) < 0) goto err_ret; *(x) = (type_t*)((b)->data + (b)->l_data); (b)->l_data += (l)
 2649|     25|#define _parse_err(cond, ...) do { if (cond) { hts_log_error(__VA_ARGS__); goto err_ret; } } while (0)
 2650|     25|#define _parse_warn(cond, ...) do { if (cond) { hts_log_warning(__VA_ARGS__); } } while (0)
 2651|       |
 2652|     25|    uint8_t *t;
 2653|       |
 2654|     25|    char *p = s->s, *q;
 2655|     25|    int i, overflow = 0;
 2656|     25|    char logbuf[40];
 2657|     25|    hts_pos_t cigreflen;
 2658|     25|    bam1_core_t *c = &b->core;
 2659|       |
 2660|     25|    b->l_data = 0;
 2661|     25|    memset(c, 0, 32);
 2662|       |
 2663|       |    // qname
 2664|     25|    q = _read_token(p);
 2665|       |
 2666|     12|    _parse_warn(p - q <= 1, "empty query name");
 2667|     12|    _parse_err(p - q > 255, "query name too long");
 2668|       |    // resize large enough for name + extranul
 2669|     12|    if (possibly_expand_bam_data(b, (p - q) + 4) < 0) goto err_ret;
 2670|     12|    memcpy(b->data + b->l_data, q, p-q); b->l_data += p-q;
 2671|       |
 2672|     12|    c->l_extranul = (4 - (b->l_data & 3)) & 3;
 2673|     12|    memcpy(b->data + b->l_data, "\0\0\0\0", c->l_extranul);
 2674|     12|    b->l_data += c->l_extranul;
 2675|       |
 2676|     12|    c->l_qname = p - q + c->l_extranul;
 2677|       |
 2678|       |    // flag
 2679|     12|    c->flag = parse_sam_flag(p, &p, &overflow);
 2680|     12|    if (*p++ != '\t') goto err_ret; // malformated flag
 2681|       |
 2682|       |    // chr
 2683|      3|    q = _read_token(p);
 2684|      1|    if (strcmp(q, "*")) {
 2685|      1|        _parse_err(h->n_targets == 0, "no SQ lines present in the header");
 2686|      0|        c->tid = bam_name2id(h, q);
 2687|      0|        _parse_err(c->tid < -1, "failed to parse header");
 2688|      0|        _parse_warn(c->tid < 0, "unrecognized reference name %s; treated as unmapped", hts_strprint(logbuf, sizeof logbuf, '"', q, SIZE_MAX));
 2689|      0|    } else c->tid = -1;
 2690|       |
 2691|       |    // pos
 2692|      0|    c->pos = hts_str2uint(p, &p, 63, &overflow) - 1;
 2693|      0|    if (*p++ != '\t') goto err_ret;
 2694|      0|    if (c->pos < 0 && c->tid >= 0) {
 2695|      0|        _parse_warn(1, "mapped query cannot have zero coordinate; treated as unmapped");
 2696|      0|        c->tid = -1;
 2697|      0|    }
 2698|      0|    if (c->tid < 0) c->flag |= BAM_FUNMAP;
 2699|       |
 2700|       |    // mapq
 2701|      0|    c->qual = hts_str2uint(p, &p, 8, &overflow);
 2702|      0|    if (*p++ != '\t') goto err_ret;
 2703|       |    // cigar
 2704|      0|    if (*p != '*') {
 2705|      0|        uint32_t *cigar = NULL;
 2706|      0|        int old_l_data = b->l_data;
 2707|      0|        int n_cigar = bam_parse_cigar(p, &p, b);
 2708|      0|        if (n_cigar < 1 || *p++ != '\t') goto err_ret;
 2709|      0|        cigar = (uint32_t *)(b->data + old_l_data);
 2710|      0|        c->n_cigar = n_cigar;
 2711|       |
 2712|       |        // can't use bam_endpos() directly as some fields not yet set up
 2713|      0|        cigreflen = (!(c->flag&BAM_FUNMAP))? bam_cigar2rlen(c->n_cigar, cigar) : 1;
 2714|      0|        if (cigreflen == 0) cigreflen = 1;
 2715|      0|    } else {
 2716|      0|        _parse_warn(!(c->flag&BAM_FUNMAP), "mapped query must have a CIGAR; treated as unmapped");
 2717|      0|        c->flag |= BAM_FUNMAP;
 2718|      0|        q = _read_token(p);
 2719|      0|        cigreflen = 1;
 2720|      0|    }
 2721|      0|    _parse_err(HTS_POS_MAX - cigreflen <= c->pos,
 2722|      0|               "read ends beyond highest supported position");
 2723|      0|    c->bin = hts_reg2bin(c->pos, c->pos + cigreflen, 14, 5);
 2724|       |    // mate chr
 2725|      0|    q = _read_token(p);
 2726|      0|    if (strcmp(q, "=") == 0) {
 2727|      0|        c->mtid = c->tid;
 2728|      0|    } else if (strcmp(q, "*") == 0) {
 2729|      0|        c->mtid = -1;
 2730|      0|    } else {
 2731|      0|        c->mtid = bam_name2id(h, q);
 2732|      0|        _parse_err(c->mtid < -1, "failed to parse header");
 2733|      0|        _parse_warn(c->mtid < 0, "unrecognized mate reference name %s; treated as unmapped", hts_strprint(logbuf, sizeof logbuf, '"', q, SIZE_MAX));
 2734|      0|    }
 2735|       |    // mpos
 2736|      0|    c->mpos = hts_str2uint(p, &p, 63, &overflow) - 1;
 2737|      0|    if (*p++ != '\t') goto err_ret;
 2738|      0|    if (c->mpos < 0 && c->mtid >= 0) {
 2739|      0|        _parse_warn(1, "mapped mate cannot have zero coordinate; treated as unmapped");
 2740|      0|        c->mtid = -1;
 2741|      0|    }
 2742|       |    // tlen
 2743|      0|    c->isize = hts_str2int(p, &p, 64, &overflow);
 2744|      0|    if (*p++ != '\t') goto err_ret;
 2745|       |    // seq
 2746|      0|    q = _read_token(p);
 2747|      0|    if (strcmp(q, "*")) {
 2748|      0|        _parse_err(p - q - 1 > INT32_MAX, "read sequence is too long");
 2749|      0|        c->l_qseq = p - q - 1;
 2750|      0|        hts_pos_t ql = bam_cigar2qlen(c->n_cigar, (uint32_t*)(b->data + c->l_qname));
 2751|      0|        _parse_err(c->n_cigar && ql != c->l_qseq, "CIGAR and query sequence are of different length");
 2752|      0|        i = (c->l_qseq + 1) >> 1;
 2753|      0|        _get_mem(uint8_t, &t, b, i);
 2754|       |
 2755|      0|        unsigned int lqs2 = c->l_qseq&~1, i;
 2756|      0|        for (i = 0; i < lqs2; i+=2)
 2757|      0|            t[i>>1] = (seq_nt16_table[(unsigned char)q[i]] << 4) | seq_nt16_table[(unsigned char)q[i+1]];
 2758|      0|        for (; i < c->l_qseq; ++i)
 2759|      0|            t[i>>1] = seq_nt16_table[(unsigned char)q[i]] << ((~i&1)<<2);
 2760|      0|    } else c->l_qseq = 0;
 2761|       |    // qual
 2762|      0|    _get_mem(uint8_t, &t, b, c->l_qseq);
 2763|      0|    if (p[0] == '*' && (p[1] == '\t' || p[1] == '\0')) {
 2764|      0|        memset(t, 0xff, c->l_qseq);
 2765|      0|        p += 2;
 2766|      0|    } else {
 2767|      0|        int failed = 0;
 2768|      0|        _parse_err(s->l - (p - s->s) < c->l_qseq
 2769|      0|                   || (p[c->l_qseq] != '\t' && p[c->l_qseq] != '\0'),
 2770|      0|                   "SEQ and QUAL are of different length");
 2771|      0|        COPY_MINUS_N(t, p, 33, c->l_qseq, failed);
 2772|      0|        _parse_err(failed, "invalid QUAL character");
 2773|      0|        p += c->l_qseq + 1;
 2774|      0|    }
 2775|       |
 2776|       |    // aux
 2777|      0|    if (aux_parse(p, s->s + s->l, b, 0, NULL) < 0)
 2778|      0|        goto err_ret;
 2779|       |
 2780|      0|    if (bam_tag2cigar(b, 1, 1) < 0)
 2781|      0|        return -2;
 2782|      0|    return 0;
 2783|       |
 2784|     25|#undef _parse_warn
 2785|     25|#undef _parse_err
 2786|     25|#undef _get_mem
 2787|     25|#undef _read_token
 2788|     25|err_ret:
 2789|     25|    return -2;
 2790|      0|}
sam_state_destroy:
 3021|    457|int sam_state_destroy(htsFile *fp) {
 3022|    457|    int ret = 0;
 3023|       |
 3024|    457|    if (!fp->state)
 3025|    457|        return 0;
 3026|       |
 3027|      0|    SAM_state *fd = fp->state;
 3028|      0|    if (fd->p) {
 3029|      0|        if (fd->h) {
 3030|       |            // Notify sam_dispatcher we're closing
 3031|      0|            pthread_mutex_lock(&fd->command_m);
 3032|      0|            if (fd->command != SAM_CLOSE_DONE)
 3033|      0|                fd->command = SAM_CLOSE;
 3034|      0|            pthread_cond_signal(&fd->command_c);
 3035|      0|            ret = -fd->errcode;
 3036|      0|            if (fd->q)
 3037|      0|                hts_tpool_wake_dispatch(fd->q); // unstick the reader
 3038|       |
 3039|      0|            if (!fp->is_write && fd->q && fd->dispatcher_set) {
 3040|      0|                for (;;) {
 3041|       |                    // Avoid deadlocks with dispatcher
 3042|      0|                    if (fd->command == SAM_CLOSE_DONE)
 3043|      0|                        break;
 3044|      0|                    hts_tpool_wake_dispatch(fd->q);
 3045|      0|                    pthread_mutex_unlock(&fd->command_m);
 3046|      0|                    usleep(10000);
 3047|      0|                    pthread_mutex_lock(&fd->command_m);
 3048|      0|                }
 3049|      0|            }
 3050|      0|            pthread_mutex_unlock(&fd->command_m);
 3051|       |
 3052|      0|            if (fp->is_write) {
 3053|       |                // Dispatch the last partial block.
 3054|      0|                sp_bams *gb = fd->curr_bam;
 3055|      0|                if (!ret && gb && gb->nbams > 0 && fd->q)
 3056|      0|                    ret = hts_tpool_dispatch(fd->p, fd->q, sam_format_worker, gb);
 3057|       |
 3058|       |                // Flush and drain output
 3059|      0|                if (fd->q)
 3060|      0|                    hts_tpool_process_flush(fd->q);
 3061|      0|                pthread_mutex_lock(&fd->command_m);
 3062|      0|                if (!ret) ret = -fd->errcode;
 3063|      0|                pthread_mutex_unlock(&fd->command_m);
 3064|       |
 3065|      0|                while (!ret && fd->q && !hts_tpool_process_empty(fd->q)) {
 3066|      0|                    usleep(10000);
 3067|      0|                    pthread_mutex_lock(&fd->command_m);
 3068|      0|                    ret = -fd->errcode;
 3069|       |                    // not empty but shutdown implies error
 3070|      0|                    if (hts_tpool_process_is_shutdown(fd->q) && !ret)
 3071|      0|                        ret = EIO;
 3072|      0|                    pthread_mutex_unlock(&fd->command_m);
 3073|      0|                }
 3074|      0|                if (fd->q)
 3075|      0|                    hts_tpool_process_shutdown(fd->q);
 3076|      0|            }
 3077|       |
 3078|       |            // Wait for it to acknowledge
 3079|      0|            if (fd->dispatcher_set)
 3080|      0|                pthread_join(fd->dispatcher, NULL);
 3081|      0|            if (!ret) ret = -fd->errcode;
 3082|      0|        }
 3083|       |
 3084|       |        // Tidy up memory
 3085|      0|        if (fd->q)
 3086|      0|            hts_tpool_process_destroy(fd->q);
 3087|       |
 3088|      0|        if (fd->own_pool && fp->format.compression == no_compression) {
 3089|      0|            hts_tpool_destroy(fd->p);
 3090|      0|            fd->p = NULL;
 3091|      0|        }
 3092|      0|        pthread_mutex_destroy(&fd->lines_m);
 3093|      0|        pthread_mutex_destroy(&fd->command_m);
 3094|      0|        pthread_cond_destroy(&fd->command_c);
 3095|       |
 3096|      0|        sp_lines *l = fd->lines;
 3097|      0|        while (l) {
 3098|      0|            sp_lines *n = l->next;
 3099|      0|            free(l->data);
 3100|      0|            free(l);
 3101|      0|            l = n;
 3102|      0|        }
 3103|       |
 3104|      0|        sp_bams *b = fd->bams;
 3105|      0|        while (b) {
 3106|      0|            if (fd->curr_bam == b)
 3107|      0|                fd->curr_bam = NULL;
 3108|      0|            sp_bams *n = b->next;
 3109|      0|            sam_free_sp_bams(b);
 3110|      0|            b = n;
 3111|      0|        }
 3112|       |
 3113|      0|        if (fd->curr_bam)
 3114|      0|            sam_free_sp_bams(fd->curr_bam);
 3115|       |
 3116|       |        // Decrement counter by one, maybe destroying too.
 3117|       |        // This is to permit the caller using bam_hdr_destroy
 3118|       |        // before sam_close without triggering decode errors
 3119|       |        // in the background threads.
 3120|      0|        bam_hdr_destroy(fd->h);
 3121|      0|    }
 3122|       |
 3123|      0|    free(fp->state);
 3124|      0|    fp->state = NULL;
 3125|      0|    return ret;
 3126|      0|}
fastq_state_destroy:
 3653|    127|void fastq_state_destroy(htsFile *fp) {
 3654|    127|    if (fp->state) {
 3655|    127|        fastq_state *x = (fastq_state *)fp->state;
 3656|    127|        if (x->tags)
 3657|    127|            kh_destroy(tag, x->tags);
 3658|    127|        ks_free(&x->name);
 3659|    127|        ks_free(&x->seq);
 3660|    127|        ks_free(&x->qual);
 3661|    127|        free(fp->state);
 3662|    127|    }
 3663|    127|}
sam_read1:
 4015|    755|{
 4016|    755|    int ret, pass_filter;
 4017|       |
 4018|    755|    do {
 4019|    755|        switch (fp->format.format) {
 4020|      9|        case bam:
 4021|      9|            ret = sam_read1_bam(fp, h, b);
 4022|      9|            break;
 4023|       |
 4024|     65|        case cram:
 4025|     65|            ret = sam_read1_cram(fp, h, &b);
 4026|     65|            break;
 4027|       |
 4028|    123|        case sam:
 4029|    123|            ret = sam_read1_sam(fp, h, b);
 4030|    123|            break;
 4031|       |
 4032|    513|        case fasta_format:
 4033|    558|        case fastq_format: {
 4034|    558|            fastq_state *x = (fastq_state *)fp->state;
 4035|    558|            if (!x) {
 4036|    127|                if (!(fp->state = fastq_state_init(fp->format.format
 4037|     86|                                                   == fastq_format ? '@' : '>')))
 4038|      0|                    return -2;
 4039|    558|            }
 4040|       |
 4041|    558|            return fastq_parse1(fp, b);
 4042|    558|        }
 4043|       |
 4044|      0|        case empty_format:
 4045|      0|            errno = EPIPE;
 4046|      0|            return -3;
 4047|       |
 4048|      0|        default:
 4049|      0|            errno = EFTYPE;
 4050|      0|            return -3;
 4051|    197|        }
 4052|       |
 4053|    197|        pass_filter = (ret >= 0 && fp->filter)
 4054|      0|            ? sam_passes_filter(h, b, fp->filter)
 4055|    197|            : 1;
 4056|    197|    } while (pass_filter == 0);
 4057|       |
 4058|    197|    return pass_filter < 0 ? -2 : ret;
 4059|    755|}
sam_format1:
 4147|    431|{
 4148|    431|    str->l = 0;
 4149|    431|    return sam_format1_append(h, b, str);
 4150|    431|}
sam_write1:
 4252|    431|{
 4253|    431|    switch (fp->format.format) {
 4254|      0|    case binary_format:
 4255|      0|        fp->format.category = sequence_data;
 4256|      0|        fp->format.format = bam;
 4257|       |        /* fall-through */
 4258|      0|    case bam:
 4259|      0|        return bam_write_idx1(fp, h, b);
 4260|       |
 4261|      0|    case cram:
 4262|      0|        return cram_put_bam_seq(fp->fp.cram, (bam1_t *)b);
 4263|       |
 4264|      0|    case text_format:
 4265|      0|        fp->format.category = sequence_data;
 4266|      0|        fp->format.format = sam;
 4267|       |        /* fall-through */
 4268|    431|    case sam:
 4269|    431|        if (fp->state) {
 4270|      0|            SAM_state *fd = (SAM_state *)fp->state;
 4271|       |
 4272|       |            // Threaded output
 4273|      0|            if (!fd->h) {
 4274|       |                // NB: discard const.  We don't actually modify sam_hdr_t here,
 4275|       |                // just data pointed to by it (which is a bit weasely still),
 4276|       |                // but out cached pointer must be non-const as we want to
 4277|       |                // destroy it later on and sam_hdr_destroy takes non-const.
 4278|       |                //
 4279|       |                // We do this because some tools do sam_hdr_destroy; sam_close
 4280|       |                // while others do sam_close; sam_hdr_destroy.  The former is
 4281|       |                // an issue as we need the header still when flushing.
 4282|      0|                fd->h = (sam_hdr_t *)h;
 4283|      0|                fd->h->ref_count++;
 4284|       |
 4285|      0|                if (pthread_create(&fd->dispatcher, NULL, sam_dispatcher_write,
 4286|      0|                                   fp) != 0)
 4287|      0|                    return -2;
 4288|      0|                fd->dispatcher_set = 1;
 4289|      0|            }
 4290|       |
 4291|      0|            if (fd->h != h) {
 4292|      0|                hts_log_error("SAM multi-threaded decoding does not support changing header");
 4293|      0|                return -2;
 4294|      0|            }
 4295|       |
 4296|       |            // Find a suitable BAM array to copy to
 4297|      0|            sp_bams *gb = fd->curr_bam;
 4298|      0|            if (!gb) {
 4299|      0|                pthread_mutex_lock(&fd->lines_m);
 4300|      0|                if (fd->bams) {
 4301|      0|                    fd->curr_bam = gb = fd->bams;
 4302|      0|                    fd->bams = gb->next;
 4303|      0|                    gb->next = NULL;
 4304|      0|                    gb->nbams = 0;
 4305|      0|                    pthread_mutex_unlock(&fd->lines_m);
 4306|      0|                } else {
 4307|      0|                    pthread_mutex_unlock(&fd->lines_m);
 4308|      0|                    if (!(gb = calloc(1, sizeof(*gb)))) return -1;
 4309|      0|                    if (!(gb->bams = calloc(NB, sizeof(*gb->bams)))) {
 4310|      0|                        free(gb);
 4311|      0|                        return -1;
 4312|      0|                    }
 4313|      0|                    gb->nbams = 0;
 4314|      0|                    gb->abams = NB;
 4315|      0|                    gb->fd = fd;
 4316|      0|                    fd->curr_idx = 0;
 4317|      0|                    fd->curr_bam = gb;
 4318|      0|                }
 4319|      0|            }
 4320|       |
 4321|      0|            if (!bam_copy1(&gb->bams[gb->nbams++], b))
 4322|      0|                return -2;
 4323|       |
 4324|       |            // Dispatch if full
 4325|      0|            if (gb->nbams == NB) {
 4326|      0|                gb->serial = fd->serial++;
 4327|       |                //fprintf(stderr, "Dispatch another %d bams\n", NB);
 4328|      0|                pthread_mutex_lock(&fd->command_m);
 4329|      0|                if (fd->errcode != 0) {
 4330|      0|                    pthread_mutex_unlock(&fd->command_m);
 4331|      0|                    return -fd->errcode;
 4332|      0|                }
 4333|      0|                if (hts_tpool_dispatch3(fd->p, fd->q, sam_format_worker, gb,
 4334|      0|                                        cleanup_sp_bams,
 4335|      0|                                        cleanup_sp_lines, 0) < 0) {
 4336|      0|                    pthread_mutex_unlock(&fd->command_m);
 4337|      0|                    return -1;
 4338|      0|                }
 4339|      0|                pthread_mutex_unlock(&fd->command_m);
 4340|      0|                fd->curr_bam = NULL;
 4341|      0|            }
 4342|       |
 4343|       |            // Dummy value as we don't know how long it really is.
 4344|       |            // We could track file sizes via a SAM_state field, but I don't think
 4345|       |            // it is necessary.
 4346|      0|            return 1;
 4347|    431|        } else {
 4348|    431|            if (sam_format1(h, b, &fp->line) < 0) return -1;
 4349|    431|            kputc('\n', &fp->line);
 4350|    431|            if (fp->is_bgzf) {
 4351|      0|                if ( bgzf_write(fp->fp.bgzf, fp->line.s, fp->line.l) != fp->line.l ) return -1;
 4352|    431|            } else {
 4353|    431|                if ( hwrite(fp->fp.hfile, fp->line.s, fp->line.l) != fp->line.l ) return -1;
 4354|    431|            }
 4355|       |
 4356|    431|            if (fp->idx) {
 4357|      0|                if (fp->format.compression == bgzf) {
 4358|      0|                    if (bgzf_idx_push(fp->fp.bgzf, fp->idx, b->core.tid, b->core.pos, bam_endpos(b),
 4359|      0|                                      bgzf_tell(fp->fp.bgzf), !(b->core.flag&BAM_FUNMAP)) < 0) {
 4360|      0|                        hts_log_error("Read '%s' with ref_name='%s', ref_length=%"PRIhts_pos", flags=%d, pos=%"PRIhts_pos" cannot be indexed",
 4361|      0|                                bam_get_qname(b), sam_hdr_tid2name(h, b->core.tid), sam_hdr_tid2len(h, b->core.tid), b->core.flag, b->core.pos+1);
 4362|      0|                        return -1;
 4363|      0|                    }
 4364|      0|                } else {
 4365|      0|                    if (hts_idx_push(fp->idx, b->core.tid, b->core.pos, bam_endpos(b),
 4366|      0|                                     bgzf_tell(fp->fp.bgzf), !(b->core.flag&BAM_FUNMAP)) < 0) {
 4367|      0|                        hts_log_error("Read '%s' with ref_name='%s', ref_length=%"PRIhts_pos", flags=%d, pos=%"PRIhts_pos" cannot be indexed",
 4368|      0|                                bam_get_qname(b), sam_hdr_tid2name(h, b->core.tid), sam_hdr_tid2len(h, b->core.tid), b->core.flag, b->core.pos+1);
 4369|      0|                        return -1;
 4370|      0|                    }
 4371|    431|                }
 4372|      0|            }
 4373|       |
 4374|    431|            return fp->line.l;
 4375|    431|        }
 4376|       |
 4377|       |
 4378|      0|    case fasta_format:
 4379|      0|    case fastq_format: {
 4380|      0|        fastq_state *x = (fastq_state *)fp->state;
 4381|      0|        if (!x) {
 4382|      0|            if (!(fp->state = fastq_state_init(fp->format.format
 4383|      0|                                               == fastq_format ? '@' : '>')))
 4384|      0|                return -2;
 4385|      0|        }
 4386|       |
 4387|      0|        if (fastq_format1(fp->state, b, &fp->line) < 0)
 4388|      0|            return -1;
 4389|      0|        if (fp->is_bgzf) {
 4390|      0|            if (bgzf_write(fp->fp.bgzf, fp->line.s, fp->line.l) != fp->line.l)
 4391|      0|                return -1;
 4392|      0|        } else {
 4393|      0|            if (hwrite(fp->fp.hfile, fp->line.s, fp->line.l) != fp->line.l)
 4394|      0|                return -1;
 4395|      0|        }
 4396|      0|        return fp->line.l;
 4397|      0|    }
 4398|       |
 4399|      0|    default:
 4400|      0|        errno = EBADF;
 4401|      0|        return -1;
 4402|    431|    }
 4403|    431|}
sam.c:subtract_check_underflow:
  491|  2.15k|{
  492|  2.15k|    if (length <= *limit) {
  493|  2.15k|        *limit -= length;
  494|  2.15k|        return 0;
  495|  2.15k|    }
  496|       |
  497|      0|    return -1;
  498|      0|}
sam.c:sam_hdr_sanitise:
 1744|    210|static sam_hdr_t *sam_hdr_sanitise(sam_hdr_t *h) {
 1745|    210|    if (!h)
 1746|     12|        return NULL;
 1747|       |
 1748|       |    // Special case for empty headers.
 1749|    198|    if (h->l_text == 0)
 1750|     72|        return h;
 1751|       |
 1752|    126|    size_t i;
 1753|    126|    unsigned int lnum = 0;
 1754|    126|    char *cp = h->text, last = '\n';
 1755|  2.67k|    for (i = 0; i < h->l_text; i++) {
 1756|       |        // NB: l_text excludes terminating nul.  This finds early ones.
 1757|  2.58k|        if (cp[i] == 0)
 1758|     36|            break;
 1759|       |
 1760|       |        // Error on \n[^@], including duplicate newlines
 1761|  2.55k|        if (last == '\n') {
 1762|    143|            lnum++;
 1763|    143|            if (cp[i] != '@') {
 1764|      1|                hts_log_error("Malformed SAM header at line %u", lnum);
 1765|      1|                sam_hdr_destroy(h);
 1766|      1|                return NULL;
 1767|      1|            }
 1768|  2.55k|        }
 1769|       |
 1770|  2.55k|        last = cp[i];
 1771|  2.55k|    }
 1772|       |
 1773|    125|    if (i < h->l_text) { // Early nul found.  Complain if not just padding.
 1774|     36|        size_t j = i;
 1775|    278|        while (j < h->l_text && cp[j] == '\0') j++;
 1776|     36|        if (j < h->l_text)
 1777|     35|            hts_log_warning("Unexpected NUL character in header. Possibly truncated");
 1778|     36|    }
 1779|       |
 1780|       |    // Add trailing newline and/or trailing nul if required.
 1781|    125|    if (last != '\n') {
 1782|     34|        hts_log_warning("Missing trailing newline on SAM header. Possibly truncated");
 1783|       |
 1784|     34|        if (h->l_text < 2 || i >= h->l_text - 2) {
 1785|      1|            if (h->l_text >= SIZE_MAX - 2) {
 1786|      0|                hts_log_error("No room for extra newline");
 1787|      0|                sam_hdr_destroy(h);
 1788|      0|                return NULL;
 1789|      0|            }
 1790|       |
 1791|      1|            cp = realloc(h->text, (size_t) h->l_text+2);
 1792|      1|            if (!cp) {
 1793|      0|                sam_hdr_destroy(h);
 1794|      0|                return NULL;
 1795|      0|            }
 1796|      1|            h->text = cp;
 1797|      1|        }
 1798|     34|        cp[i++] = '\n';
 1799|       |
 1800|       |        // l_text may be larger already due to multiple nul padding
 1801|     34|        if (h->l_text < i)
 1802|      0|            h->l_text = i;
 1803|     34|        cp[h->l_text] = '\0';
 1804|     34|    }
 1805|       |
 1806|    125|    return h;
 1807|    125|}
sam.c:sam_hdr_create:
 1823|    133|static sam_hdr_t *sam_hdr_create(htsFile* fp) {
 1824|    133|    kstring_t str = { 0, 0, NULL };
 1825|    133|    khint_t k;
 1826|    133|    sam_hdr_t* h = sam_hdr_init();
 1827|    133|    const char *q, *r;
 1828|    133|    char* sn = NULL;
 1829|    133|    khash_t(s2i) *d = kh_init(s2i);
 1830|    133|    khash_t(s2i) *long_refs = NULL;
 1831|    133|    if (!h || !d)
 1832|      0|        goto error;
 1833|       |
 1834|    133|    int ret, has_SQ = 0;
 1835|    133|    int next_c = '@';
 1836|    291|    while (next_c == '@' && (ret = hts_getline(fp, KS_SEP_LINE, &fp->line)) >= 0) {
 1837|    168|        if (fp->line.s[0] != '@')
 1838|      0|            break;
 1839|       |
 1840|    168|        if (fp->line.l > 3 && strncmp(fp->line.s, "@SQ", 3) == 0) {
 1841|     68|            has_SQ = 1;
 1842|     68|            hts_pos_t ln = -1;
 1843|    273|            for (q = fp->line.s + 4;; ++q) {
 1844|    273|                if (strncmp(q, "SN:", 3) == 0) {
 1845|     30|                    q += 3;
 1846|    185|                    for (r = q;*r != '\t' && *r != '\n' && *r != '\0';++r);
 1847|       |
 1848|     30|                    if (sn) {
 1849|     14|                        hts_log_warning("SQ header line has more than one SN: tag");
 1850|     14|                        free(sn);
 1851|     14|                    }
 1852|     30|                    sn = (char*)calloc(r - q + 1, 1);
 1853|     30|                    if (!sn)
 1854|      0|                        goto error;
 1855|       |
 1856|     30|                    strncpy(sn, q, r - q);
 1857|     30|                    q = r;
 1858|    243|                } else {
 1859|    243|                    if (strncmp(q, "LN:", 3) == 0)
 1860|     25|                        ln = strtoll(q + 3, (char**)&q, 10);
 1861|    243|                }
 1862|       |
 1863|  1.35k|                while (*q != '\t' && *q != '\n' && *q != '\0')
 1864|  1.08k|                    ++q;
 1865|    273|                if (*q == '\0' || *q == '\n')
 1866|     68|                    break;
 1867|    273|            }
 1868|     68|            if (sn) {
 1869|     16|                if (ln >= 0) {
 1870|      0|                    int absent;
 1871|      0|                    k = kh_put(s2i, d, sn, &absent);
 1872|      0|                    if (absent < 0)
 1873|      0|                        goto error;
 1874|       |
 1875|      0|                    if (!absent) {
 1876|      0|                        hts_log_warning("Duplicated sequence \"%s\" in file \"%s\"", sn, fp->fn);
 1877|      0|                        free(sn);
 1878|      0|                    } else {
 1879|      0|                        sn = NULL;
 1880|      0|                        if (ln >= UINT32_MAX) {
 1881|       |                            // Stash away ref length that
 1882|       |                            // doesn't fit in target_len array
 1883|      0|                            int k2;
 1884|      0|                            if (!long_refs) {
 1885|      0|                                long_refs = kh_init(s2i);
 1886|      0|                                if (!long_refs)
 1887|      0|                                    goto error;
 1888|      0|                            }
 1889|      0|                            k2 = kh_put(s2i, long_refs, kh_key(d, k), &absent);
 1890|      0|                            if (absent < 0)
 1891|      0|                                goto error;
 1892|      0|                            kh_val(long_refs, k2) = ln;
 1893|      0|                            kh_val(d, k) = ((int64_t) (kh_size(d) - 1) << 32
 1894|      0|                                            | UINT32_MAX);
 1895|      0|                        } else {
 1896|      0|                            kh_val(d, k) = (int64_t) (kh_size(d) - 1) << 32 | ln;
 1897|      0|                        }
 1898|      0|                    }
 1899|     16|                } else {
 1900|     16|                    hts_log_warning("Ignored @SQ SN:%s : bad or missing LN tag", sn);
 1901|     16|                    warn_if_known_stderr(fp->line.s);
 1902|     16|                    free(sn);
 1903|     16|                }
 1904|     52|            } else {
 1905|     52|                hts_log_warning("Ignored @SQ line with missing SN: tag");
 1906|     52|                warn_if_known_stderr(fp->line.s);
 1907|     52|            }
 1908|     68|            sn = NULL;
 1909|     68|        }
 1910|    100|        else if (!valid_sam_header_type(fp->line.s)) {
 1911|     10|            hts_log_error("Invalid header line: must start with @HD/@SQ/@RG/@PG/@CO");
 1912|     10|            warn_if_known_stderr(fp->line.s);
 1913|     10|            goto error;
 1914|     10|        }
 1915|       |
 1916|    158|        if (kputsn(fp->line.s, fp->line.l, &str) < 0)
 1917|      0|            goto error;
 1918|       |
 1919|    158|        if (kputc('\n', &str) < 0)
 1920|      0|            goto error;
 1921|       |
 1922|    158|        if (fp->is_bgzf) {
 1923|      0|            next_c = bgzf_peek(fp->fp.bgzf);
 1924|    158|        } else {
 1925|    158|            unsigned char nc;
 1926|    158|            ssize_t pret = hpeek(fp->fp.hfile, &nc, 1);
 1927|     98|            next_c = pret > 0 ? nc : pret - 1;
 1928|    158|        }
 1929|    158|        if (next_c < -1)
 1930|      0|            goto error;
 1931|    158|    }
 1932|    123|    if (next_c != '@')
 1933|    123|        fp->line.l = 0;
 1934|       |
 1935|    123|    if (ret < -1)
 1936|      0|        goto error;
 1937|       |
 1938|    123|    if (!has_SQ && fp->fn_aux) {
 1939|      0|        kstring_t line = { 0, 0, NULL };
 1940|       |
 1941|       |        /* The reference index (.fai) is actually needed here */
 1942|      0|        char *fai_fn = fp->fn_aux;
 1943|      0|        char *fn_delim = strstr(fp->fn_aux, HTS_IDX_DELIM);
 1944|      0|        if (fn_delim)
 1945|      0|            fai_fn = fn_delim + strlen(HTS_IDX_DELIM);
 1946|       |
 1947|      0|        hFILE* f = hopen(fai_fn, "r");
 1948|      0|        int e = 0, absent;
 1949|      0|        if (f == NULL)
 1950|      0|            goto error;
 1951|       |
 1952|      0|        while (line.l = 0, kgetline(&line, (kgets_func*) hgets, f) >= 0) {
 1953|      0|            char* tab = strchr(line.s, '\t');
 1954|      0|            hts_pos_t ln;
 1955|       |
 1956|      0|            if (tab == NULL)
 1957|      0|                continue;
 1958|       |
 1959|      0|            sn = (char*)calloc(tab-line.s+1, 1);
 1960|      0|            if (!sn) {
 1961|      0|                e = 1;
 1962|      0|                break;
 1963|      0|            }
 1964|      0|            memcpy(sn, line.s, tab-line.s);
 1965|      0|            k = kh_put(s2i, d, sn, &absent);
 1966|      0|            if (absent < 0) {
 1967|      0|                e = 1;
 1968|      0|                break;
 1969|      0|            }
 1970|       |
 1971|      0|            ln = strtoll(tab, NULL, 10);
 1972|       |
 1973|      0|            if (!absent) {
 1974|      0|                hts_log_warning("Duplicated sequence \"%s\" in the file \"%s\"", sn, fai_fn);
 1975|      0|                free(sn);
 1976|      0|                sn = NULL;
 1977|      0|            } else {
 1978|      0|                sn = NULL;
 1979|      0|                if (ln >= UINT32_MAX) {
 1980|       |                    // Stash away ref length that
 1981|       |                    // doesn't fit in target_len array
 1982|      0|                    khint_t k2;
 1983|      0|                    int absent = -1;
 1984|      0|                    if (!long_refs) {
 1985|      0|                        long_refs = kh_init(s2i);
 1986|      0|                        if (!long_refs) {
 1987|      0|                            e = 1;
 1988|      0|                            break;
 1989|      0|                        }
 1990|      0|                    }
 1991|      0|                    k2 = kh_put(s2i, long_refs, kh_key(d, k), &absent);
 1992|      0|                    if (absent < 0) {
 1993|      0|                         e = 1;
 1994|      0|                         break;
 1995|      0|                    }
 1996|      0|                    kh_val(long_refs, k2) = ln;
 1997|      0|                    kh_val(d, k) = ((int64_t) (kh_size(d) - 1) << 32
 1998|      0|                                    | UINT32_MAX);
 1999|      0|                } else {
 2000|      0|                    kh_val(d, k) = (int64_t) (kh_size(d) - 1) << 32 | ln;
 2001|      0|                }
 2002|      0|                has_SQ = 1;
 2003|      0|            }
 2004|       |
 2005|      0|            e |= kputs("@SQ\tSN:", &str) < 0;
 2006|      0|            e |= kputsn(line.s, tab - line.s, &str) < 0;
 2007|      0|            e |= kputs("\tLN:", &str) < 0;
 2008|      0|            e |= kputll(ln, &str) < 0;
 2009|      0|            e |= kputc('\n', &str) < 0;
 2010|      0|            if (e)
 2011|      0|                break;
 2012|      0|        }
 2013|       |
 2014|      0|        ks_free(&line);
 2015|      0|        if (hclose(f) != 0) {
 2016|      0|            hts_log_error("Error on closing %s", fai_fn);
 2017|      0|            e = 1;
 2018|      0|        }
 2019|      0|        if (e)
 2020|      0|            goto error;
 2021|    123|    }
 2022|       |
 2023|    123|    if (has_SQ) {
 2024|       |        // Populate the targets array
 2025|     62|        h->n_targets = kh_size(d);
 2026|       |
 2027|     62|        h->target_name = (char**) malloc(sizeof(char*) * h->n_targets);
 2028|     62|        if (!h->target_name) {
 2029|      0|            h->n_targets = 0;
 2030|      0|            goto error;
 2031|      0|        }
 2032|       |
 2033|     62|        h->target_len = (uint32_t*) malloc(sizeof(uint32_t) * h->n_targets);
 2034|     62|        if (!h->target_len) {
 2035|      0|            h->n_targets = 0;
 2036|      0|            goto error;
 2037|      0|        }
 2038|       |
 2039|     62|        for (k = kh_begin(d); k != kh_end(d); ++k) {
 2040|      0|            if (!kh_exist(d, k))
 2041|      0|                continue;
 2042|       |
 2043|      0|            h->target_name[kh_val(d, k) >> 32] = (char*) kh_key(d, k);
 2044|      0|            h->target_len[kh_val(d, k) >> 32] = kh_val(d, k) & 0xffffffffUL;
 2045|      0|            kh_val(d, k) >>= 32;
 2046|      0|        }
 2047|     62|    }
 2048|       |
 2049|       |    // Repurpose sdict to hold any references longer than UINT32_MAX
 2050|    123|    h->sdict = long_refs;
 2051|       |
 2052|    123|    kh_destroy(s2i, d);
 2053|       |
 2054|    123|    if (str.l == 0)
 2055|      0|        kputsn("", 0, &str);
 2056|    123|    h->l_text = str.l;
 2057|    123|    h->text = ks_release(&str);
 2058|    123|    fp->bam_header = sam_hdr_sanitise(h);
 2059|    123|    fp->bam_header->ref_count = 1;
 2060|       |
 2061|    123|    return fp->bam_header;
 2062|       |
 2063|     10| error:
 2064|     10|    if (h && d && (!h->target_name || !h->target_len)) {
 2065|     10|        for (k = kh_begin(d); k != kh_end(d); ++k)
 2066|      0|            if (kh_exist(d, k)) free((void *)kh_key(d, k));
 2067|     10|    }
 2068|     10|    sam_hdr_destroy(h);
 2069|     10|    ks_free(&str);
 2070|     10|    kh_destroy(s2i, d);
 2071|     10|    kh_destroy(s2i, long_refs);
 2072|     10|    if (sn) free(sn);
 2073|     10|    return NULL;
 2074|    123|}
sam.c:warn_if_known_stderr:
 1814|     78|static void warn_if_known_stderr(const char *line) {
 1815|     78|    if (strstr(line, "M::bwa_idx_load_from_disk") != NULL)
 1816|      1|        known_stderr("bwa", "Use `bwa mem -o file.sam ...` or `bwa sampe -f file.sam ...` instead of `bwa ... > file.sam`");
 1817|     77|    else if (strstr(line, "M::mem_pestat") != NULL)
 1818|      1|        known_stderr("bwa", "Use `bwa mem -o file.sam ...` instead of `bwa mem ... > file.sam`");
 1819|     76|    else if (strstr(line, "loaded/built the index") != NULL)
 1820|      1|        known_stderr("minimap2", "Use `minimap2 -o file.sam ...` instead of `minimap2 ... > file.sam`");
 1821|     78|}
sam.c:known_stderr:
 1809|      3|static void known_stderr(const char *tool, const char *advice) {
 1810|      3|    hts_log_warning("SAM file corrupted by embedded %s error/log message", tool);
 1811|      3|    hts_log_warning("%s", advice);
 1812|      3|}
sam.c:valid_sam_header_type:
 1719|    100|static int valid_sam_header_type(const char *s) {
 1720|    100|    if (s[0] != '@') return 0;
 1721|    100|    switch (s[1]) {
 1722|      6|    case 'H':
 1723|      6|        return s[2] == 'D' && s[3] == '\t';
 1724|      2|    case 'S':
 1725|      2|        return s[2] == 'Q' && s[3] == '\t';
 1726|     46|    case 'R':
 1727|     51|    case 'P':
 1728|     51|        return s[2] == 'G' && s[3] == '\t';
 1729|     37|    case 'C':
 1730|     37|        return s[2] == 'O';
 1731|      4|    }
 1732|      4|    return 0;
 1733|      4|}
sam.c:parse_sam_flag:
 2441|     12|static inline unsigned int parse_sam_flag(char *v, char **rv, int *overflow) {
 2442|     12|    if (*v >= '1' && *v <= '9') {
 2443|      4|        return hts_str2uint(v, rv, 16, overflow);
 2444|      4|    }
 2445|      8|    else if (*v == '0') {
 2446|       |        // handle single-digit "0" directly; otherwise it's hex or octal
 2447|      2|        if (v[1] == '\t') { *rv = v+1; return 0; }
 2448|      1|        else {
 2449|      1|            unsigned long val = strtoul(v, rv, 0);
 2450|      1|            if (val > 65535) { *overflow = 1; return 65535; }
 2451|      1|            return val;
 2452|      1|        }
 2453|      6|    }
 2454|      6|    else {
 2455|       |        // TODO implement symbolic flag letters
 2456|      6|        *rv = v;
 2457|      6|        return 0;
 2458|      6|    }
 2459|     12|}
sam.c:fastq_state_init:
 3643|    127|static fastq_state *fastq_state_init(int name_char) {
 3644|    127|    fastq_state *x = (fastq_state *)calloc(1, sizeof(*x));
 3645|    127|    if (!x)
 3646|      0|        return NULL;
 3647|    127|    strcpy(x->BC, "BC");
 3648|    127|    x->nprefix = name_char;
 3649|       |
 3650|    127|    return x;
 3651|    127|}
sam.c:sam_read1_bam:
 3893|      9|static inline int sam_read1_bam(htsFile *fp, sam_hdr_t *h, bam1_t *b) {
 3894|      9|    int ret = bam_read1(fp->fp.bgzf, b);
 3895|      9|    if (h && ret >= 0) {
 3896|      0|        if (b->core.tid  >= h->n_targets || b->core.tid  < -1 ||
 3897|      0|            b->core.mtid >= h->n_targets || b->core.mtid < -1) {
 3898|      0|            errno = ERANGE;
 3899|      0|            return -3;
 3900|      0|        }
 3901|      9|    }
 3902|      9|    return ret;
 3903|      9|}
sam.c:sam_read1_cram:
 3906|     65|static inline int sam_read1_cram(htsFile *fp, sam_hdr_t *h, bam1_t **b) {
 3907|     65|    int ret = cram_get_bam_seq(fp->fp.cram, b);
 3908|     65|    if (ret < 0)
 3909|     65|        return cram_eof(fp->fp.cram) ? -1 : -2;
 3910|       |
 3911|      0|    if (bam_tag2cigar(*b, 1, 1) < 0)
 3912|      0|        return -2;
 3913|       |
 3914|      0|    return ret;
 3915|      0|}
sam.c:sam_read1_sam:
 3918|    123|static inline int sam_read1_sam(htsFile *fp, sam_hdr_t *h, bam1_t *b) {
 3919|    123|    int ret;
 3920|       |
 3921|       |    // Consume 1st line after header parsing as it wasn't using peek
 3922|    123|    if (fp->line.l != 0) {
 3923|      0|        ret = sam_parse1(&fp->line, h, b);
 3924|      0|        fp->line.l = 0;
 3925|      0|        return ret;
 3926|      0|    }
 3927|       |
 3928|    123|    if (fp->state) {
 3929|      0|        SAM_state *fd = (SAM_state *)fp->state;
 3930|       |
 3931|      0|        if (fp->format.compression == bgzf && fp->fp.bgzf->seeked) {
 3932|       |            // We don't support multi-threaded SAM parsing with seeks yet.
 3933|      0|            int ret;
 3934|      0|            if ((ret = sam_state_destroy(fp)) < 0) {
 3935|      0|                errno = -ret;
 3936|      0|                return -2;
 3937|      0|            }
 3938|      0|            if (bgzf_seek(fp->fp.bgzf, fp->fp.bgzf->seeked, SEEK_SET) < 0)
 3939|      0|                return -1;
 3940|      0|            fp->fp.bgzf->seeked = 0;
 3941|      0|            goto err_recover;
 3942|      0|        }
 3943|       |
 3944|      0|        if (!fd->h) {
 3945|      0|            fd->h = h;
 3946|      0|            fd->h->ref_count++;
 3947|       |            // Ensure hrecs is initialised now as we don't want multiple
 3948|       |            // threads trying to do this simultaneously.
 3949|      0|            if (!fd->h->hrecs && sam_hdr_fill_hrecs(fd->h) < 0)
 3950|      0|                return -2;
 3951|       |
 3952|       |            // We can only do this once we've got a header
 3953|      0|            if (pthread_create(&fd->dispatcher, NULL, sam_dispatcher_read,
 3954|      0|                               fp) != 0)
 3955|      0|                return -2;
 3956|      0|            fd->dispatcher_set = 1;
 3957|      0|        }
 3958|       |
 3959|      0|        if (fd->h != h) {
 3960|      0|            hts_log_error("SAM multi-threaded decoding does not support changing header");
 3961|      0|            return -1;
 3962|      0|        }
 3963|       |
 3964|      0|        sp_bams *gb = fd->curr_bam;
 3965|      0|        if (!gb) {
 3966|      0|            if (fd->errcode) {
 3967|       |                // In case reader failed
 3968|      0|                errno = fd->errcode;
 3969|      0|                return -2;
 3970|      0|            }
 3971|      0|            hts_tpool_result *r = hts_tpool_next_result_wait(fd->q);
 3972|      0|            if (!r)
 3973|      0|                return -2;
 3974|      0|            fd->curr_bam = gb = (sp_bams *)hts_tpool_result_data(r);
 3975|      0|            hts_tpool_delete_result(r, 0);
 3976|      0|        }
 3977|      0|        if (!gb)
 3978|      0|            return fd->errcode ? -2 : -1;
 3979|      0|        bam1_t *b_array = (bam1_t *)gb->bams;
 3980|      0|        if (fd->curr_idx < gb->nbams)
 3981|      0|            if (!bam_copy1(b, &b_array[fd->curr_idx++]))
 3982|      0|                return -2;
 3983|      0|        if (fd->curr_idx == gb->nbams) {
 3984|      0|            pthread_mutex_lock(&fd->lines_m);
 3985|      0|            gb->next = fd->bams;
 3986|      0|            fd->bams = gb;
 3987|      0|            pthread_mutex_unlock(&fd->lines_m);
 3988|       |
 3989|      0|            fd->curr_bam = NULL;
 3990|      0|            fd->curr_idx = 0;
 3991|      0|        }
 3992|       |
 3993|      0|        ret = 0;
 3994|       |
 3995|    123|    } else  {
 3996|    123|    err_recover:
 3997|    123|        ret = hts_getline(fp, KS_SEP_LINE, &fp->line);
 3998|    123|        if (ret < 0) return ret;
 3999|       |
 4000|     25|        ret = sam_parse1(&fp->line, h, b);
 4001|     25|        fp->line.l = 0;
 4002|     25|        if (ret < 0) {
 4003|     25|            hts_log_warning("Parse error at line %lld", (long long)fp->lineno);
 4004|     25|            if (h->ignore_sam_err) goto err_recover;
 4005|     25|        }
 4006|     25|    }
 4007|       |
 4008|     25|    return ret;
 4009|     25|}
sam.c:fastq_parse1:
 3731|    558|static int fastq_parse1(htsFile *fp, bam1_t *b) {
 3732|    558|    fastq_state *x = (fastq_state *)fp->state;
 3733|    558|    size_t i, l;
 3734|    558|    int ret = 0;
 3735|       |
 3736|    558|    if (fp->format.format == fasta_format && fp->line.s) {
 3737|       |        // For FASTA we've already read the >name line; steal it
 3738|       |        // Not the most efficient, but we don't optimise for fasta reading.
 3739|    427|        if (fp->line.l == 0)
 3740|     86|            return -1; // EOF
 3741|       |
 3742|    341|        free(x->name.s);
 3743|    341|        x->name = fp->line;
 3744|    341|        fp->line.l = fp->line.m = 0;
 3745|    341|        fp->line.s = NULL;
 3746|    131|    } else {
 3747|       |        // Read a FASTQ format entry.
 3748|    131|        ret = hts_getline(fp, KS_SEP_LINE, &x->name);
 3749|    131|        if (ret == -1)
 3750|      1|            return -1;  // EOF
 3751|    130|        else if (ret < -1)
 3752|      0|            return ret; // ERR
 3753|    471|    }
 3754|       |
 3755|       |    // Name
 3756|       |
 3757|    471|    if (*x->name.s != x->nprefix)
 3758|      3|        return -2;
 3759|       |
 3760|       |    // Reverse the SRA strangeness of putting the run_name.number before
 3761|       |    // the read name.
 3762|    468|    i = 0;
 3763|    468|    char *name = x->name.s+1;
 3764|    468|    if (x->sra_names) {
 3765|      0|        char *cp = strpbrk(x->name.s, " \t");
 3766|      0|        if (cp) {
 3767|      0|            while (*cp == ' ' || *cp == '\t')
 3768|      0|                cp++;
 3769|      0|            *--cp = '@';
 3770|      0|            i = cp - x->name.s;
 3771|      0|            name = cp+1;
 3772|      0|        }
 3773|      0|    }
 3774|       |
 3775|    468|    l = x->name.l;
 3776|    468|    char *s = x->name.s;
 3777|  1.45k|    while (i < l && !isspace_c(s[i]))
 3778|    986|        i++;
 3779|    468|    if (i < l) {
 3780|     48|        s[i] = 0;
 3781|     48|        x->name.l = i++;
 3782|     48|    }
 3783|       |
 3784|       |    // Comment; a kstring struct, but pointer into name line.  (Do not free)
 3785|    568|    while (i < l && isspace_c(s[i]))
 3786|    100|        i++;
 3787|    468|    x->comment.s = s+i;
 3788|    468|    x->comment.l = l - i;
 3789|       |
 3790|       |    // Seq
 3791|    468|    x->seq.l = 0;
 3792|  1.60k|    for (;;) {
 3793|  1.60k|        if ((ret = hts_getline(fp, KS_SEP_LINE, &fp->line)) < 0)
 3794|    116|            if (fp->format.format == fastq_format || ret < -1)
 3795|     30|                return -2;
 3796|  1.57k|        if (*fp->line.s == (fp->format.format == fastq_format ? '+' : '>')
 3797|  1.22k|            || ret == -1)
 3798|    438|            break;
 3799|  1.13k|        if (kputsn(fp->line.s, fp->line.l, &x->seq) < 0)
 3800|      0|            return -2;
 3801|  1.13k|    }
 3802|       |
 3803|       |    // Qual
 3804|    438|    if (fp->format.format == fastq_format) {
 3805|     11|        size_t remainder = x->seq.l;
 3806|     11|        x->qual.l = 0;
 3807|     32|        do {
 3808|     32|            if (hts_getline(fp, KS_SEP_LINE, &fp->line) < 0)
 3809|      6|                return -2;
 3810|     26|            if (fp->line.l > remainder)
 3811|      1|                return -2;
 3812|     25|            if (kputsn(fp->line.s, fp->line.l, &x->qual) < 0)
 3813|      0|                return -2;
 3814|     25|            remainder -= fp->line.l;
 3815|     25|        } while (remainder > 0);
 3816|       |
 3817|       |        // Decr qual
 3818|     51|        for (i = 0; i < x->qual.l; i++)
 3819|     47|            x->qual.s[i] -= '!';
 3820|      4|    }
 3821|       |
 3822|    431|    int flag = BAM_FUNMAP; int pflag = BAM_FMUNMAP | BAM_FPAIRED;
 3823|    431|    if (x->name.l > 2 &&
 3824|    109|        x->name.s[x->name.l-2] == '/' &&
 3825|     52|        isdigit_c(x->name.s[x->name.l-1])) {
 3826|     13|        switch(x->name.s[x->name.l-1]) {
 3827|      0|        case '1': flag |= BAM_FREAD1 | pflag; break;
 3828|      0|        case '2': flag |= BAM_FREAD2 | pflag; break;
 3829|     13|        default : flag |= BAM_FREAD1 | BAM_FREAD2 | pflag; break;
 3830|     13|        }
 3831|     13|        x->name.s[x->name.l-=2] = 0;
 3832|     13|    }
 3833|       |
 3834|       |    // Convert to BAM
 3835|    431|    ret = bam_set1(b,
 3836|    431|                   x->name.s + x->name.l - name, name,
 3837|    431|                   flag,
 3838|    431|                   -1, -1, 0, // ref '*', pos, mapq,
 3839|    431|                   0, NULL,     // no cigar,
 3840|    431|                   -1, -1, 0,    // mate
 3841|    431|                   x->seq.l, x->seq.s, x->qual.s,
 3842|    431|                   0);
 3843|       |
 3844|       |    // Identify Illumina CASAVA strings.
 3845|       |    // <read>:<is_filtered>:<control_bits>:<barcode_sequence>
 3846|    431|    char *barcode = NULL;
 3847|    431|    int barcode_len = 0;
 3848|    431|    kstring_t *kc = &x->comment;
 3849|    431|    char *endptr;
 3850|    431|    if (x->casava &&
 3851|       |        // \d:[YN]:\d+:[ACGTN]+
 3852|      0|        kc->l > 6 && (kc->s[1] | kc->s[3]) == ':' && isdigit_c(kc->s[0]) &&
 3853|      0|        strtol(kc->s+4, &endptr, 10) >= 0 && endptr != kc->s+4
 3854|      0|        && *endptr == ':') {
 3855|       |
 3856|       |        // read num
 3857|      0|        switch(kc->s[0]) {
 3858|      0|        case '1': b->core.flag |= BAM_FREAD1 | pflag; break;
 3859|      0|        case '2': b->core.flag |= BAM_FREAD2 | pflag; break;
 3860|      0|        default : b->core.flag |= BAM_FREAD1 | BAM_FREAD2 | pflag; break;
 3861|      0|        }
 3862|       |
 3863|      0|        if (kc->s[2] == 'Y')
 3864|      0|            b->core.flag |= BAM_FQCFAIL;
 3865|       |
 3866|       |        // Barcode, maybe numeric in which case we skip it
 3867|      0|        if (!isdigit_c(endptr[1])) {
 3868|      0|            barcode = endptr+1;
 3869|      0|            for (i = barcode - kc->s; i < kc->l; i++)
 3870|      0|                if (isspace_c(kc->s[i]))
 3871|      0|                    break;
 3872|       |
 3873|      0|            kc->s[i] = 0;
 3874|      0|            barcode_len = i+1-(barcode - kc->s);
 3875|      0|        }
 3876|      0|    }
 3877|       |
 3878|    431|    if (ret >= 0 && barcode_len)
 3879|      0|        if (bam_aux_append(b, x->BC, 'Z', barcode_len, (uint8_t *)barcode) < 0)
 3880|      0|            ret = -2;
 3881|       |
 3882|    431|    if (!x->aux)
 3883|    431|        return ret;
 3884|       |
 3885|       |    // Identify any SAM style aux tags in comments too.
 3886|      0|    if (aux_parse(&kc->s[barcode_len], kc->s + kc->l, b, 1, x->tags) < 0)
 3887|      0|        ret = -2;
 3888|       |
 3889|      0|    return ret;
 3890|      0|}
sam.c:sam_format1_append:
 4063|    431|{
 4064|    431|    int i, r = 0;
 4065|    431|    uint8_t *s, *end;
 4066|    431|    const bam1_core_t *c = &b->core;
 4067|       |
 4068|    431|    if (c->l_qname == 0)
 4069|      0|        return -1;
 4070|    431|    r |= kputsn_(bam_get_qname(b), c->l_qname-1-c->l_extranul, str);
 4071|    431|    r |= kputc_('\t', str); // query name
 4072|    431|    r |= kputw(c->flag, str); r |= kputc_('\t', str); // flag
 4073|    431|    if (c->tid >= 0) { // chr
 4074|      0|        r |= kputs(h->target_name[c->tid] , str);
 4075|      0|        r |= kputc_('\t', str);
 4076|    431|    } else r |= kputsn_("*\t", 2, str);
 4077|    431|    r |= kputll(c->pos + 1, str); r |= kputc_('\t', str); // pos
 4078|    431|    r |= kputw(c->qual, str); r |= kputc_('\t', str); // qual
 4079|    431|    if (c->n_cigar) { // cigar
 4080|      0|        uint32_t *cigar = bam_get_cigar(b);
 4081|      0|        for (i = 0; i < c->n_cigar; ++i) {
 4082|      0|            r |= kputw(bam_cigar_oplen(cigar[i]), str);
 4083|      0|            r |= kputc_(bam_cigar_opchr(cigar[i]), str);
 4084|      0|        }
 4085|    431|    } else r |= kputc_('*', str);
 4086|    431|    r |= kputc_('\t', str);
 4087|    431|    if (c->mtid < 0) r |= kputsn_("*\t", 2, str); // mate chr
 4088|      0|    else if (c->mtid == c->tid) r |= kputsn_("=\t", 2, str);
 4089|      0|    else {
 4090|      0|        r |= kputs(h->target_name[c->mtid], str);
 4091|      0|        r |= kputc_('\t', str);
 4092|      0|    }
 4093|    431|    r |= kputll(c->mpos + 1, str); r |= kputc_('\t', str); // mate pos
 4094|    431|    r |= kputll(c->isize, str); r |= kputc_('\t', str); // template len
 4095|    431|    if (c->l_qseq) { // seq and qual
 4096|    148|        uint8_t *s = bam_get_seq(b);
 4097|    148|        if (ks_resize(str, str->l+2+2*c->l_qseq) < 0) goto mem_err;
 4098|    148|        char *cp = str->s + str->l;
 4099|       |
 4100|       |        // Sequence, 2 bases at a time
 4101|    148|        nibble2base(s, cp, c->l_qseq);
 4102|    148|        cp[c->l_qseq] = '\t';
 4103|    148|        cp += c->l_qseq+1;
 4104|       |
 4105|       |        // Quality
 4106|    148|        s = bam_get_qual(b);
 4107|    148|        i = 0;
 4108|    148|        if (s[0] == 0xff) {
 4109|    146|            cp[i++] = '*';
 4110|      2|        } else {
 4111|       |            // local copy of c->l_qseq to aid unrolling
 4112|      2|            uint32_t lqseq = c->l_qseq;
 4113|     49|            for (i = 0; i < lqseq; ++i)
 4114|     47|                cp[i]=s[i]+33;
 4115|      2|        }
 4116|    148|        cp[i] = 0;
 4117|    148|        cp += i;
 4118|    148|        str->l = cp - str->s;
 4119|    283|    } else r |= kputsn_("*\t*", 3, str);
 4120|       |
 4121|    431|    s = bam_get_aux(b); // aux
 4122|    431|    end = b->data + b->l_data;
 4123|       |
 4124|    431|    while (end - s >= 4) {
 4125|      0|        r |= kputc_('\t', str);
 4126|      0|        if ((s = (uint8_t *)sam_format_aux1(s, s[2], s+3, end, str)) == NULL)
 4127|      0|            goto bad_aux;
 4128|      0|    }
 4129|    431|    r |= kputsn("", 0, str); // nul terminate
 4130|    431|    if (r < 0) goto mem_err;
 4131|       |
 4132|    431|    return str->l;
 4133|       |
 4134|      0| bad_aux:
 4135|      0|    hts_log_error("Corrupted aux data for read %.*s",
 4136|      0|                  b->core.l_qname, bam_get_qname(b));
 4137|      0|    errno = EINVAL;
 4138|      0|    return -1;
 4139|       |
 4140|      0| mem_err:
 4141|      0|    hts_log_error("Out of memory");
 4142|      0|    errno = ENOMEM;
 4143|      0|    return -1;
 4144|    431|}

sam.c:realloc_bam_data:
   47|    433|{
   48|    433|    if (desired <= b->m_data) return 0;
   49|    140|    return sam_realloc_bam_data(b, desired);
   50|    140|}
sam.c:nibble2base:
   71|    148|static inline void nibble2base(uint8_t *nib, char *seq, int len) {
   72|    148|    static const char code2base[512] =
   73|    148|        "===A=C=M=G=R=S=V=T=W=Y=H=K=D=B=N"
   74|    148|        "A=AAACAMAGARASAVATAWAYAHAKADABAN"
   75|    148|        "C=CACCCMCGCRCSCVCTCWCYCHCKCDCBCN"
   76|    148|        "M=MAMCMMMGMRMSMVMTMWMYMHMKMDMBMN"
   77|    148|        "G=GAGCGMGGGRGSGVGTGWGYGHGKGDGBGN"
   78|    148|        "R=RARCRMRGRRRSRVRTRWRYRHRKRDRBRN"
   79|    148|        "S=SASCSMSGSRSSSVSTSWSYSHSKSDSBSN"
   80|    148|        "V=VAVCVMVGVRVSVVVTVWVYVHVKVDVBVN"
   81|    148|        "T=TATCTMTGTRTSTVTTTWTYTHTKTDTBTN"
   82|    148|        "W=WAWCWMWGWRWSWVWTWWWYWHWKWDWBWN"
   83|    148|        "Y=YAYCYMYGYRYSYVYTYWYYYHYKYDYBYN"
   84|    148|        "H=HAHCHMHGHRHSHVHTHWHYHHHKHDHBHN"
   85|    148|        "K=KAKCKMKGKRKSKVKTKWKYKHKKKDKBKN"
   86|    148|        "D=DADCDMDGDRDSDVDTDWDYDHDKDDDBDN"
   87|    148|        "B=BABCBMBGBRBSBVBTBWBYBHBKBDBBBN"
   88|    148|        "N=NANCNMNGNRNSNVNTNWNYNHNKNDNBNN";
   89|       |
   90|    148|    int i, len2 = len/2;
   91|    148|    seq[0] = 0;
   92|       |
   93|    493|    for (i = 0; i < len2; i++)
   94|       |        // Note size_t cast helps gcc optimiser.
   95|    345|        memcpy(&seq[i*2], &code2base[(size_t)nib[i]*2], 2);
   96|       |
   97|    148|    if ((i *= 2) < len)
   98|     64|        seq[i] = seq_nt16_str[bam_seqi(nib, i)];
   99|    148|}
sam.c:possibly_expand_bam_data:
   52|     12|static inline int possibly_expand_bam_data(bam1_t *b, size_t bytes) {
   53|     12|    size_t new_len = (size_t) b->l_data + bytes;
   54|       |
   55|     12|    if (new_len > INT32_MAX || new_len < bytes) { // Too big or overflow
   56|      0|        errno = ENOMEM;
   57|      0|        return -1;
   58|      0|    }
   59|     12|    if (new_len <= b->m_data) return 0;
   60|     12|    return sam_realloc_bam_data(b, new_len);
   61|     12|}

LLVMFuzzerTestOneInput:
  119|    578|int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  120|    578|    hFILE *memfile;
  121|    578|    uint8_t *copy = malloc(size);
  122|    578|    if (copy == NULL) {
  123|      0|        abort();
  124|      0|    }
  125|    578|    memcpy(copy, data, size);
  126|       |    // hopen does not take ownership of `copy`, but hts_hopen does.
  127|    578|    memfile = hopen("mem:", "rb:", copy, size);
  128|    578|    if (memfile == NULL) {
  129|      0|        free(copy);
  130|      0|        return 0;
  131|      0|    }
  132|       |
  133|    578|    htsFile *ht_file = hts_hopen(memfile, "data", "rb");
  134|    578|    if (ht_file == NULL) {
  135|     85|        if (hclose(memfile) != 0) {
  136|      0|            abort();
  137|      0|        }
  138|     85|        return 0;
  139|     85|    }
  140|    493|    switch (ht_file->format.category) {
  141|    347|        case sequence_data:
  142|    347|            view_sam(ht_file);
  143|    347|            break;
  144|     20|        case variant_data:
  145|     20|            view_vcf(ht_file);
  146|     20|            break;
  147|    126|        default:
  148|    126|            break;
  149|    493|    }
  150|    493|    hts_close(ht_file);
  151|    493|    return 0;
  152|    493|}
hts_open_fuzzer.c:view_sam:
   46|    347|static void view_sam(htsFile *in) {
   47|    347|    if (!in) {
   48|      0|        return;
   49|      0|    }
   50|    347|    samFile *out = sam_open("/dev/null", "w");
   51|    347|    if (!out) {
   52|      0|        abort();
   53|      0|    }
   54|    347|    sam_hdr_t *hdr = sam_hdr_read(in);
   55|    347|    if (hdr == NULL) {
   56|     23|        hts_close_or_abort(out);
   57|     23|        return;
   58|     23|    }
   59|       |
   60|       |    // This will force the header to be parsed.
   61|    324|    (void) sam_hdr_count_lines(hdr, "SQ");
   62|       |
   63|    324|    if (sam_hdr_write(out, hdr) != 0) {
   64|      0|        sam_hdr_destroy(hdr);
   65|      0|        hts_close_or_abort(out);
   66|      0|        return;
   67|      0|    }
   68|    324|    bam1_t *b = bam_init1();
   69|    324|    if (b == NULL) {
   70|      0|        sam_hdr_destroy(hdr);
   71|      0|        hts_close_or_abort(out);
   72|      0|        return;
   73|      0|    }
   74|    755|    while (sam_read1(in, hdr, b) >= 0) {
   75|    431|        if (sam_write1(out, hdr, b) < 0) {
   76|      0|            break;
   77|      0|        }
   78|    431|    }
   79|    324|    bam_destroy1(b);
   80|       |
   81|    324|    sam_hdr_destroy(hdr);
   82|    324|    hts_close_or_abort(out);
   83|    324|}
hts_open_fuzzer.c:hts_close_or_abort:
   40|    367|static void hts_close_or_abort(htsFile* file) {
   41|    367|    if (hts_close(file) != 0) {
   42|      0|        abort();
   43|      0|    }
   44|    367|}
hts_open_fuzzer.c:view_vcf:
   85|     20|static void view_vcf(htsFile *in) {
   86|     20|    if (!in) {
   87|      0|        return;
   88|      0|    }
   89|     20|    vcfFile *out = vcf_open("/dev/null", "w");
   90|     20|    if (!out) {
   91|      0|        abort();
   92|      0|    }
   93|     20|    bcf_hdr_t *hdr = bcf_hdr_read(in);
   94|     20|    if (hdr == NULL) {
   95|     20|        hts_close_or_abort(out);
   96|     20|        return;
   97|     20|    }
   98|       |
   99|      0|    if (bcf_hdr_write(out, hdr) != 0) {
  100|      0|        bcf_hdr_destroy(hdr);
  101|      0|        hts_close_or_abort(out);
  102|      0|    }
  103|      0|    bcf1_t *rec = bcf_init();
  104|      0|    if (rec == NULL) {
  105|      0|        bcf_hdr_destroy(hdr);
  106|      0|        hts_close_or_abort(out);
  107|      0|    }
  108|      0|    while (bcf_read(in, hdr, rec) >= 0) {
  109|      0|        if (bcf_write(out, hdr, rec) < 0) {
  110|      0|            break;
  111|      0|        }
  112|      0|    }
  113|      0|    bcf_destroy(rec);
  114|       |
  115|      0|    bcf_hdr_destroy(hdr);
  116|      0|    hts_close_or_abort(out);
  117|      0|}

header.c:isalpha_c:
  162|    278|static inline int isalpha_c(char c) { return isalpha((unsigned char) c); }
hfile.c:tolower_c:
  171|  1.74k|static inline char tolower_c(char c) { return tolower((unsigned char) c); }
hfile.c:isalnum_c:
  161|  2.68k|static inline int isalnum_c(char c) { return isalnum((unsigned char) c); }
hts.c:isspace_c:
  168|    373|static inline int isspace_c(char c) { return isspace((unsigned char) c); }
hts.c:isdigit_c:
  163|  1.56k|static inline int isdigit_c(char c) { return isdigit((unsigned char) c); }
sam.c:hts_str2uint:
  274|      4|                                      int *failed) {
  275|      4|    uint64_t n = 0, limit = (bits < 64 ? (1ULL << bits) : 0) - 1;
  276|      4|    const unsigned char *v = (const unsigned char *) in;
  277|      4|    const unsigned int ascii_zero = '0'; // Prevents conversion to signed
  278|      4|    uint32_t fast = bits * 1000 / 3322 + 1; // log(10)/log(2) ~= 3.322
  279|      4|    unsigned char d;
  280|       |
  281|      4|    if (*v == '+')
  282|      0|        v++;
  283|       |
  284|     10|    while (--fast && *v>='0' && *v<='9')
  285|      6|        n = n*10 + *v++ - ascii_zero;
  286|       |
  287|      4|    if (!fast) {
  288|      0|        uint64_t limit_d_10 = limit / 10;
  289|      0|        uint64_t limit_m_10 = limit - 10 * limit_d_10;
  290|      0|        while ((d = *v - ascii_zero) < 10) {
  291|      0|            if (n < limit_d_10 || (n == limit_d_10 && d <= limit_m_10)) {
  292|      0|                n = n*10 + d;
  293|      0|                v++;
  294|      0|            } else {
  295|      0|                do { v++; } while (*v - ascii_zero < 10);
  296|      0|                n = limit;
  297|      0|                *failed = 1;
  298|      0|                break;
  299|      0|            }
  300|      0|        }
  301|      0|    }
  302|       |
  303|      4|    *end = (char *)v;
  304|      4|    return n;
  305|      4|}
sam.c:isspace_c:
  168|  1.15k|static inline int isspace_c(char c) { return isspace((unsigned char) c); }
sam.c:isdigit_c:
  163|     52|static inline int isdigit_c(char c) { return isdigit((unsigned char) c); }
vcf.c:isalpha_c:
  162|     14|static inline int isalpha_c(char c) { return isalpha((unsigned char) c); }
vcf.c:isalnum_c:
  161|     91|static inline int isalnum_c(char c) { return isalnum((unsigned char) c); }

bcf_hrec_destroy:
  204|     21|{
  205|     21|    if (!hrec) return;
  206|     21|    free(hrec->key);
  207|     21|    if ( hrec->value ) free(hrec->value);
  208|     21|    int i;
  209|     42|    for (i=0; i<hrec->nkeys; i++)
  210|     21|    {
  211|     21|        free(hrec->keys[i]);
  212|     21|        free(hrec->vals[i]);
  213|     21|    }
  214|     21|    free(hrec->keys);
  215|     21|    free(hrec->vals);
  216|     21|    free(hrec);
  217|     21|}
bcf_hrec_add_key:
  293|     14|{
  294|     14|    char **tmp;
  295|     14|    size_t n = hrec->nkeys + 1;
  296|     14|    assert(len > 0 && len < SIZE_MAX);
  297|     14|    tmp = realloc(hrec->keys, sizeof(char*)*n);
  298|     14|    if (!tmp) return -1;
  299|     14|    hrec->keys = tmp;
  300|     14|    tmp = realloc(hrec->vals, sizeof(char*)*n);
  301|     14|    if (!tmp) return -1;
  302|     14|    hrec->vals = tmp;
  303|       |
  304|     14|    hrec->keys[hrec->nkeys] = (char*) malloc((len+1)*sizeof(char));
  305|     14|    if (!hrec->keys[hrec->nkeys]) return -1;
  306|     14|    memcpy(hrec->keys[hrec->nkeys],str,len);
  307|     14|    hrec->keys[hrec->nkeys][len] = 0;
  308|     14|    hrec->vals[hrec->nkeys] = NULL;
  309|     14|    hrec->nkeys = n;
  310|     14|    return 0;
  311|     14|}
bcf_hrec_set_val:
  314|     14|{
  315|     14|    if ( hrec->vals[i] ) {
  316|      0|        free(hrec->vals[i]);
  317|      0|        hrec->vals[i] = NULL;
  318|      0|    }
  319|     14|    if ( !str ) return 0;
  320|     14|    if ( is_quoted )
  321|      7|    {
  322|      7|        if (len >= SIZE_MAX - 3) {
  323|      0|            errno = ENOMEM;
  324|      0|            return -1;
  325|      0|        }
  326|      7|        hrec->vals[i] = (char*) malloc((len+3)*sizeof(char));
  327|      7|        if (!hrec->vals[i]) return -1;
  328|      7|        hrec->vals[i][0] = '"';
  329|      7|        memcpy(&hrec->vals[i][1],str,len);
  330|      7|        hrec->vals[i][len+1] = '"';
  331|      7|        hrec->vals[i][len+2] = 0;
  332|      7|    }
  333|      7|    else
  334|      7|    {
  335|      7|        if (len == SIZE_MAX) {
  336|      0|            errno = ENOMEM;
  337|      0|            return -1;
  338|      0|        }
  339|      7|        hrec->vals[i] = (char*) malloc((len+1)*sizeof(char));
  340|      7|        if (!hrec->vals[i]) return -1;
  341|      7|        memcpy(hrec->vals[i],str,len);
  342|      7|        hrec->vals[i][len] = 0;
  343|      7|    }
  344|     14|    return 0;
  345|     14|}
hrec_add_idx:
  348|      7|{
  349|      7|    int n = hrec->nkeys + 1;
  350|      7|    char **tmp = (char**) realloc(hrec->keys, sizeof(char*)*n);
  351|      7|    if (!tmp) return -1;
  352|      7|    hrec->keys = tmp;
  353|       |
  354|      7|    tmp = (char**) realloc(hrec->vals, sizeof(char*)*n);
  355|      7|    if (!tmp) return -1;
  356|      7|    hrec->vals = tmp;
  357|       |
  358|      7|    hrec->keys[hrec->nkeys] = strdup("IDX");
  359|      7|    if (!hrec->keys[hrec->nkeys]) return -1;
  360|       |
  361|      7|    kstring_t str = {0,0,0};
  362|      7|    if (kputw(idx, &str) < 0) {
  363|      0|        free(hrec->keys[hrec->nkeys]);
  364|      0|        return -1;
  365|      0|    }
  366|      7|    hrec->vals[hrec->nkeys] = str.s;
  367|      7|    hrec->nkeys = n;
  368|      7|    return 0;
  369|      7|}
bcf_hdr_parse_line:
  387|     28|{
  388|     28|    bcf_hrec_t *hrec = NULL;
  389|     28|    const char *p = line;
  390|     28|    if (p[0] != '#' || p[1] != '#') { *len = 0; return NULL; }
  391|     21|    p += 2;
  392|       |
  393|     21|    const char *q = p;
  394|    203|    while ( *q && *q!='=' && *q != '\n' ) q++;
  395|     21|    ptrdiff_t n = q-p;
  396|     21|    if ( *q!='=' || !n ) // wrong format
  397|      0|        goto malformed_line;
  398|       |
  399|     21|    hrec = (bcf_hrec_t*) calloc(1,sizeof(bcf_hrec_t));
  400|     21|    if (!hrec) { *len = -1; return NULL; }
  401|     21|    hrec->key = (char*) malloc(sizeof(char)*(n+1));
  402|     21|    if (!hrec->key) goto fail;
  403|     21|    memcpy(hrec->key,p,n);
  404|     21|    hrec->key[n] = 0;
  405|       |
  406|     21|    p = ++q;
  407|     21|    if ( *p!='<' ) // generic field, e.g. ##samtoolsVersion=0.1.18-r579
  408|     14|    {
  409|    228|        while ( *q && *q!='\n' ) q++;
  410|     14|        hrec->value = (char*) malloc((q-p+1)*sizeof(char));
  411|     14|        if (!hrec->value) goto fail;
  412|     14|        memcpy(hrec->value, p, q-p);
  413|     14|        hrec->value[q-p] = 0;
  414|     10|        *len = q - line + (*q ? 1 : 0); // Skip \n but not \0
  415|     14|        return hrec;
  416|     14|    }
  417|       |
  418|       |    // structured line, e.g.
  419|       |    // ##INFO=<ID=PV1,Number=1,Type=Float,Description="P-value for baseQ bias">
  420|       |    // ##PEDIGREE=<Name_0=G0-ID,Name_1=G1-ID,Name_3=GN-ID>
  421|      7|    int nopen = 1;
  422|     21|    while ( *q && *q!='\n' && nopen>0 )
  423|     14|    {
  424|     14|        p = ++q;
  425|     14|        while ( *q && *q==' ' ) { p++; q++; }
  426|       |        // ^[A-Za-z_][0-9A-Za-z_.]*$
  427|     14|        if (p==q && *q && (isalpha_c(*q) || *q=='_'))
  428|     14|        {
  429|     14|            q++;
  430|     91|            while ( *q && (isalnum_c(*q) || *q=='_' || *q=='.') ) q++;
  431|     14|        }
  432|     14|        n = q-p;
  433|     14|        int m = 0;
  434|     14|        while ( *q && *q==' ' ) { q++; m++; }
  435|     14|        if ( *q!='=' || !n )
  436|      0|            goto malformed_line;
  437|       |
  438|     14|        if (bcf_hrec_add_key(hrec, p, q-p-m) < 0) goto fail;
  439|     14|        p = ++q;
  440|     14|        while ( *q && *q==' ' ) { p++; q++; }
  441|       |
  442|     14|        int quoted = 0;
  443|     14|        char ending = '\0';
  444|     14|        switch (*p) {
  445|      7|        case '"':
  446|      7|            quoted = 1;
  447|      7|            ending = '"';
  448|      7|            p++;
  449|      7|            break;
  450|      0|        case '[':
  451|      0|            quoted = 1;
  452|      0|            ending = ']';
  453|      0|            break;
  454|     14|        }
  455|     14|        if ( quoted ) q++;
  456|    168|        while ( *q && *q != '\n' )
  457|    168|        {
  458|    168|            if ( quoted ) { if ( *q==ending && !is_escaped(p,q) ) break; }
  459|     35|            else
  460|     35|            {
  461|     35|                if ( *q=='<' ) nopen++;
  462|     35|                if ( *q=='>' ) nopen--;
  463|     35|                if ( !nopen ) break;
  464|     35|                if ( *q==',' && nopen==1 ) break;
  465|    154|            }
  466|    154|            q++;
  467|    154|        }
  468|     14|        const char *r = q;
  469|     14|        if (quoted && ending == ']') {
  470|      0|            if (*q == ending) {
  471|      0|                r++;
  472|      0|                q++;
  473|      0|                quoted = 0;
  474|      0|            } else {
  475|      0|                char buffer[320];
  476|      0|                hts_log_error("Missing ']' in header line %s",
  477|      0|                              hts_strprint(buffer, sizeof(buffer), '"',
  478|      0|                                           line, q-line));
  479|      0|                goto fail;
  480|      0|            }
  481|     14|        }
  482|     14|        while ( r > p && r[-1] == ' ' ) r--;
  483|     14|        if (bcf_hrec_set_val(hrec, hrec->nkeys-1, p, r-p, quoted) < 0)
  484|      0|            goto fail;
  485|     14|        if ( quoted && *q==ending ) q++;
  486|     14|        if ( *q=='>' ) { nopen--; q++; }
  487|     14|    }
  488|       |
  489|       |    // Skip to end of line
  490|      7|    int nonspace = 0;
  491|      7|    p = q;
  492|      7|    while ( *q && *q!='\n' ) { nonspace |= !isspace_c(*q); q++; }
  493|      7|    if (nonspace) {
  494|      0|        char buffer[320];
  495|      0|        hts_log_warning("Dropped trailing junk from header line '%s'",
  496|      0|                        hts_strprint(buffer, sizeof(buffer),
  497|      0|                                     '"', line, q - line));
  498|      0|    }
  499|       |
  500|      7|    *len = q - line + (*q ? 1 : 0);
  501|      7|    return hrec;
  502|       |
  503|      0| fail:
  504|      0|    *len = -1;
  505|      0|    bcf_hrec_destroy(hrec);
  506|      0|    return NULL;
  507|       |
  508|      0| malformed_line:
  509|      0|    {
  510|      0|        char buffer[320];
  511|      0|        while ( *q && *q!='\n' ) q++;  // Ensure *len includes full line
  512|      0|        hts_log_error("Could not parse the header line: %s",
  513|      0|                      hts_strprint(buffer, sizeof(buffer),
  514|      0|                                   '"', line, q - line));
  515|      0|        *len = q - line + (*q ? 1 : 0);
  516|      0|        bcf_hrec_destroy(hrec);
  517|      0|        return NULL;
  518|      7|    }
  519|      7|}
bcf_hdr_add_hrec:
  737|     21|{
  738|     21|    int res;
  739|     21|    if ( !hrec ) return 0;
  740|       |
  741|     21|    hrec->type = BCF_HL_GEN;
  742|     21|    res = bcf_hdr_register_hrec(hdr,hrec);
  743|     21|    if (res < 0) return -1;
  744|     21|    if ( !res )
  745|     14|    {
  746|       |        // If one of the hashed field, then it is already present
  747|     14|        if ( hrec->type != BCF_HL_GEN )
  748|      0|        {
  749|      0|            bcf_hrec_destroy(hrec);
  750|      0|            return 0;
  751|      0|        }
  752|       |
  753|       |        // Is one of the generic fields and already present?
  754|     14|        int i;
  755|     14|        for (i=0; i<hdr->nhrec; i++)
  756|      7|        {
  757|      7|            if ( hdr->hrec[i]->type!=BCF_HL_GEN ) continue;
  758|      7|            if ( !strcmp(hdr->hrec[i]->key,hrec->key) && !strcmp(hrec->key,"fileformat") ) break;
  759|      0|            if ( !strcmp(hdr->hrec[i]->key,hrec->key) && !strcmp(hdr->hrec[i]->value,hrec->value) ) break;
  760|      0|        }
  761|     14|        if ( i<hdr->nhrec )
  762|      7|        {
  763|      7|            bcf_hrec_destroy(hrec);
  764|      7|            return 0;
  765|      7|        }
  766|     14|    }
  767|       |
  768|       |    // New record, needs to be added
  769|     14|    int n = hdr->nhrec + 1;
  770|     14|    bcf_hrec_t **new_hrec = realloc(hdr->hrec, n*sizeof(bcf_hrec_t*));
  771|     14|    if (!new_hrec) return -1;
  772|     14|    hdr->hrec = new_hrec;
  773|     14|    hdr->hrec[hdr->nhrec] = hrec;
  774|     14|    hdr->dirty = 1;
  775|     14|    hdr->nhrec = n;
  776|       |
  777|     14|    return hrec->type==BCF_HL_GEN ? 0 : 1;
  778|     14|}
bcf_hdr_parse:
  841|      7|{
  842|      7|    int len, done = 0;
  843|      7|    char *p = htxt;
  844|       |
  845|       |    // Check sanity: "fileformat" string must come as first
  846|      7|    bcf_hrec_t *hrec = bcf_hdr_parse_line(hdr,p,&len);
  847|      7|    if ( !hrec || !hrec->key || strcasecmp(hrec->key,"fileformat") )
  848|      0|        hts_log_warning("The first line should be ##fileformat; is the VCF/BCF header broken?");
  849|      7|    if (bcf_hdr_add_hrec(hdr, hrec) < 0) {
  850|      0|        bcf_hrec_destroy(hrec);
  851|      0|        return -1;
  852|      0|    }
  853|       |
  854|       |    // The filter PASS must appear first in the dictionary
  855|      7|    hrec = bcf_hdr_parse_line(hdr,"##FILTER=<ID=PASS,Description=\"All filters passed\">",&len);
  856|      7|    if (!hrec || bcf_hdr_add_hrec(hdr, hrec) < 0) {
  857|      0|        bcf_hrec_destroy(hrec);
  858|      0|        return -1;
  859|      0|    }
  860|       |
  861|       |    // Parse the whole header
  862|      7|    do {
  863|     14|        while (NULL != (hrec = bcf_hdr_parse_line(hdr, p, &len))) {
  864|      7|            if (bcf_hdr_add_hrec(hdr, hrec) < 0) {
  865|      0|                bcf_hrec_destroy(hrec);
  866|      0|                return -1;
  867|      0|            }
  868|      7|            p += len;
  869|      7|        }
  870|      7|        assert(hrec == NULL);
  871|      7|        if (len < 0) {
  872|       |            // len < 0 indicates out-of-memory, or similar error
  873|      0|            hts_log_error("Could not parse header line: %s", strerror(errno));
  874|      0|            return -1;
  875|      7|        } else if (len > 0) {
  876|       |            // Bad header line.  bcf_hdr_parse_line() will have logged it.
  877|       |            // Skip and try again on the next line (p + len will be the start
  878|       |            // of the next one).
  879|      0|            p += len;
  880|      0|            continue;
  881|      0|        }
  882|       |
  883|       |        // Next should be the sample line.  If not, it was a malformed
  884|       |        // header, in which case print a warning and skip (many VCF
  885|       |        // operations do not really care about a few malformed lines).
  886|       |        // In the future we may want to add a strict mode that errors in
  887|       |        // this case.
  888|      7|        if ( strncmp("#CHROM\t",p,7) && strncmp("#CHROM ",p,7) ) {
  889|      7|            char *eol = strchr(p, '\n');
  890|      7|            if (*p != '\0') {
  891|      0|                char buffer[320];
  892|      0|                hts_log_warning("Could not parse header line: %s",
  893|      0|                                hts_strprint(buffer, sizeof(buffer),
  894|      0|                                               '"', p,
  895|      0|                                               eol ? (eol - p) : SIZE_MAX));
  896|      0|            }
  897|      7|            if (eol) {
  898|      0|                p = eol + 1; // Try from the next line.
  899|      7|            } else {
  900|      7|                done = -1; // No more lines left, give up.
  901|      7|            }
  902|      0|        } else {
  903|      0|            done = 1; // Sample line found
  904|      0|        }
  905|      7|    } while (!done);
  906|       |
  907|      7|    if (done < 0) {
  908|       |        // No sample line is fatal.
  909|      7|        hts_log_error("Could not parse the header, sample line not found");
  910|      7|        return -1;
  911|      7|    }
  912|       |
  913|      0|    if (bcf_hdr_parse_sample_line(hdr,p) < 0)
  914|      0|        return -1;
  915|      0|    if (bcf_hdr_sync(hdr) < 0)
  916|      0|        return -1;
  917|      0|    bcf_hdr_check_sanity(hdr);
  918|      0|    return 0;
  919|      0|}
bcf_hdr_init:
 1066|     20|{
 1067|     20|    int i;
 1068|     20|    bcf_hdr_t *h;
 1069|     20|    h = (bcf_hdr_t*)calloc(1, sizeof(bcf_hdr_t));
 1070|     20|    if (!h) return NULL;
 1071|     80|    for (i = 0; i < 3; ++i)
 1072|     60|        if ((h->dict[i] = kh_init(vdict)) == NULL) goto fail;
 1073|     20|    if ( strchr(mode,'w') )
 1074|      0|    {
 1075|      0|        bcf_hdr_append(h, "##fileformat=VCFv4.2");
 1076|       |        // The filter PASS must appear first in the dictionary
 1077|      0|        bcf_hdr_append(h, "##FILTER=<ID=PASS,Description=\"All filters passed\">");
 1078|      0|    }
 1079|     20|    return h;
 1080|       |
 1081|      0| fail:
 1082|      0|    for (i = 0; i < 3; ++i)
 1083|      0|        kh_destroy(vdict, h->dict[i]);
 1084|      0|    free(h);
 1085|      0|    return NULL;
 1086|     20|}
bcf_hdr_destroy:
 1089|     20|{
 1090|     20|    int i;
 1091|     20|    khint_t k;
 1092|     20|    if (!h) return;
 1093|     80|    for (i = 0; i < 3; ++i) {
 1094|     60|        vdict_t *d = (vdict_t*)h->dict[i];
 1095|     60|        if (d == 0) continue;
 1096|     88|        for (k = kh_begin(d); k != kh_end(d); ++k)
 1097|     28|            if (kh_exist(d, k)) free((char*)kh_key(d, k));
 1098|     60|        kh_destroy(vdict, d);
 1099|     60|        free(h->id[i]);
 1100|     60|    }
 1101|     34|    for (i=0; i<h->nhrec; i++)
 1102|     14|        bcf_hrec_destroy(h->hrec[i]);
 1103|     20|    if (h->nhrec) free(h->hrec);
 1104|     20|    if (h->samples) free(h->samples);
 1105|     20|    free(h->keep_samples);
 1106|     20|    free(h->transl[0]); free(h->transl[1]);
 1107|     20|    free(h->mem.s);
 1108|     20|    free(h);
 1109|     20|}
bcf_hdr_read:
 1112|     20|{
 1113|     20|    if (hfp->format.format == vcf)
 1114|     12|        return vcf_hdr_read(hfp);
 1115|      8|    if (hfp->format.format != bcf) {
 1116|      0|        hts_log_error("Input is not detected as bcf or vcf format");
 1117|      0|        return NULL;
 1118|      0|    }
 1119|       |
 1120|      8|    assert(hfp->is_bgzf);
 1121|       |
 1122|      8|    BGZF *fp = hfp->fp.bgzf;
 1123|      8|    uint8_t magic[5];
 1124|      8|    bcf_hdr_t *h;
 1125|      8|    h = bcf_hdr_init("r");
 1126|      8|    if (!h) {
 1127|      0|        hts_log_error("Failed to allocate bcf header");
 1128|      0|        return NULL;
 1129|      0|    }
 1130|      8|    if (bgzf_read(fp, magic, 5) != 5)
 1131|      2|    {
 1132|      2|        hts_log_error("Failed to read the header (reading BCF in text mode?)");
 1133|      2|        bcf_hdr_destroy(h);
 1134|      2|        return NULL;
 1135|      2|    }
 1136|      6|    if (strncmp((char*)magic, "BCF\2\2", 5) != 0)
 1137|      4|    {
 1138|      4|        if (!strncmp((char*)magic, "BCF", 3))
 1139|      4|            hts_log_error("Invalid BCF2 magic string: only BCFv2.2 is supported");
 1140|      4|        else
 1141|      0|            hts_log_error("Invalid BCF2 magic string");
 1142|      4|        bcf_hdr_destroy(h);
 1143|      4|        return NULL;
 1144|      4|    }
 1145|      2|    uint8_t buf[4];
 1146|      2|    size_t hlen;
 1147|      2|    char *htxt = NULL;
 1148|      2|    if (bgzf_read(fp, buf, 4) != 4) goto fail;
 1149|      1|    hlen = buf[0] | (buf[1] << 8) | (buf[2] << 16) | ((size_t) buf[3] << 24);
 1150|      1|    if (hlen >= SIZE_MAX) { errno = ENOMEM; goto fail; }
 1151|      1|    htxt = (char*)malloc(hlen + 1);
 1152|      1|    if (!htxt) goto fail;
 1153|      1|    if (bgzf_read(fp, htxt, hlen) != hlen) goto fail;
 1154|      0|    htxt[hlen] = '\0'; // Ensure htxt is terminated
 1155|      0|    if ( bcf_hdr_parse(h, htxt) < 0 ) goto fail;
 1156|      0|    free(htxt);
 1157|      0|    return h;
 1158|      2| fail:
 1159|      2|    hts_log_error("Failed to read BCF header");
 1160|      2|    free(htxt);
 1161|      2|    bcf_hdr_destroy(h);
 1162|      2|    return NULL;
 1163|      0|}
vcf_hdr_read:
 1902|     12|{
 1903|     12|    kstring_t txt, *s = &fp->line;
 1904|     12|    int ret;
 1905|     12|    bcf_hdr_t *h;
 1906|     12|    tbx_t *idx = NULL;
 1907|     12|    const char **names = NULL;
 1908|     12|    h = bcf_hdr_init("r");
 1909|     12|    if (!h) {
 1910|      0|        hts_log_error("Failed to allocate bcf header");
 1911|      0|        return NULL;
 1912|      0|    }
 1913|     12|    txt.l = txt.m = 0; txt.s = 0;
 1914|     35|    while ((ret = hts_getline(fp, KS_SEP_LINE, s)) >= 0) {
 1915|     28|        int e = 0;
 1916|     28|        if (s->l == 0) continue;
 1917|     17|        if (s->s[0] != '#') {
 1918|      5|            hts_log_error("No sample line");
 1919|      5|            goto error;
 1920|      5|        }
 1921|     12|        if (s->s[1] != '#' && fp->fn_aux) { // insert contigs here
 1922|      0|            kstring_t tmp = { 0, 0, NULL };
 1923|      0|            hFILE *f = hopen(fp->fn_aux, "r");
 1924|      0|            if (f == NULL) {
 1925|      0|                hts_log_error("Couldn't open \"%s\"", fp->fn_aux);
 1926|      0|                goto error;
 1927|      0|            }
 1928|      0|            while (tmp.l = 0, kgetline(&tmp, (kgets_func *) hgets, f) >= 0) {
 1929|      0|                char *tab = strchr(tmp.s, '\t');
 1930|      0|                if (tab == NULL) continue;
 1931|      0|                e |= (kputs("##contig=<ID=", &txt) < 0);
 1932|      0|                e |= (kputsn(tmp.s, tab - tmp.s, &txt) < 0);
 1933|      0|                e |= (kputs(",length=", &txt) < 0);
 1934|      0|                e |= (kputl(atol(tab), &txt) < 0);
 1935|      0|                e |= (kputsn(">\n", 2, &txt) < 0);
 1936|      0|            }
 1937|      0|            free(tmp.s);
 1938|      0|            if (hclose(f) != 0) {
 1939|      0|                hts_log_error("Error on closing %s", fp->fn_aux);
 1940|      0|                goto error;
 1941|      0|            }
 1942|      0|            if (e) goto error;
 1943|     12|        }
 1944|     12|        if (kputsn(s->s, s->l, &txt) < 0) goto error;
 1945|     12|        if (kputc('\n', &txt) < 0) goto error;
 1946|     12|        if (s->s[1] != '#') break;
 1947|     12|    }
 1948|      7|    if ( ret < -1 ) goto error;
 1949|      7|    if ( !txt.s )
 1950|      0|    {
 1951|      0|        hts_log_error("Could not read the header");
 1952|      0|        goto error;
 1953|      0|    }
 1954|      7|    if ( bcf_hdr_parse(h, txt.s) < 0 ) goto error;
 1955|       |
 1956|       |    // check tabix index, are all contigs listed in the header? add the missing ones
 1957|      0|    idx = tbx_index_load3(fp->fn, NULL, HTS_IDX_SILENT_FAIL);
 1958|      0|    if ( idx )
 1959|      0|    {
 1960|      0|        int i, n, need_sync = 0;
 1961|      0|        names = tbx_seqnames(idx, &n);
 1962|      0|        if (!names) goto error;
 1963|      0|        for (i=0; i<n; i++)
 1964|      0|        {
 1965|      0|            bcf_hrec_t *hrec = bcf_hdr_get_hrec(h, BCF_HL_CTG, "ID", (char*) names[i], NULL);
 1966|      0|            if ( hrec ) continue;
 1967|      0|            if (add_missing_contig_hrec(h, names[i]) < 0) goto error;
 1968|      0|            need_sync = 1;
 1969|      0|        }
 1970|      0|        if ( need_sync ) {
 1971|      0|            if (bcf_hdr_sync(h) < 0) goto error;
 1972|      0|        }
 1973|      0|        free(names);
 1974|      0|        tbx_destroy(idx);
 1975|      0|    }
 1976|      0|    free(txt.s);
 1977|      0|    return h;
 1978|       |
 1979|     12| error:
 1980|     12|    if (idx) tbx_destroy(idx);
 1981|     12|    free(names);
 1982|     12|    free(txt.s);
 1983|     12|    if (h) bcf_hdr_destroy(h);
 1984|     12|    return NULL;
 1985|      0|}
vcf.c:is_escaped:
  380|      7|{
  381|      7|    int n = 0;
  382|      7|    while ( --str>=min && *str=='\\' ) n++;
  383|      7|    return n%2;
  384|      7|}
vcf.c:bcf_hdr_register_hrec:
  552|     21|{
  553|       |    // contig
  554|     21|    int i, ret, replacing = 0;
  555|     21|    khint_t k;
  556|     21|    char *str = NULL;
  557|       |
  558|     21|    if ( !strcmp(hrec->key, "contig") )
  559|      0|    {
  560|      0|        hts_pos_t len = 0;
  561|      0|        hrec->type = BCF_HL_CTG;
  562|       |
  563|       |        // Get the contig ID ($str) and length ($j)
  564|      0|        i = bcf_hrec_find_key(hrec,"length");
  565|      0|        if ( i<0 ) len = 0;
  566|      0|        else {
  567|      0|            char *end = hrec->vals[i];
  568|      0|            len = strtoll(hrec->vals[i], &end, 10);
  569|      0|            if (end == hrec->vals[i] || len < 0) return 0;
  570|      0|        }
  571|       |
  572|      0|        i = bcf_hrec_find_key(hrec,"ID");
  573|      0|        if ( i<0 ) return 0;
  574|      0|        str = strdup(hrec->vals[i]);
  575|      0|        if (!str) return -1;
  576|       |
  577|       |        // Register in the dictionary
  578|      0|        vdict_t *d = (vdict_t*)hdr->dict[BCF_DT_CTG];
  579|      0|        khint_t k = kh_get(vdict, d, str);
  580|      0|        if ( k != kh_end(d) ) { // already present
  581|      0|            free(str); str=NULL;
  582|      0|            if (kh_val(d, k).hrec[0] != NULL) // and not removed
  583|      0|                return 0;
  584|      0|            replacing = 1;
  585|      0|        } else {
  586|      0|            k = kh_put(vdict, d, str, &ret);
  587|      0|            if (ret < 0) { free(str); return -1; }
  588|      0|        }
  589|       |
  590|      0|        int idx = bcf_hrec_find_key(hrec,"IDX");
  591|      0|        if ( idx!=-1 )
  592|      0|        {
  593|      0|            char *tmp = hrec->vals[idx];
  594|      0|            idx = strtol(hrec->vals[idx], &tmp, 10);
  595|      0|            if ( *tmp || idx < 0 || idx >= INT_MAX - 1)
  596|      0|            {
  597|      0|                if (!replacing) {
  598|      0|                    kh_del(vdict, d, k);
  599|      0|                    free(str);
  600|      0|                }
  601|      0|                hts_log_warning("Error parsing the IDX tag, skipping");
  602|      0|                return 0;
  603|      0|            }
  604|      0|        }
  605|       |
  606|      0|        kh_val(d, k) = bcf_idinfo_def;
  607|      0|        kh_val(d, k).id = idx;
  608|      0|        kh_val(d, k).info[0] = len;
  609|      0|        kh_val(d, k).hrec[0] = hrec;
  610|      0|        if (bcf_hdr_set_idx(hdr, BCF_DT_CTG, kh_key(d,k), &kh_val(d,k)) < 0) {
  611|      0|            if (!replacing) {
  612|      0|                kh_del(vdict, d, k);
  613|      0|                free(str);
  614|      0|            }
  615|      0|            return -1;
  616|      0|        }
  617|      0|        if ( idx==-1 ) {
  618|      0|            if (hrec_add_idx(hrec, kh_val(d,k).id) < 0) {
  619|      0|               return -1;
  620|      0|            }
  621|      0|        }
  622|       |
  623|      0|        return 1;
  624|      0|    }
  625|       |
  626|     21|    if ( !strcmp(hrec->key, "INFO") ) hrec->type = BCF_HL_INFO;
  627|     21|    else if ( !strcmp(hrec->key, "FILTER") ) hrec->type = BCF_HL_FLT;
  628|     14|    else if ( !strcmp(hrec->key, "FORMAT") ) hrec->type = BCF_HL_FMT;
  629|     14|    else if ( hrec->nkeys>0 ) { hrec->type = BCF_HL_STR; return 1; }
  630|     14|    else return 0;
  631|       |
  632|       |    // INFO/FILTER/FORMAT
  633|      7|    char *id = NULL;
  634|      7|    uint32_t type = UINT32_MAX, var = UINT32_MAX;
  635|      7|    int num = -1, idx = -1;
  636|     21|    for (i=0; i<hrec->nkeys; i++)
  637|     14|    {
  638|     14|        if ( !strcmp(hrec->keys[i], "ID") ) id = hrec->vals[i];
  639|      7|        else if ( !strcmp(hrec->keys[i], "IDX") )
  640|      0|        {
  641|      0|            char *tmp = hrec->vals[i];
  642|      0|            idx = strtol(hrec->vals[i], &tmp, 10);
  643|      0|            if ( *tmp || idx < 0 || idx >= INT_MAX - 1)
  644|      0|            {
  645|      0|                hts_log_warning("Error parsing the IDX tag, skipping");
  646|      0|                return 0;
  647|      0|            }
  648|      7|        }
  649|      7|        else if ( !strcmp(hrec->keys[i], "Type") )
  650|      0|        {
  651|      0|            if ( !strcmp(hrec->vals[i], "Integer") ) type = BCF_HT_INT;
  652|      0|            else if ( !strcmp(hrec->vals[i], "Float") ) type = BCF_HT_REAL;
  653|      0|            else if ( !strcmp(hrec->vals[i], "String") ) type = BCF_HT_STR;
  654|      0|            else if ( !strcmp(hrec->vals[i], "Character") ) type = BCF_HT_STR;
  655|      0|            else if ( !strcmp(hrec->vals[i], "Flag") ) type = BCF_HT_FLAG;
  656|      0|            else
  657|      0|            {
  658|      0|                hts_log_warning("The type \"%s\" is not supported, assuming \"String\"", hrec->vals[i]);
  659|      0|                type = BCF_HT_STR;
  660|      0|            }
  661|      0|        }
  662|      7|        else if ( !strcmp(hrec->keys[i], "Number") )
  663|      0|        {
  664|      0|            if ( !strcmp(hrec->vals[i],"A") ) var = BCF_VL_A;
  665|      0|            else if ( !strcmp(hrec->vals[i],"R") ) var = BCF_VL_R;
  666|      0|            else if ( !strcmp(hrec->vals[i],"G") ) var = BCF_VL_G;
  667|      0|            else if ( !strcmp(hrec->vals[i],".") ) var = BCF_VL_VAR;
  668|      0|            else
  669|      0|            {
  670|      0|                sscanf(hrec->vals[i],"%d",&num);
  671|      0|                var = BCF_VL_FIXED;
  672|      0|            }
  673|      0|            if (var != BCF_VL_FIXED) num = 0xfffff;
  674|      0|        }
  675|     14|    }
  676|      7|    if (hrec->type == BCF_HL_INFO || hrec->type == BCF_HL_FMT) {
  677|      0|        if (type == -1) {
  678|      0|            hts_log_warning("%s %s field has no Type defined. Assuming String",
  679|      0|                *hrec->key == 'I' ? "An" : "A", hrec->key);
  680|      0|            type = BCF_HT_STR;
  681|      0|        }
  682|      0|        if (var == -1) {
  683|      0|            hts_log_warning("%s %s field has no Number defined. Assuming '.'",
  684|      0|                *hrec->key == 'I' ? "An" : "A", hrec->key);
  685|      0|            var = BCF_VL_VAR;
  686|      0|        }
  687|      0|    }
  688|      7|    uint32_t info = ((((uint32_t)num) & 0xfffff)<<12 |
  689|      7|                     (var & 0xf) << 8 |
  690|      7|                     (type & 0xf) << 4 |
  691|      7|                     (((uint32_t) hrec->type) & 0xf));
  692|       |
  693|      7|    if ( !id ) return 0;
  694|      7|    str = strdup(id);
  695|      7|    if (!str) return -1;
  696|       |
  697|      7|    vdict_t *d = (vdict_t*)hdr->dict[BCF_DT_ID];
  698|      7|    k = kh_get(vdict, d, str);
  699|      7|    if ( k != kh_end(d) )
  700|      0|    {
  701|       |        // already present
  702|      0|        free(str);
  703|      0|        if ( kh_val(d, k).hrec[info&0xf] ) return 0;
  704|      0|        kh_val(d, k).info[info&0xf] = info;
  705|      0|        kh_val(d, k).hrec[info&0xf] = hrec;
  706|      0|        if ( idx==-1 ) {
  707|      0|            if (hrec_add_idx(hrec, kh_val(d, k).id) < 0) {
  708|      0|                return -1;
  709|      0|            }
  710|      0|        }
  711|      0|        return 1;
  712|      0|    }
  713|      7|    k = kh_put(vdict, d, str, &ret);
  714|      7|    if (ret < 0) {
  715|      0|        free(str);
  716|      0|        return -1;
  717|      0|    }
  718|      7|    kh_val(d, k) = bcf_idinfo_def;
  719|      7|    kh_val(d, k).info[info&0xf] = info;
  720|      7|    kh_val(d, k).hrec[info&0xf] = hrec;
  721|      7|    kh_val(d, k).id = idx;
  722|      7|    if (bcf_hdr_set_idx(hdr, BCF_DT_ID, kh_key(d,k), &kh_val(d,k)) < 0) {
  723|      0|        kh_del(vdict, d, k);
  724|      0|        free(str);
  725|      0|        return -1;
  726|      0|    }
  727|      7|    if ( idx==-1 ) {
  728|      7|        if (hrec_add_idx(hrec, kh_val(d,k).id) < 0) {
  729|      0|            return -1;
  730|      0|        }
  731|      7|    }
  732|       |
  733|      7|    return 1;
  734|      7|}
vcf.c:bcf_hdr_set_idx:
  522|      7|{
  523|      7|    size_t new_n;
  524|       |
  525|       |    // If available, preserve existing IDX
  526|      7|    if ( idinfo->id==-1 )
  527|      7|        idinfo->id = hdr->n[dict_type];
  528|      0|    else if ( idinfo->id < hdr->n[dict_type] && hdr->id[dict_type][idinfo->id].key )
  529|      0|    {
  530|      0|        hts_log_error("Conflicting IDX=%d lines in the header dictionary, the new tag is %s",
  531|      0|            idinfo->id, tag);
  532|      0|        errno = EINVAL;
  533|      0|        return -1;
  534|      0|    }
  535|       |
  536|      7|    new_n = idinfo->id >= hdr->n[dict_type] ? idinfo->id+1 : hdr->n[dict_type];
  537|      7|    if (hts_resize(bcf_idpair_t, new_n, &hdr->m[dict_type],
  538|      0|                   &hdr->id[dict_type], HTS_RESIZE_CLEAR)) {
  539|      0|        return -1;
  540|      0|    }
  541|      7|    hdr->n[dict_type] = new_n;
  542|       |
  543|       |    // NB: the next kh_put call can invalidate the idinfo pointer, therefore
  544|       |    // we leave it unassigned here. It must be set explicitly in bcf_hdr_sync.
  545|      7|    hdr->id[dict_type][idinfo->id].key = tag;
  546|       |
  547|      7|    return 0;
  548|      7|}

